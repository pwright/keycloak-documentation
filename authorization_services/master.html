<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Authorization Services Guide</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="node_modules/reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="node_modules/reveal.js/css/theme/black.css" id="theme"><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link href="node_modules/reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "node_modules/reveal.js/css/print/pdf.css" : "node_modules/reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="node_modules/reveal.js/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Authorization Services Guide</h1></section><section><section id="_overview"><h2>Overview</h2><div class="paragraph"><p>Red Hat Single Sign-On supports fine-grained authorization policies and is able to combine different access control
mechanisms such as:</p></div><div class="ulist"><ul><li><p><strong>Attribute-based access control (ABAC)</strong></p></li><li><p><strong>Role-based access control (RBAC)</strong></p></li><li><p><strong>User-based access control (UBAC)</strong></p></li><li><p><strong>Context-based access control (CBAC)</strong></p></li><li><p><strong>Rule-based access control</strong></p><div class="ulist"><ul><li><p>Using JavaScript</p></li><li><p>Using JBoss Drools</p></li></ul></div></li><li><p><strong>Time-based access control</strong></p></li><li><p><strong>Support for custom access control mechanisms (ACMs) through a Policy Provider Service Provider Interface (SPI)</strong></p></li></ul></div><div class="paragraph"><p>Red Hat Single Sign-On is based on a set of administrative UIs and a RESTful API, and provides the necessary means to create permissions
for your protected resources and scopes, associate those permissions with authorization policies, and enforce authorization decisions in your applications and services.</p></div><div class="paragraph"><p>Resource servers (applications or services serving protected resources) usually rely on some kind of information to decide if access should be granted to a protected resource. For RESTful-based resource servers, that information is usually obtained from a security token, usually sent as a bearer token on every request to the server. For web applications that rely on a session to authenticate users, that information is usually stored in a user&#8217;s session and retrieved from there for each request.</p></div><div class="paragraph"><p>Frequently, resource servers only perform authorization decisions based on role-based access control (RBAC), where the roles granted to the user trying to access protected resources are checked against the roles mapped to these same resources. While roles are very useful and used by applications, they also have a few limitations:</p></div><div class="ulist"><ul><li><p>Resources and roles are tightly coupled and changes to roles (such as adding, removing, or changing an access context) can impact multiple resources</p></li><li><p>Changes to your security requirements can imply deep changes to application code to reflect these changes</p></li><li><p>Depending on your application size, role management might become difficult and error-prone</p></li><li><p>It is not the most flexible access control mechanism. Roles do not represent who you are and lack contextual information. If you have been granted a role, you have at least some access.</p></li></ul></div><div class="paragraph"><p>Considering that today we need to consider heterogeneous environments where users are distributed across different regions, with different local policies,
using different devices, and with a high demand for information sharing, Red Hat Single Sign-On Authorization Services can help you improve the authorization capabilities of your applications and services by providing:</p></div><div class="ulist"><ul><li><p>Resource protection using fine-grained authorization policies and different access control mechanisms</p></li><li><p>Centralized Resource, Permission, and Policy Management</p></li><li><p>Centralized Policy Decision Point</p></li><li><p>REST security based on a set of REST-based authorization services</p></li><li><p>Authorization workflows and User-Managed Access</p></li><li><p>The infrastructure to help avoid code replication across projects (and redeploys) and quickly adapt to changes in your security requirements.</p></li></ul></div></section><section id="_overview_architecture"><h2>Architecture</h2><div class="paragraph"><p><span class="image"><img src="images/authz-arch-overview.png" alt="Red Hat Single Sign-On AuthZ Architecture Overview"></span></p></div>
<div class="paragraph"><p>From a design perspective, Authorization Services is based on a well-defined set of authorization patterns providing these capabilities:</p></div>
<div class="ulist"><ul><li><p><strong>Policy Administration Point (PAP)</strong></p><div class="paragraph"><p>Provides a set of UIs based on the Red Hat Single Sign-On Administration Console to manage resource servers, resources, scopes, permissions, and policies.
Part of this is also accomplished remotely through the use of the <a href="#_service_protection_api">Protection API</a>.</p></div></li><li><p><strong>Policy Decision Point (PDP)</strong></p><div class="paragraph"><p>Provides a distributable policy decision point to where authorization requests are sent and policies are evaluated accordingly with the permissions being requested.
For more information, see <a href="#_service_obtaining_permissions">Obtaining Permissions</a>.</p></div></li><li><p><strong>Policy Enforcement Point (PEP)</strong></p><div class="paragraph"><p>Provides implementations for different environments to actually enforce authorization decisions at the resource server side.
Red Hat Single Sign-On provides some built-in <a href="#_enforcer_overview">Policy Enforcers</a>.</p></div></li><li><p><strong>Policy Information Point (PIP)</strong></p><div class="paragraph"><p>Being based on Red Hat Single Sign-On Authentication Server, you can obtain attributes from identities and runtime environment during the evaluation of authorization policies.</p></div></li></ul></div>
<h3>The Authorization Process</h3><div class="paragraph"><p>Three main processes define the necessary steps to understand how to use Red Hat Single Sign-On to enable fine-grained authorization to your applications:</p></div>
<div class="ulist"><ul><li><p><strong>Resource Management</strong></p></li><li><p><strong>Permission and Policy Management</strong></p></li><li><p><strong>Policy Enforcement</strong></p></li></ul></div>
<h4>Resource Management</h4><div class="paragraph"><p><strong>Resource Management</strong> involves all the necessary steps to define what is being protected.</p></div>
<div class="paragraph"><p><span class="image"><img src="images/resource-mgmt-process.png" alt="Resource Management Overview"></span></p></div>
<div class="paragraph"><p>First, you need to specify Red Hat Single Sign-On what are you looking to protect, which usually represents a web application or a set of one or more services. For more information on resource servers see <a href="#_overview_terminology">Terminology</a>.</p></div>
<div class="paragraph"><p>Resource servers are managed using the Red Hat Single Sign-On Administration Console. There you can enable any registered client application as a resource server and start managing the resources and scopes you want to protect.</p></div>
<div class="paragraph"><p><span class="image"><img src="images/rs-r-scopes.png" alt="Resource Server Overview"></span></p></div>
<div class="paragraph"><p>A resource can be a web page, a RESTFul resource, a file in your file system, an EJB, and so on. They can represent a group of resources (just like a Class in Java) or they can represent a single and specific resource.</p></div>
<div class="paragraph"><p>For instance, you might have a <em>Bank Account</em> resource that represents all banking accounts and use it to define the authorization policies that are common to all banking accounts. However, you might want to define specific policies for <em>Alice Account</em> (a resource instance that belongs to a customer), where only the owner is allowed to access some information or perform an operation.</p></div>
<div class="paragraph"><p>Resources can be managed using the Red Hat Single Sign-On Administration Console or the <a href="#_service_protection_api">Protection API</a>. In the latter case, resource servers are able to manage their resources remotely.</p></div>
<div class="paragraph"><p>Scopes usually represent the actions that can be performed on a resource, but they are not limited to that. You can also use scopes to represent one or more attributes within a resource.</p></div>
<h4>Permission and Policy Management</h4><div class="paragraph"><p>Once you have defined your resource server and all the resources you want to protect, you must set up permissions and policies.</p></div>
<div class="paragraph"><p>This process involves all the necessary steps to actually define the security and access requirements that govern your resources.</p></div>
<div class="paragraph"><p><span class="image"><img src="images/policy-mgmt-process.png" alt="Permission and Policy Management Overview"></span></p></div>
<div class="paragraph"><p>Policies define the conditions that must be satisfied to access or perform operations on something (resource or scope), but they are not tied to what they are protecting. They are generic and can be reused to build permissions or even more complex policies.</p></div>
<div class="paragraph"><p>For instance,to allow access to a group of resources only for users granted with a role "User Premium", you can use RBAC (Role-based Access Control).</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On provides a few built-in policy types (and their respective policy providers) covering the most common access control mechanisms. You can even create policies based on rules written using JavaScript or JBoss Drools.</p></div>
<div class="paragraph"><p>Once you have your policies defined, you can start defining your permissions. Permissions are coupled with the resource they are protecting. Here you specify
what you want to protect (resource or scope) and the policies that must be satisfied to grant or deny permission.</p></div>
<h4>Policy Enforcement</h4><div class="paragraph"><p><strong>Policy Enforcement</strong> involves the necessary steps to actually enforce authorization decisions to a resource server. This is achieved by enabling a <strong>Policy Enforcement Point</strong> or PEP at the resource server that is capable of communicating with the authorization server, ask for authorization data and control access to protected resources based on the decisions and permissions returned by the server.</p></div>
<div class="paragraph"><p><span class="image"><img src="images/pep-pattern-diagram.png" alt="PEP Overview"></span></p></div>
<div class="paragraph"><p>Red Hat Single Sign-On provides some built-in <a href="#_enforcer_overview">Policy Enforcers</a> implementations that you can use to protect your applications depending on the platform they are running on.</p></div>
<h3>Authorization Services</h3><div class="paragraph"><p>Authorization services consist of the following RESTFul endpoints:</p></div>
<div class="ulist"><ul><li><p><strong>Token Endpoint</strong></p></li><li><p><strong>Resource Management Endpoint</strong></p></li><li><p><strong>Permission Management Endpoint</strong></p></li></ul></div>
<div class="paragraph"><p>Each of these services provides a specific API covering the different steps involved in the authorization process.</p></div>
<h4>Token Endpoint</h4><div class="paragraph"><p>OAuth2 clients (such as front end applications) can obtain access tokens from the server using the token endpoint and use
these same tokens to access resources protected by a resource server (such as back end services). In the same way,
Red Hat Single Sign-On Authorization Services provide extensions to OAuth2 to allow access tokens to be issued based on the processing
of all policies associated with the resource(s) or scope(s) being requested. This means that resource servers can enforce access
to their protected resources based on the permissions granted by the server and held by an access token. In Red Hat Single Sign-On Authorization Services
the access token with permissions is called a Requesting Party Token or RPT for short.</p></div>
<div class="paragraph"><p>For more information, see <a href="#_service_obtaining_permissions">Obtaining Permissions</a>.</p></div>
<h4>Protection API</h4><div class="paragraph"><p>The <strong>Protection API</strong> is a set of <a href="https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html">UMA-compliant</a> endpoint-providing operations
for resource servers to help them manage their resources, scopes, permissions, and policies associated with them. Only resource servers are allowed to access this API, which also requires a
<strong>uma_protection</strong> scope.</p></div>
<div class="paragraph"><p>The operations provided by the Protection API can be organized in two main groups:</p></div>
<div class="ulist"><ul><li><p><strong>Resource Management</strong></p><div class="ulist"><ul><li><p>Create Resource</p></li><li><p>Delete Resource</p></li><li><p>Find by Id</p></li><li><p>Query</p></li></ul></div></li><li><p><strong>Permission Management</strong></p><div class="ulist"><ul><li><p>Issue Permission Tickets</p></li></ul></div></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">By default, Remote Resource Management is enabled. You can change that using the Red Hat Single Sign-On Administration Console and only allow resource management through the console.</td></tr></table></div>
<div class="paragraph"><p>When using the UMA protocol, the issuance of Permission Tickets by the Protection API is an important part of the whole authorization process. As described in a subsequent section, they represent the permissions being requested by the client and that are sent to the server to obtain a final token with all permissions granted during the evaluation of the permissions and policies associated with the resources and scopes being requested.</p></div>
<div class="paragraph"><p>For more information, see <a href="#_service_protection_api">Protection API</a>.</p></div></section><section id="_overview_terminology"><h2>Terminology</h2><div class="paragraph"><p>Before going further, it is important to understand these terms and concepts introduced by Red Hat Single Sign-On Authorization Services.</p></div>
<h3>Resource Server</h3><div class="paragraph"><p>Per OAuth2 terminology, a resource server is the server hosting the protected resources and capable of accepting and responding to protected resource requests.</p></div>
<div class="paragraph"><p>Resource servers usually rely on some kind of information to decide whether access to a protected resource should be granted. For RESTful-based resource servers,
that information is usually carried in a security token, typically sent as a bearer token along with every request to the server. Web applications that rely on a session to
authenticate users usually store that information in the user&#8217;s session and retrieve it from there for each request.</p></div>
<div class="paragraph"><p>In Red Hat Single Sign-On, any <strong>confidential</strong> client application can act as a resource server. This client&#8217;s resources and their respective scopes are protected and governed by a set of authorization policies.</p></div>
<h3>Resource</h3><div class="paragraph"><p>A resource is part of the assets of an application and the organization. It can be a set of one or more endpoints, a classic web resource such as an HTML page, and so on.
In authorization policy terminology, a resource is the <em>object</em> being protected.</p></div>
<div class="paragraph"><p>Every resource has a unique identifier that can represent a single resource or a set of resources. For instance, you can manage a <em>Banking Account Resource</em> that represents and defines a set of authorization policies for all banking accounts. But you can also have a different resource named <em>Alice&#8217;s Banking Account</em>, which represents a single resource owned by a single customer, which can have its own set of authorization policies.</p></div>
<h3>Scope</h3><div class="paragraph"><p>A resource&#8217;s scope is a bounded extent of access that is possible to perform on a resource. In authorization policy terminology, a scope is one of the potentially many <em>verbs</em> that can logically apply to a resource.</p></div>
<div class="paragraph"><p>It usually indicates what can be done with a given resource. Example of scopes are view, edit, delete, and so on. However, scope can also be related to specific information provided by a resource. In this case, you can have a project resource and a cost scope, where the cost scope is used to define specific policies and permissions for users to access a project&#8217;s cost.</p></div>
<h3>Permission</h3><div class="paragraph"><p>Consider this simple and very common permission:</p></div>
<div class="paragraph"><p>A permission associates the object being protected with the policies that must be evaluated to determine whether access is granted.</p></div>
<div class="ulist"><ul><li><p><strong>X</strong> CAN DO <strong>Y</strong> ON RESOURCE <strong>Z</strong></p><div class="ulist"><ul><li><p>where &#8230;&#8203;</p><div class="ulist"><ul><li><p><strong>X</strong> represents one or more users, roles, or groups, or a combination of them. You can also use claims and context here.</p></li><li><p><strong>Y</strong> represents an action to be performed, for example, write, view, and so on.</p></li><li><p><strong>Z</strong> represents a protected resource, for example, "/accounts".</p></li></ul></div></li></ul></div></li></ul></div>
<div class="paragraph"><p>Red Hat Single Sign-On provides a rich platform for building a range of permission strategies ranging from simple to very complex, rule-based dynamic permissions. It provides flexibility and helps to:</p></div>
<div class="ulist"><ul><li><p>Reduce code refactoring and permission management costs</p></li><li><p>Support a more flexible security model, helping you to easily adapt to changes in your security requirements</p></li><li><p>Make changes at runtime; applications are only concerned about the resources and scopes being protected and not how they are protected.</p></li></ul></div>
<h3>Policy</h3><div class="paragraph"><p>A policy defines the conditions that must be satisfied to grant access to an object. Unlike permissions, you do not specify the object being protected
but rather the conditions that must be satisfied for access to a given object (for example, resource, scope, or both).
Policies are strongly related to the different access control mechanisms (ACMs) that you can use to protect your resources.
With policies, you can implement strategies for attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, or any combination of these.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On leverages the concept of policies and how you define them by providing the concept of aggregated policies, where you can build a "policy of policies" and still control the behavior of the evaluation.
Instead of writing one large policy with all the conditions that must be satisfied for access to a given resource, the policies implementation in Red Hat Single Sign-On Authorization Services follows the divide-and-conquer technique.
That is, you can create individual policies, then reuse them with different permissions and build more complex policies by combining individual policies.</p></div>
<h3>Policy Provider</h3><div class="paragraph"><p>Policy providers are implementations of specific policy types. Red Hat Single Sign-On provides built-in policies, backed by their corresponding
policy providers, and you can create your own policy types to support your specific requirements.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On provides a SPI (Service Provider Interface) that you can use to plug in your own policy provider implementations.</p></div>
<h3>Permission Ticket</h3><div class="paragraph"><p>A permission ticket is a special type of token defined by the User-Managed Access (UMA) specification that provides an opaque structure whose form is determined by the authorization server. This
structure represents the resources and/or scopes being requested by a client, the access context, as well as the policies that must be applied to a request for authorization data (requesting party token [RPT]).</p></div>
<div class="paragraph"><p>In UMA, permission tickets are crucial to support person-to-person sharing and also person-to-organization sharing. Using permission tickets for authorization workflows enables a range of scenarios from simple to complex, where resource owners and resource servers have complete control over their resources based on fine-grained policies that govern the access to these resources.</p></div>
<div class="paragraph"><p>In the UMA workflow, permission tickets are issued by the authorization server to a resource server, which returns the permission ticket to the client trying to access a protected resource. Once the client receives the ticket, it can make a request for an RPT (a final token holding authorization data) by sending the ticket back to the authorization server.</p></div>
<div class="paragraph"><p>For more information on permission tickets, see <a href="#_service_user_managed_access">User-Managed Access</a> and the <a href="https://docs.kantarainitiative.org/uma/wg/oauth-uma-grant-2.0-09.html">UMA</a> specification.</p></div></section></section>
<section><section id="_getting_started_overview"><h2>Getting Started</h2><div class="paragraph"><p>Before you can use this tutorial, you need to complete the installation of Red Hat Single Sign-On and create the initial admin user as shown in the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/getting_started_guide/">Getting Started Guide</a> tutorial.
There is one caveat to this. You have to run a separate JBoss EAP instance on the same machine as Red Hat Single Sign-On Server. This separate instance will run your Java Servlet application. Because of this you will have to run the Red Hat Single Sign-On under a different port so that there are no port conflicts when running on the same machine. Use the <code>jboss.socket.binding.port-offset</code> system property on the command line. The value of this property is a number that will be added to the base value of every port opened by Red Hat Single Sign-On Server.</p></div><div class="paragraph"><p>To boot Red Hat Single Sign-On Server:</p></div><div class="title">Linux/Unix</div><pre class="highlight listingblock"><code>$ .../bin/standalone.sh -Djboss.socket.binding.port-offset=100</code></pre><div class="title">Windows</div><pre class="highlight listingblock"><code>&gt; ...\bin\standalone.bat -Djboss.socket.binding.port-offset=100</code></pre><div class="paragraph"><p>For more details about how to install and configure a JBoss EAP, please follow the steps on the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a> tutorial.</p></div><div class="paragraph"><p>After installing and booting both servers you should be able to access Red Hat Single Sign-On Admin Console at <a href="http://localhost:8180/auth/admin/" class="bare">http://localhost:8180/auth/admin/</a> and also the JBoss EAP instance at
<a href="http://localhost:8080" class="bare">http://localhost:8080</a>.</p></div></section><section id="_getting_started_hello_world_overview"><h2>Securing a Servlet Application</h2><div class="paragraph"><p>The purpose of this getting started guide is to get you up and running as quickly as possible so that you can experiment with and test various authorization features provided by Red Hat Single Sign-On.
This quick tour relies heavily on the default database and server configurations and does not cover complex deployment options.
For more information on features or configuration options, see the appropriate sections in this documentation.</p></div>
<div class="paragraph"><p>This guide explains key concepts about Red Hat Single Sign-On Authorization Services:</p></div>
<div class="ulist"><ul><li><p>Enabling fine-grained authorization for a client application</p></li><li><p>Configuring a client application to be a resource server, with protected resources</p></li><li><p>Defining permissions and authorization policies to govern access to protected resources</p></li><li><p>Enabling policy enforcement in your applications.</p></li></ul></div></section><section id="_getting_started_hello_world_create_realm"><h2>Creating a Realm and a User</h2><div class="paragraph"><p>The first step in this tutorial is to create a realm and a user in that realm. Then, within the realm we will create a single client application, which then becomes a <a href="#_overview_terminology">resource server</a> for which you need to enable authorization services.</p></div>
<div class="paragraph"><p>To create a realm and a user complete the following steps:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Create a realm with a name <strong>hello-world-authz</strong>. Once created, a page similar to the following is displayed:</p><div class="paragraph"><div class="title">Realm hello-world-authz</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/create-realm.png" alt="Realm hello-world-authz"></span></p></div></li><li><p>Create a user for your newly created realm. Click <strong>Users</strong>. The user list page opens.</p></li><li><p>On the right side of the empty user list, click <strong>Add User</strong>.</p></li><li><p>To create a new user, complete the <strong>Username</strong>, <strong>Email</strong>, <strong>First Name</strong>, and <strong>Last Name</strong> fields.
Click the <strong>User Enabled</strong> switch to <strong>On</strong>, and then click <strong>Save</strong>.</p><div class="paragraph"><div class="title">Add User</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/create-user.png" alt="Add User"></span></p></div></li><li><p>Set a password for the user by clicking the <strong>Credentials</strong> tab.</p><div class="paragraph"><div class="title">Set User Password</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/reset-user-pwd.png" alt="Set User Password"></span></p></div></li><li><p>Complete the <strong>New Password</strong> and <strong>Password Confirmation</strong> fields with a password and click the <strong>Temporary</strong> switch to <strong>OFF</strong>.</p></li><li><p>Click <strong>Reset Password</strong> to set the user&#8217;s password.</p></li></ol></div></section><section id="_getting_started_hello_world_enabling_authz_services"><h2>Enabling Authorization Services</h2><div class="paragraph"><p>You can enable authorization services in an existing client application configured to use the OpenID Connect Protocol. You can also create a new client.</p></div>
<div class="paragraph"><p>To create a new client, complete the following steps:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Click <strong>Clients</strong> to start creating a new client application and fill in the <strong>Client ID</strong>, <strong>Client Protocol</strong>, and <strong>Root URL</strong> fields.</p><div class="paragraph"><div class="title">Create Client Application</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/create-client.png" alt="Create Client Application"></span></p></div></li><li><p>Click <strong>Save</strong>. The Client Details page is displayed.</p><div class="paragraph"><div class="title">Client Details</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/enable-authz.png" alt="Client Details"></span></p></div></li><li><p>On the Client Details page, click the <strong>Authorization Enabled</strong> switch to <strong>ON</strong>, and then click <strong>Save</strong>.
A new <strong>Authorization</strong> tab is displayed for the client.</p></li><li><p>Click the <strong>Authorization</strong> tab and an Authorization Settings page similar to the following is displayed:</p><div class="paragraph"><div class="title">Authorization Settings</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/authz-settings.png" alt="Authorization Settings"></span></p></div></li></ol></div>
<div class="paragraph"><p>When you enable authorization services for a client application, Red Hat Single Sign-On automatically creates several <a href="#_resource_server_default_config">default settings</a> for your client authorization configuration.</p></div>
<div class="paragraph"><p>For more information about authorization configuration, see <a href="#_resource_server_enable_authorization">Enabling Authorization Services</a>.</p></div></section><section id="_getting_started_hello_world_deploy"><h2>Build, Deploy, and Test Your Application</h2><div class="paragraph"><p>Now that the <strong>app-authz-vanilla</strong> resource server (or client) is properly configured and authorization services are enabled, it can be deployed to the server.</p></div>
<div class="paragraph"><p>The project and code for the application you are going to deploy is available in <a href="https://github.com/redhat-developer/redhat-sso-quickstarts">Red Hat Single Sign-On Quickstarts Repository</a>.  You will need the following
installed on your machine and available in your PATH before you can continue:</p></div>
<div class="ulist"><ul><li><p>Java JDK 8</p></li><li><p>Apache Maven 3.1.1 or higher</p></li><li><p>Git</p></li></ul></div>
<div class="paragraph"><p>You can obtain the code by cloning the repository at <a href="https://github.com/redhat-developer/redhat-sso-quickstarts" class="bare">https://github.com/redhat-developer/redhat-sso-quickstarts</a>. Use the branch matching the version of Red Hat Single Sign-On in use.</p></div>
<div class="paragraph"><p>Follow these steps to download the code.</p></div>
<div class="title">Clone Project</div><pre class="highlight listingblock"><code>$ git clone https://github.com/redhat-developer/redhat-sso-quickstarts</code></pre>
<div class="paragraph"><p>The application we are about to build and deploy is located at</p></div>
<pre class="highlight listingblock"><code>$ cd redhat-sso-quickstarts/app-authz-jee-vanilla</code></pre>
<h3>Obtaining the Adapter Configuration</h3><div class="paragraph"><p>You must first obtain the adapter configuration before building and deploying the application.</p></div>
<div class="paragraph"><p>To obtain the adapter configuration from the Red Hat Single Sign-On Administration Console, complete the following steps.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Click <strong>Clients</strong>. In the client listing, click the <strong>app-authz-vanilla</strong> client application. The Client Details page opens.</p><div class="paragraph"><div class="title">Client Details</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/enable-authz.png" alt="Client Details"></span></p></div></li><li><p>Click the <strong>Installation</strong> tab. From the Format Option dropdown list, select <strong>Keycloak OIDC JSON</strong>. The adapter configuration is displayed in JSON format. Click <strong>Download</strong>.</p><div class="paragraph"><div class="title">Adapter Configuration</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/adapter-config.png" alt="Adapter Configuration"></span></p></div></li><li><p>Move the file <code>keycloak.json</code> to the <code>app-authz-jee-vanilla/config</code> directory.</p></li><li><p>(optional) By default, the policy enforcer responds with a <code>403</code> status code when the user lacks permission to access protected resources on the resource server. However, you can also specify a redirection URL for unauthorized users. To specify a redirection URL, edit the <strong>keycloak.json</strong> file you updated in step 3 and replace the <code>policy-enforcer</code> configuration with the following:</p><pre class="highlight listingblock"><code class="json language-json">"policy-enforcer": {
    "on-deny-redirect-to" : "/app-authz-vanilla/error.jsp"
}</code></pre>
<div class="paragraph"><p>This change specifies to the policy enforcer to redirect users to a <code>/app-authz-vanilla/error.jsp</code> page if a user does not have the necessary permissions to access a protected resource, rather than an unhelpful <code>403 Unauthorized</code> message.</p></div></li></ol></div>
<h3>Building and Deploying the Application</h3><div class="paragraph"><p>To build and deploy the application execute the following command:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">$ cd redhat-sso-quickstarts/app-authz-jee-vanilla
$ mvn clean package wildfly:deploy</code></pre>
<h3>Testing the Application</h3><div class="paragraph"><p>If your application was successfully deployed you can access it at <a href="http://localhost:8080/app-authz-vanilla">http://localhost:8080/app-authz-vanilla</a>. The Red Hat Single Sign-On Login page opens.</p></div>
<div class="paragraph"><div class="title">Login Page</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/login-page.png" alt="Login Page"></span></p></div>
<div class="paragraph"><p>Log in as <strong>alice</strong> using the password you specified for that user. After authenticating, the following page is displayed:</p></div>
<div class="paragraph"><div class="title">Hello World Authz Main Page</div><p><span class="image"><img src="rhsso-images/getting-started/hello-world/main-page.png" alt="Hello World Authz Main Page"></span></p></div>
<div class="paragraph"><p>The <a href="#_resource_server_default_config">default settings</a> defined by Red Hat Single Sign-On when you enable authorization services for a client application provide a simple
policy that always grants access to the resources protected by this policy.</p></div>
<div class="paragraph"><p>You can start by changing the default permissions and policies and test how your application responds, or even create new policies using the different
<a href="#_policy_overview">policy types</a> provided by Red Hat Single Sign-On.</p></div>
<div class="paragraph"><p>There are a plenty of things you can do now to test this application. For example, you can change the default policy by clicking the Authorization tab for the client, then <code>Policies</code> tab, then click on <code>Default Policy</code> in the list to allow you to change it as follows:</p></div>
<pre class="highlight listingblock"><code class="js language-js">// The default value is $evaluation.grant(),
// let's see what happens when we change it to $evaluation.deny()
$evaluation.deny();</code></pre>
<div class="paragraph"><p>Now, log out of the demo application and log in again. You can no longer access the application.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/getting-started/hello-world/access-denied-page.png" alt="Access Denied Page"></span></p></div>
<div class="paragraph"><p>Let&#8217;s fix that now, but instead of changing the <code>Default Policy</code> code we are going to change the <code>Logic</code> to <code>Negative</code> using the dropdown list below the policy code text area.
That re-enables access to the application as we are negating the result of that policy, which is by default denying all requests for access. Again, before testing this change, be sure to log out and log in again.</p></div>
<h3>Next Steps</h3><div class="paragraph"><p>There are additional things you can do, such as:</p></div>
<div class="ulist"><ul><li><p>Create a scope, define a policy and permission for it, and test it on the application side. Can the user perform an action (or anything else represented by the scope you created)?</p></li><li><p>Create different types of policies such as <a href="#_policy_drools">rule-based</a>, and associate these policies with the <code>Default Permission</code>.</p></li><li><p>Apply multiple policies to the <code>Default Permission</code> and test the behavior. For example, combine multiple policies and change the <code>Decision Strategy</code> accordingly.</p></li><li><p>For more information about how to view and test permissions inside your application see <a href="#_enforcer_authorization_context">Obtaining the Authorization Context</a>.</p></li></ul></div></section><section id="_authorization_quickstarts"><h2>Authorization Quickstarts</h2><div class="paragraph"><p>In addition to the <strong>app-authz-jee-vanilla</strong> quickstart that was used as a sample application in the previous section, the
<a href="https://github.com/redhat-developer/redhat-sso-quickstarts">Red Hat Single Sign-On Quickstarts Repository</a> contains other applications that make use of the authorization services
described in this documentation.</p></div>
<div class="paragraph"><p>The authorization quickstarts have been designed so that authorization services are displayed in different scenarios and
using different technologies and integrations. It is not meant as a comprehensive set of all the possible use cases involving
authorization but they should provide a starting point for users interested in understanding how the authorization services
can be used in their own applications.</p></div>
<div class="paragraph"><p>Each quickstart has a <code>README</code> file with instructions on how to build, deploy, and test the sample application. The following
table provides a brief description of the available authorization quickstarts:</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 1. Authorization Quickstarts</caption><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Name</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-jee-servlet">app-authz-jee-servlet</a></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Demonstrates how to enable fine-grained authorization to a Java EE application in order to protect specific resources and build a dynamic menu based on the permissions obtained from a Keycloak Server.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-jee-vanilla">app-authz-jee-vanilla</a></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Demonstrates how to enable fine-grained authorization to a Java EE application and use the default authorization settings to protect all resources in the application.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-rest-springboot">app-authz-rest-springboot</a></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Demonstrates how to protect a SpringBoot REST service using Keycloak Authorization Services.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-springboot">app-authz-springboot</a></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Demonstrates how to write a SpringBoot Web application where both authentication and authorization aspects are managed by Keycloak.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-uma-photoz">app-authz-uma-photoz</a></p></td><td class="tableblock halign-left valign-top"><p class="tableblock">A simple application based on HTML5+AngularJS+JAX-RS that demonstrates how to enable User-Managed Access to your application and let users to manage permissions for their resources.</p></td></tr></table></section></section>
<section><section id="_resource_server_overview"><h2>Managing Resource Servers</h2><div class="paragraph"><p>According to the OAuth2 specification, a resource server is a server hosting the protected resources and capable of accepting and responding to protected resource requests.</p></div><div class="paragraph"><p>In Red Hat Single Sign-On, resource servers are provided with a rich platform for enabling fine-grained authorization for their protected resources, where authorization decisions can be made based on different access control mechanisms.</p></div><div class="paragraph"><p>Any client application can be configured to support fine-grained permissions. In doing so, you are conceptually turning the client application into a resource server.</p></div></section><section id="_resource_server_create_client"><h2>Creating a Client Application</h2><div class="paragraph"><p>The first step to enable Red Hat Single Sign-On Authorization Services is to create the client application that you want to turn into a resource server.</p></div>
<div class="paragraph"><p>To create a client application, complete the following steps:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Click <strong>Clients</strong>.</p><div class="paragraph"><div class="title">Clients</div><p><span class="image"><img src="rhsso-images/resource-server/client-list.png" alt="Clients"></span></p></div></li><li><p>On this page, click <strong>Create</strong>.</p><div class="paragraph"><div class="title">Create Client</div><p><span class="image"><img src="rhsso-images/resource-server/client-create.png" alt="Create Client"></span></p></div></li><li><p>Type the <code>Client ID</code> of the client. For example, <em>my-resource-server</em>.</p></li><li><p>Type the <code>Root URL</code> for your application. For example:</p><pre class="highlight listingblock"><code>http://${host}:${port}/my-resource-server</code></pre></li><li><p>Click <strong>Save</strong>. The client is created and the client Settings page opens. A page similar to the following is displayed:</p><div class="paragraph"><div class="title">Client Settings</div><p><span class="image"><img src="rhsso-images/resource-server/client-enable-authz.png" alt="Client Settings"></span></p></div></li></ol></div></section><section id="_resource_server_enable_authorization"><h2>Enabling Authorization Services</h2><div class="paragraph"><p>To turn your OIDC Client Application into a resource server and enable fine-grained authorization, click the <strong>Authorization Enabled</strong> switch to <strong>ON</strong> and click <strong>Save</strong>.</p></div>
<div class="paragraph"><div class="title">Enabling Authorization Services</div><p><span class="image"><img src="rhsso-images/resource-server/client-enable-authz.png" alt="Enabling Authorization Services"></span></p></div>
<div class="paragraph"><p>A new Authorization tab is displayed for this client. Click the <strong>Authorization</strong> tab and a page similar to the following is displayed:</p></div>
<div class="paragraph"><div class="title">Resource Server Settings</div><p><span class="image"><img src="rhsso-images/resource-server/authz-settings.png" alt="Resource Server Settings"></span></p></div>
<div class="paragraph"><p>The Authorization tab contains additional sub-tabs covering the different steps that you must follow to actually protect your application&#8217;s resources. Each tab is covered separately by a specific topic in this documentation. But here is a quick description about each one:</p></div>
<div class="ulist"><ul><li><p><strong>Settings</strong></p><div class="paragraph"><p>General settings for your resource server. For more details about this page see the <a href="#resource_server_settings">Resource Server Settings</a> section.</p></div></li><li><p><strong>Resource</strong></p><div class="paragraph"><p>From this page, you can manage your application&#8217;s <a href="#_resource_overview">resources</a>.</p></div></li><li><p><strong>Authorization Scopes</strong></p><div class="paragraph"><p>From this page, you can manage <a href="#_resource_overview">scopes</a>.</p></div></li><li><p><strong>Policies</strong></p><div class="paragraph"><p>From this page, you can manage <a href="#_policy_overview">authorization policies</a> and define the conditions that must be met to grant a permission.</p></div></li><li><p><strong>Permissions</strong></p><div class="paragraph"><p>From this page, you can manage the <a href="#_permission_overview">permissions</a> for your protected resources and scopes by linking them with the policies you created.</p></div></li><li><p><strong>Evaluate</strong></p><div class="paragraph"><p>From this page, you can <a href="#_policy_evaluation_overview">simulate authorization requests</a> and view the result of the evaluation of the permissions and authorization policies you have defined.</p></div></li><li><p><strong>Export Settings</strong></p><div class="paragraph"><p>From this page, you can <a href="#_resource_server_import_config">export</a> the authorization settings to a JSON file.</p></div></li></ul></div>
<h3>Resource Server Settings</h3><div class="paragraph"><p>On the Resource Server Settings page, you can configure the policy enforcement mode, allow remote resource management, and export the authorization configuration settings.</p></div>
<div class="ulist"><ul><li><p><strong>Policy Enforcement Mode</strong></p><div class="paragraph"><p>Specifies how policies are enforced when processing authorization requests sent to the server.</p></div>
<div class="ulist"><ul><li><p><strong>Enforcing</strong></p><div class="paragraph"><p>(default mode) Requests are denied by default even when there is no policy associated with a given resource.</p></div></li><li><p><strong>Permissive</strong></p><div class="paragraph"><p>Requests are allowed even when there is no policy associated with a given resource.</p></div></li><li><p><strong>Disabled</strong></p><div class="paragraph"><p>Disables the evaluation of all policies and allows access to all resources.</p></div></li></ul></div></li><li><p><strong>Decision Strategy</strong></p><div class="paragraph"><p>This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. <code>Affirmative</code> means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. <code>Unanimous</code> means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is <code>Affirmative</code>. Otherwise, a single deny from any permission will also deny access to the resource or scope.</p></div></li><li><p><strong>Remote Resource Management</strong></p><div class="paragraph"><p>Specifies whether resources can be managed remotely by the resource server. If false, resources can be managed only from the administration console.</p></div></li></ul></div></section><section id="_resource_server_default_config"><h2>Default Configuration</h2><div class="paragraph"><p>When you create a resource server, Red Hat Single Sign-On creates a default configuration for your newly created resource server.</p></div>
<div class="paragraph"><p>The default configuration consists of:</p></div>
<div class="ulist"><ul><li><p>A default protected resource representing all resources in your application.</p></li><li><p>A policy that always grants access to the resources protected by this policy.</p></li><li><p>A permission that governs access to all resources based on the default policy.</p></li></ul></div>
<div class="paragraph"><p>The default protected resource is referred to as the <strong>default resource</strong> and you can view it if you navigate to the <strong>Resources</strong> tab.</p></div>
<div class="paragraph"><div class="title">Default Resource</div><p><span class="image"><img src="rhsso-images/resource-server/default-resource.png" alt="Default Resource"></span></p></div>
<div class="paragraph"><p>This resource defines a <code>Type</code>, namely <code>urn:my-resource-server:resources:default</code> and a <code>URI</code> <code>/*</code>. Here, the <code>URI</code> field defines a
wildcard pattern that indicates to Red Hat Single Sign-On that this resource represents all the paths in your application. In other words,
when enabling <a href="#_enforcer_overview">policy enforcement</a> for your application, all the permissions associated with the resource
will be examined before granting access.</p></div>
<div class="paragraph"><p>The <code>Type</code> mentioned previously defines a value that can be used to create <a href="#_permission_typed_resource">typed resource permissions</a> that must be applied
to the default resource or any other resource you create using the same type.</p></div>
<div class="paragraph"><p>The default policy is referred to as the <strong>only from realm policy</strong> and you can view it if you navigate to the <strong>Policies</strong> tab.</p></div>
<div class="paragraph"><div class="title">Default Policy</div><p><span class="image"><img src="rhsso-images/resource-server/default-policy.png" alt="Default Policy"></span></p></div>
<div class="paragraph"><p>This policy is a <a href="#_policy_js">JavaScript-based policy</a> defining a condition that always grants access to the resources protected by this policy. If you click this policy you can see that it defines a rule as follows:</p></div>
<pre class="highlight listingblock"><code class="js language-js">// by default, grants any permission associated with this policy
$evaluation.grant();</code></pre>
<div class="paragraph"><p>Lastly, the default permission is referred to as the <strong>default permission</strong> and you can view it if you navigate to the <strong>Permissions</strong> tab.</p></div>
<div class="paragraph"><div class="title">Default Permission</div><p><span class="image"><img src="rhsso-images/resource-server/default-permission.png" alt="Default Permission"></span></p></div>
<div class="paragraph"><p>This permission is a <a href="#_permission_create_resource">resource-based permission</a>, defining a set of one or more policies that are applied to all resources with a given type.</p></div>
<h3>Changing the Default Configuration</h3><div class="paragraph"><p>You can change the default configuration by removing the default resource, policy, or permission definitions and creating your own.</p></div>
<div class="paragraph"><p>The default resource is created with an <strong>URI</strong> that maps to any resource or path in your application using a <strong>/</strong>* pattern. Before creating your own resources, permissions and policies, make
sure the default configuration doesn&#8217;t conflict with your own settings.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">The default configuration defines a resource that maps to all paths in your application. If you are about to write permissions to your own resources, be sure to remove the <strong>Default Resource</strong> or change its <code><code>URIS</code></code> fields to a more specific paths in your application. Otherwise, the policy associated with the default resource (which by default always grants access) will allow Red Hat Single Sign-On to grant access to any protected resource.</td></tr></table></div></section><section id="_resource_server_import_config"><h2>Export and Import Authorization Configuration</h2><div class="paragraph"><p>The configuration settings for a resource server (or client) can be exported and downloaded. You can also import an existing configuration file for a resource server. Importing and exporting a configuration file is helpful when you want to create an initial configuration for a resource server or to update an existing configuration. The configuration file contains definitions for:</p></div>
<div class="ulist"><ul><li><p>Protected resources and scopes</p></li><li><p>Policies</p></li><li><p>Permissions</p></li></ul></div>
<h3>Exporting a Configuration File</h3><div class="paragraph"><p>To export a configuration file, complete the following steps:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Navigate to the <strong>Resource Server Settings</strong> page.</p></li><li><p>Click the <strong>Export Settings</strong> tab.</p></li><li><p>On this page, click <strong>Export</strong>.</p><div class="paragraph"><div class="title">Export Settings</div><p><span class="image"><img src="rhsso-images/resource-server/authz-export.png" alt="Export Settings"></span></p></div></li></ol></div>
<div class="paragraph"><p>The configuration file is exported in JSON format and displayed in a text area, from which you can copy and paste. You can also click <strong>Download</strong> to download the configuration file and save it.</p></div>
<h3>Importing a Configuration File</h3><div class="paragraph"><p>To import a configuration file, complete the following steps:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Navigate to the <strong>Resource Server Settings</strong> page.</p><div class="paragraph"><div class="title">Import Settings</div><p><span class="image"><img src="rhsso-images/resource-server/authz-settings.png" alt="Import Settings"></span></p></div></li></ol></div>
<div class="paragraph"><p>To import a configuration file for a resource server, click <strong>Select file</strong> to select a file containing the configuration you want to import.</p></div></section></section>
<section><section id="_resource_overview"><h2>Managing Resources and Scopes</h2><div class="paragraph"><p>Resource management is straightforward and generic. After creating a resource server, you can start creating the resources and scopes that you want to protect.
Resources and scopes can be managed by navigating to the <strong>Resource</strong> and <strong>Scope</strong> tabs, respectively.</p></div></section><section id="_resource_view"><h2>Viewing Resources</h2><div class="paragraph"><p>On the <strong>Resource</strong> page, you see a list of the resources associated with a resource server.</p></div>
<div class="paragraph"><div class="title">Resources</div><p><span class="image"><img src="rhsso-images/resource/view.png" alt="Resources"></span></p></div>
<div class="paragraph"><p>The resource list provides information about the protected resources, such as:</p></div>
<div class="ulist"><ul><li><p>Type</p></li><li><p>URIS</p></li><li><p>Owner</p></li><li><p>Associated scopes, if any</p></li><li><p>Associated permissions</p></li></ul></div>
<div class="paragraph"><p>From this list, you can also directly create a permission by clicking <strong>Create Permission</strong> for the resource for which you want to create the permission.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Before creating permissions for your resources, be sure you have already defined the policies that you want to associate with the permission.</td></tr></table></div></section><section id="_resource_create"><h2>Creating Resources</h2><div class="paragraph"><p>Creating a resource is straightforward and generic. Your main concern is the granularity of the resources you create. In other words, resources can
be created to represent a set of one or more resources and the way you define them is crucial to managing permissions.</p></div>
<div class="paragraph"><p>To create a new resource, click <strong>Create</strong> in the right upper corner of the resource listing.</p></div>
<div class="paragraph"><div class="title">Add Resource</div><p><span class="image"><img src="rhsso-images/resource/create.png" alt="Add Resource"></span></p></div>
<div class="paragraph"><p>In Red Hat Single Sign-On, a resource defines a small set of information that is common to different types of resources, such as:</p></div>
<div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing this resource.</p></div></li></ul></div>
<div class="ulist" id="_resource_create_type"><ul><li><p><strong>Type</strong></p><div class="paragraph"><p>A string uniquely identifying the type of a set of one or more resources. The type is a <em>string</em> used to group different resource instances.
For example, the default type for the default resource that is automatically created is <code>urn:resource-server-name:resources:default</code></p></div></li></ul></div>
<div class="ulist" id="_resource_create_uri"><ul><li><p><strong>URIS</strong></p><div class="paragraph"><p>URIS that provides the locations/addresses for the resource. For HTTP resources, the URIS
are usually the relative paths used to serve these resources.</p></div></li><li><p><strong>Scopes</strong></p><div class="paragraph"><p>One or more scopes to associate with the resource.</p></div></li></ul></div>
<h3>Resource Attributes</h3><div class="paragraph"><p>Resources may have attributes associated with them. These attributes can be used to provide additional information about
a resource and to provide additional information to policies when evaluating permissions associated with a resource.</p></div>
<div class="paragraph"><p>Each attribute is a key and value pair where the value can be a set of one or many strings. Multiple values can be defined for an attribute by separating each value with a comma.</p></div>
<h3>Typed Resources</h3><div class="paragraph"><p>The type field of a resource can be used to group different resources together, so they can be protected using a common set of permissions.</p></div>
<h3>Resource Owners</h3><div class="paragraph"><p>Resources also have an owner. By default, resources are owned by the resource server.</p></div>
<div class="paragraph"><p>However, resources can also be associated with users, so you can create permissions based on the resource owner. For example, only the resource owner is allowed to delete or update a given resource.</p></div>
<h3>Managing Resources Remotely</h3><div class="paragraph"><p>Resource management is also exposed through the <a href="#_service_protection_api">Protection API</a> to allow resource servers to remotely manage their resources.</p></div>
<div class="paragraph"><p>When using the Protection API, resource servers can be implemented to manage resources owned by their users. In this case, you can
specify the user identifier to configure a resource as belonging to a specific user.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Red Hat Single Sign-On provides resource servers complete control over their resources. In the future, we should be able to
allow users to control their own resources as well as approve authorization requests and manage permissions, especially when using the UMA protocol.</td></tr></table></div></section></section>
<section><section id="_policy_overview"><h2>Managing Policies</h2><div class="paragraph"><p>As mentioned previously, policies define the conditions that must be satisfied before granting access to an object.</p></div><div class="paragraph"><p>You can view all policies associated with a resource server by clicking the <strong>Policy</strong> tab when editing a resource server.</p></div><div class="paragraph"><div class="title">Policies</div><p><span class="image"><img src="rhsso-images/policy/view.png" alt="Policies"></span></p></div><div class="paragraph"><p>On this tab, you can view the list of previously created policies as well as create and edit a policy.</p></div><div class="paragraph"><p>To create a new policy, in the upper right corner of the policy list, select a policy type from the <code>Create policy</code> dropdown list. Details about each policy type are described in this section.</p></div></section><section id="_policy_user"><h2>User-Based Policy</h2><div class="paragraph"><p>You can use this type of policy to define conditions for your permissions where a set of one or more users is permitted to access an object.</p></div>
<div class="paragraph"><p>To create a new user-based policy, select <strong>User</strong> in the dropdown list in the upper right corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add a User-Based Policy</div><p><span class="image"><img src="rhsso-images/policy/create-user.png" alt="Add User-Based Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string identifying the policy. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this policy.</p></div></li><li><p><strong>Users</strong></p><div class="paragraph"><p>Specifies which users are given access by this policy.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div></section><section id="_policy_rbac"><h2>Role-Based Policy</h2><div class="paragraph"><p>You can use this type of policy to define conditions for your permissions where a set of one or more roles is permitted to access an object.</p></div>
<div class="paragraph"><p>By default, roles added to this policy are not specified as required and the policy will grant access if the user requesting access has been granted any of these roles. However, you can specify a specific role as <a href="#_policy_rbac_required">required</a> if you want to enforce a specific role. You can also combine required and non-required roles, regardless of whether they are realm or client roles.</p></div>
<div class="paragraph"><p>Role policies can be useful when you need more restricted role-based access control (RBAC), where specific roles must be enforced to grant access to an object. For instance, you can enforce that a user must consent to allowing a client application (which is acting on the user&#8217;s behalf) to access the user&#8217;s resources. You can use Red Hat Single Sign-On Client Scope Mapping to enable consent pages or even enforce clients to explicitly provide a scope when obtaining access tokens from a Red Hat Single Sign-On server.</p></div>
<div class="paragraph"><p>To create a new role-based policy, select <strong>Role</strong> in the dropdown list in the upper right corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add Role-Based Policy</div><p><span class="image"><img src="rhsso-images/policy/create-role.png" alt="Add Role-Based Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this policy.</p></div></li><li><p><strong>Realm Roles</strong></p><div class="paragraph"><p>Specifies which <strong>realm</strong> roles are permitted by this policy.</p></div></li><li><p><strong>Client Roles</strong></p><div class="paragraph"><p>Specifies which <strong>client</strong> roles are permitted by this policy. To enable this field must first select a <code>Client</code>.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div>
<h3>Defining a Role as Required</h3><div class="paragraph"><p>When creating a role-based policy, you can specify a specific role as <code>Required</code>. When you do that, the policy will grant access
only if the user requesting access has been granted <strong>all</strong> the <strong>required</strong> roles. Both realm and client roles can be configured as such.</p></div>
<div class="paragraph"><div class="title">Example of Required Role</div><p><span class="image"><img src="rhsso-images/policy/create-role.png" alt="Example of Required Role"></span></p></div>
<div class="paragraph"><p>To specify a role as required, select the <code>Required</code> checkbox for the role you want to configure as required.</p></div>
<div class="paragraph"><p>Required roles can be useful when your policy defines multiple roles but only a subset of them are mandatory. In this case, you can combine realm and client roles to enable an
even more fine-grained role-based access control (RBAC) model for your application. For example, you can have policies specific for a client and require a specific client role associated with that client. Or you can enforce that access is granted only in the presence of a specific realm role. You can also combine both approaches within the same policy.</p></div></section><section id="_policy_js"><h2>JavaScript-Based Policy</h2><div class="paragraph"><p>You can use this type of policy to define conditions for your permissions using JavaScript. It is one of the rule-based policy types
supported by Red Hat Single Sign-On, and provides flexibility to write any policy based on the <a href="#_policy_evaluation_api">Evaluation API</a>.</p></div>
<div class="paragraph"><p>To create a new JavaScript-based policy, select <strong>JavaScript</strong> in the dropdown list in the upper right corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add JavaScript Policy</div><p><span class="image"><img src="rhsso-images/policy/create-js.png" alt="Add JavaScript Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this policy.</p></div></li><li><p><strong>Code</strong></p><div class="paragraph"><p>The JavaScript code providing the conditions for this policy.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div>
<h3>Examples</h3><h4>Checking for attributes from the evaluation context</h4><div class="paragraph"><p>Here is a simple example of a JavaScript-based policy that uses attribute-based access control (ABAC) to define a condition based on an attribute
obtained from the execution context:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var context = $evaluation.getContext();
var contextAttributes = context.getAttributes();

if (contextAttributes.containsValue('kc.client.network.ip_address', '127.0.0.1')) {
    $evaluation.grant();
}</code></pre>
<h4>Checking for attributes from the current identity</h4><div class="paragraph"><p>Here is a simple example of a JavaScript-based policy that uses attribute-based access control (ABAC) to define a condition based on an attribute
obtained associated with the current identity:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();
var attributes = identity.getAttributes();
var email = attributes.getValue('email').asString(0);

if (email.endsWith('@keycloak.org')) {
    $evaluation.grant();
}</code></pre>
<div class="paragraph"><p>Where these attributes are mapped from whatever claim is defined in the token that was used in the authorization request.</p></div>
<h4>Checking for roles granted to the current identity</h4><div class="paragraph"><p>You can also use Role-Based Access Control (RBAC) in your policies. In the example below, we check if a user is granted with a <code>keycloak_user</code> <strong>realm</strong> role:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();

if (identity.hasRealmRole('keycloak_user')) {
    $evaluation.grant();
}</code></pre>
<div class="paragraph"><p>Or you can check if a user is granted with a <code>my-client-role</code> <strong>client</strong> role, where <code>my-client</code> is the client id of the client application:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();

if (identity.hasClientRole('my-client', 'my-client-role')) {
    $evaluation.grant();
}</code></pre>
<h4>Checking for roles granted to an user</h4><div class="paragraph"><p>To check for realm roles granted to an user:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var realm = $evaluation.getRealm();

if (realm.isUserInRealmRole('marta', 'role-a')) {
    $evaluation.grant();
}</code></pre>
<div class="paragraph"><p>Or for client roles granted to an user:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var realm = $evaluation.getRealm();

if (realm.isUserInClientRole('marta', 'my-client', 'some-client-role')) {
    $evaluation.grant();
}</code></pre>
<h4>Checking for roles granted to a group</h4><div class="paragraph"><p>To check for realm roles granted to a group:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var realm = $evaluation.getRealm();

if (realm.isGroupInRole('/Group A/Group D', 'role-a')) {
    $evaluation.grant();
}</code></pre>
<h4>Pushing arbitrary claims to the resource server</h4><div class="paragraph"><p>To push arbitrary claims to the resource server in order to provide additional information on how permissions should be
enforced:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var permission = $evaluation.getPermission();

// decide if permission should be granted

if (granted) {
    permission.addClaim('claim-a', 'claim-a');
    permission.addClaim('claim-a', 'claim-a1');
    permission.addClaim('claim-b', 'claim-b');
}</code></pre>
<h4>Checking for group membership</h4><pre class="highlight listingblock"><code class="javascript language-javascript">var realm = $evaluation.getRealm();

if (realm.isUserInGroup('marta', '/Group A/Group B')) {
    $evaluation.grant();
}</code></pre>
<h4>Mixing different access control mechanisms</h4><div class="paragraph"><p>You can also use a combination of several access control mechanisms. The example below shows how roles(RBAC) and
claims/attributes(ABAC) checks can be used within the same policy. In this case we check if user is granted with <code>admin</code> role
or has an e-mail from <code>keycloak.org</code> domain:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var context = $evaluation.getContext();
var identity = context.getIdentity();
var attributes = identity.getAttributes();
var email = attributes.getValue('email').asString(0);

if (identity.hasRealmRole('admin') || email.endsWith('@keycloak.org')) {
    $evaluation.grant();
}</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">When writing your own rules, keep in mind that the <strong>$evaluation</strong> object is an object implementing <strong>org.keycloak.authorization.policy.evaluation.Evaluation</strong>. For more information about what you can access from this interface, see the <a href="#_policy_evaluation_api">Evaluation API</a>.</td></tr></table></div></section><section id="_policy_drools"><h2>Rule-Based Policy</h2><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>Drools Policy is <strong>Technology Preview</strong> and is not fully supported. This feature is disabled by default.</p></div>
<div class="paragraph"><p>To enable start the server with <code>-Dkeycloak.profile=preview</code>
or <code>-Dkeycloak.profile.feature.authz_drools_policy=enabled</code>
. For more details see <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.</p></div></td></tr></table></div>
<div class="paragraph"><p>With this type of policy you can define conditions for your permissions using <a href="https://www.drools.org/">Drools</a>, which is a rule evaluation environment. It is one of the <em>Rule-Based</em> policy types
supported by Red Hat Single Sign-On, and provides flexibility to write any policy based on the <a href="#_policy_evaluation_api">Evaluation API</a>.</p></div>
<div class="paragraph"><p>To create a new Rule-based policy, in the dropdown list in the right upper corner of the policy listing,
 select <strong>Rule</strong>.</p></div>
<div class="paragraph"><div class="title">Add Rule Policy</div><p><span class="image"><img src="rhsso-images/policy/create-drools.png" alt="Add Rule Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the policy. We strongly suggest that you use names that are closely related with your business and security requirements, so you
can identify them more easily and also know what they actually mean.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string with more details about this policy.</p></div></li><li><p><strong>Policy Maven Artifact</strong></p><div class="paragraph"><p>A Maven groupId-artifactId-version (GAV) pointing to an artifact where the rules are defined. Once you have provided the GAV, you can click <strong>Resolve</strong> to load both <strong>Module</strong> and <strong>Session</strong> fields.</p></div>
<div class="ulist"><ul><li><p>Group Id</p><div class="paragraph"><p>The groupId of the artifact.</p></div></li><li><p>Artifact Id</p><div class="paragraph"><p>The artifactId of the artifact.</p></div></li><li><p>Version</p><div class="paragraph"><p>The version of the artifact.</p></div></li></ul></div></li><li><p><strong>Module</strong></p><div class="paragraph"><p>The module used by this policy. You must provide a module to select a specific session from which rules will be loaded.</p></div></li><li><p><strong>Session</strong></p><div class="paragraph"><p>The session used by this policy. The session provides all the rules to evaluate when processing the policy.</p></div></li><li><p><strong>Update Period</strong></p><div class="paragraph"><p>Specifies an interval for scanning for artifact updates.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div>
<h3>Examples</h3><div class="paragraph"><p>Here is a simple example of a Drools-based policy that uses attribute-based access control (ABAC) to define a condition that evaluates to a GRANT
only if the authenticated user is the owner of the requested resource:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">import org.keycloak.authorization.policy.evaluation.Evaluation;
rule "Authorize Resource Owner"
    dialect "mvel"
    when
       $evaluation : Evaluation(
           $identity: context.identity,
           $permission: permission,
           $permission.resource != null &amp;&amp; $permission.resource.owner.equals($identity.id)
       )
    then
        $evaluation.grant();
end</code></pre>
<div class="paragraph"><p>You can even use another variant of ABAC to obtain attributes from the identity and define a condition accordingly:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">import org.keycloak.authorization.policy.evaluation.Evaluation;
rule "Authorize Using Identity Information"
    dialect "mvel"
    when
       $evaluation : Evaluation(
           $identity: context.identity,
           identity.attributes.containsValue("someAttribute", "you_can_access")
       )
    then
        $evaluation.grant();
end</code></pre>
<div class="paragraph"><p>For more information about what you can access from the <code>org.keycloak.authorization.policy.evaluation.Evaluation</code> interface, see <a href="#_policy_evaluation_api">Evaluation API</a>.</p></div></section><section id="_policy_time"><h2>Time-Based Policy</h2><div class="paragraph"><p>You can use this type of policy to define time conditions for your permissions.</p></div>
<div class="paragraph"><p>To create a new time-based policy, select <strong>Time</strong> in the dropdown list in the upper right corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add Time Policy</div><p><span class="image"><img src="rhsso-images/policy/create-time.png" alt="Add Time Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this policy.</p></div></li><li><p><strong>Not Before</strong></p><div class="paragraph"><p>Defines the time before which access must <strong>not</strong> be granted. Permission is granted only if the current date/time is later than or equal to this value.</p></div></li><li><p><strong>Not On or After</strong></p><div class="paragraph"><p>Defines the time after which access must <strong>not</strong> be granted. Permission is granted only if the current date/time is earlier than or equal to this value.</p></div></li><li><p><strong>Day of Month</strong></p><div class="paragraph"><p>Defines the day of month that access must be granted. You can also specify a range of dates. In this case, permission is granted only if the current day of the month is between or equal to the two values specified.</p></div></li><li><p><strong>Month</strong></p><div class="paragraph"><p>Defines the month that access must be granted. You can also specify a range of months. In this case, permission is granted only if the current month is between or equal to the two values specified.</p></div></li><li><p><strong>Year</strong></p><div class="paragraph"><p>Defines the year that access must be granted. You can also specify a range of years. In this case, permission is granted only if the current year is between or equal to the two values specified.</p></div></li><li><p><strong>Hour</strong></p><div class="paragraph"><p>Defines the hour that access must be granted. You can also specify a range of hours. In this case, permission is granted only if current hour is between or equal to the two values specified.</p></div></li><li><p><strong>Minute</strong></p><div class="paragraph"><p>Defines the minute that access must be granted. You can also specify a range of minutes. In this case, permission is granted only if the current minute is between or equal to the two values specified.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div>
<div class="paragraph"><p>Access is only granted if all conditions are satisfied. Red Hat Single Sign-On will perform an <em>AND</em> based on the outcome of each condition.</p></div></section><section id="_policy_aggregated"><h2>Aggregated Policy</h2><div class="paragraph"><p>As mentioned previously, Red Hat Single Sign-On allows you to build a policy of policies, a concept referred to as policy aggregation. You can use policy aggregation to reuse existing policies to build more complex ones and keep your permissions even more decoupled from the policies that are evaluated during the processing of authorization requests.</p></div>
<div class="paragraph"><p>To create a new aggregated policy, select <strong>Aggregated</strong> in the dropdown list located in the right upper corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add an Aggregated Policy</div><p><span class="image"><img src="rhsso-images/policy/create-aggregated.png" alt="Add Aggregated Policy"></span></p></div>
<div class="paragraph"><p>Let&#8217;s suppose you have a resource called <em>Confidential Resource</em> that can be accessed only by users from the <em>keycloak.org</em> domain and from a certain range of IP addresses.
You can create a single policy with both conditions. However, you want to reuse the domain part of this policy to apply to permissions that operates regardless of the originating network.</p></div>
<div class="paragraph"><p>You can create separate policies for both domain and network conditions and create a third policy based on the combination of these two policies. With an aggregated policy, you can freely combine other policies and then apply the new aggregated policy to any permission you want.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">When creating aggregated policies, be mindful that you are not introducing a circular reference or dependency between policies. If a circular dependency is detected, you cannot create or update the policy.</td></tr></table></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the policy. We strongly suggest that you use names that are closely related with your business and security requirements, so you
can identify them more easily and also know what they mean.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string with more details about this policy.</p></div></li><li><p><strong>Apply Policy</strong></p><div class="paragraph"><p>Defines a set of one or more policies to associate with the aggregated policy. To associate a policy you can either select an existing policy
or create a new one by selecting the type of the policy you want to create.</p></div></li><li><p><strong>Decision Strategy</strong></p><div class="paragraph"><p>The decision strategy for this permission.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div>
<h3>Decision Strategy for Aggregated Policies</h3><div class="paragraph"><p>When creating aggregated policies, you can also define the decision strategy that will be used to determine the final decision based on the outcome from each policy.</p></div>
<div class="ulist"><ul><li><p><strong>Unanimous</strong></p><div class="paragraph"><p>The default strategy if none is provided. In this case, <em>all</em> policies must evaluate to a positive decision for the final decision to be also positive.</p></div></li><li><p><strong>Affirmative</strong></p><div class="paragraph"><p>In this case, <em>at least one</em> policy must evaluate to a positive decision in order for the final decision to be also positive.</p></div></li><li><p><strong>Consensus</strong></p><div class="paragraph"><p>In this case, the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative decisions is the same, the final decision will be negative.</p></div></li></ul></div></section><section id="_policy_client"><h2>Client-Based Policy</h2><div class="paragraph"><p>You can use this type of policy to define conditions for your permissions where a set of one or more clients is permitted to access an object.</p></div>
<div class="paragraph"><p>To create a new client-based policy, select <strong>Client</strong> in the dropdown list in the upper right corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add a Client-Based Policy</div><p><span class="image"><img src="images/policy/create-client.png" alt="Add Client-Based Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string identifying the policy. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this policy.</p></div></li><li><p><strong>Clients</strong></p><div class="paragraph"><p>Specifies which clients are given access by this policy.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div></section><section id="_policy_group"><h2>Group-Based Policy</h2><div class="paragraph"><p>You can use this type of policy to define conditions for your permissions where a set of one or more groups (and their hierarchies) is permitted to access an object.</p></div>
<div class="paragraph"><p>To create a new group-based policy, select <strong>Group</strong> in the dropdown list in the upper right corner of the policy listing.</p></div>
<div class="paragraph"><div class="title">Add Group-Based Policy</div><p><span class="image"><img src="rhsso-images/policy/create-group.png" alt="Add Group-Based Policy"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this policy.</p></div></li><li><p><strong>Groups Claim</strong></p><div class="paragraph"><p>Specifies the name of the claim in the token holding the group names and/or paths. Usually, authorization requests are processed based on an ID Token or Access Token
previously issued to a client acting on behalf of some user. If defined, the token must include a claim from where this policy is going to obtain the groups
the user is a member of. If not defined, user&#8217;s groups are obtained from your realm configuration.</p></div></li><li><p><strong>Groups</strong></p><div class="paragraph"><p>Allows you to select the groups that should be enforced by this policy when evaluating permissions. After adding a group, you can extend access to children of the group
by marking the checkbox <strong>Extend to Children</strong>. If left unmarked, access restrictions only applies to the selected group.</p></div></li><li><p><strong>Logic</strong></p><div class="paragraph"><p>The <a href="#_policy_logic">Logic</a> of this policy to apply after the other conditions have been evaluated.</p></div></li></ul></div>
<h3>Extending Access to Child Groups</h3><div class="paragraph"><p>By default, when you add a group to this policy, access restrictions will only apply to members of the selected group.</p></div>
<div class="paragraph"><p>Under some circumstances, it might be necessary to allow access not only to the group itself but to any child group in the hierarchy. For any group
added you can mark a checkbox <strong>Extend to Children</strong> in order to extend access to child groups.</p></div>
<div class="paragraph"><div class="title">Extending Access to Child Groups</div><p><span class="image"><img src="rhsso-images/policy/create-group-extend-children.png" alt="Extending Access to Child Groups"></span></p></div>
<div class="paragraph"><p>In the example above, the policy is granting access for any user member of <strong>IT</strong> or any of its children.</p></div></section><section id="_policy_logic"><h2>Positive and Negative Logic</h2><div class="paragraph"><p>Policies can be configured with positive or negative logic. Briefly, you can use this option to define whether the policy result should be kept as it is or be negated.</p></div>
<div class="paragraph"><p>For example, suppose you want to create a policy where only users <strong>not</strong> granted with a specific role should be given access. In this case,
you can create a role-based policy using that role and set its <strong>Logic</strong> field to <strong>Negative</strong>. If you keep <strong>Positive</strong>, which
is the default behavior, the policy result will be kept as it is.</p></div></section><section id="_policy_evaluation_api"><h2>Policy Evaluation API</h2><div class="paragraph"><p>When writing rule-based policies using JavaScript or JBoss Drools, Red Hat Single Sign-On provides an Evaluation API that provides useful information to help determine whether a permission should be granted.</p></div>
<div class="paragraph"><p>This API consists of a few interfaces that provide you access to information, such as</p></div>
<div class="ulist"><ul><li><p>The permission being evaluated, representing both the resource and scopes being requested.</p></li><li><p>The attributes associated with the resource being requested</p></li><li><p>Runtime environment and any other attribute associated with the execution context</p></li><li><p>Information about users such as group membership and roles</p></li></ul></div>
<div class="paragraph"><p>The main interface is <strong>org.keycloak.authorization.policy.evaluation.Evaluation</strong>, which defines the following contract:</p></div>
<pre class="highlight listingblock"><code class="java language-java">public interface Evaluation {

    /**
     * Returns the {@link ResourcePermission} to be evaluated.
     *
     * @return the permission to be evaluated
     */
    ResourcePermission getPermission();

    /**
     * Returns the {@link EvaluationContext}. Which provides access to the whole evaluation runtime context.
     *
     * @return the evaluation context
     */
    EvaluationContext getContext();

    /**
     * Returns a {@link Realm} that can be used by policies to query information.
     *
     * @return a {@link Realm} instance
     */
    Realm getRealm();

    /**
     * Grants the requested permission to the caller.
     */
    void grant();

    /**
     * Denies the requested permission.
     */
    void deny();
}</code></pre>
<div class="paragraph"><p>When processing an authorization request, Red Hat Single Sign-On creates an <code>Evaluation</code> instance before evaluating any policy. This instance is then passed to each policy to determine whether access is <strong>GRANT</strong> or <strong>DENY</strong>.</p></div>
<div class="paragraph"><p>Policies determine this by invoking the <code>grant()</code> or <code>deny()</code> methods on an <code>Evaluation</code> instance. By default, the state of the <code>Evaluation</code> instance is denied, which means that your policies must explicitly invoke the <code>grant()</code> method to indicate to the policy evaluation engine that permission should be granted.</p></div>
<div class="paragraph"><p>For more information about the Evaluation API see the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/api_documentation/">JavaDocs</a>.</p></div>
<h3>The Evaluation Context</h3><div class="paragraph"><p>The evaluation context provides useful information to policies during their evaluation.</p></div>
<pre class="highlight listingblock"><code class="java language-java">public interface EvaluationContext {

    /**
     * Returns the {@link Identity} that represents an entity (person or non-person) to which the permissions must be granted, or not.
     *
     * @return the identity to which the permissions must be granted, or not
     */
    Identity getIdentity();

    /**
     * Returns all attributes within the current execution and runtime environment.
     *
     * @return the attributes within the current execution and runtime environment
     */
    Attributes getAttributes();
}</code></pre>
<div class="paragraph"><p>From this interface, policies can obtain:</p></div>
<div class="ulist"><ul><li><p>The authenticated <code>Identity</code></p></li><li><p>Information about the execution context and runtime environment</p></li></ul></div>
<div class="paragraph"><p>The <code>Identity</code> is built based on the OAuth2 Access Token that was sent along with the authorization request, and this construct has access to all claims
extracted from the original token. For example, if you are using a <em>Protocol Mapper</em> to include a custom claim in an OAuth2 Access Token you can also access this claim
from a policy and use it to build your conditions.</p></div>
<div class="paragraph"><p>The <code>EvaluationContext</code> also gives you access to attributes related to both the execution and runtime environments. For now, there only a few built-in attributes.</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 2. Execution and Runtime Attributes</caption><colgroup><col style="width:33.3333%"><col style="width:33.3333%"><col style="width:33.3334%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Name</th><th class="tableblock halign-left valign-top">Description</th><th class="tableblock halign-left valign-top">Type</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">kc.time.date_time</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Current date and time</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">String. Format <code>MM/dd/yyyy hh:mm:ss</code></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">kc.client.network.ip_address</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">IPv4 address of the client</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">kc.client.network.host</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Client&#8217;s host name</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">kc.client.id</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The client id</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">kc.client.user_agent</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The value of the 'User-Agent' HTTP header</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">String[]</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">kc.realm.name</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The name of the realm</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">String</p></td></tr></table></section></section>
<section><section id="_permission_overview"><h2>Managing Permissions</h2><div class="paragraph"><p>A permission associates the object being protected and the policies that must be evaluated to decide whether access should be granted.</p></div><div class="paragraph"><p>After creating the resources you want to protect and the policies you want to use to protect these resources,
you can start managing permissions. To manage permissions, click the <strong>Permissions</strong> tab when editing a resource server.</p></div><div class="paragraph"><div class="title">Permissions</div><p><span class="image"><img src="rhsso-images/permission/view.png" alt="Permissions"></span></p></div><div class="paragraph"><p>Permissions can be created to protect two main types of objects:</p></div><div class="ulist"><ul><li><p><strong>Resources</strong></p></li><li><p><strong>Scopes</strong></p></li></ul></div><div class="paragraph"><p>To create a permission, select the permission type you want to create from the dropdown list in the upper right corner of the permission listing. The following sections describe these two types of objects in more detail.</p></div></section><section id="_permission_create_resource"><h2>Creating Resource-Based Permissions</h2><div class="paragraph"><p>A resource-based permission defines a set of one or more resources to protect using a set of one or more authorization policies.</p></div>
<div class="paragraph"><p>To create a new resource-based permission, select <strong>Resource-based</strong> in the dropdown list in the upper right corner of the permission listing.</p></div>
<div class="paragraph"><div class="title">Add Resource-Based Permission</div><p><span class="image"><img src="rhsso-images/permission/create-resource.png" alt="Add Resource-Based Permission"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the permission. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this permission.</p></div></li></ul></div>
<div class="ulist" id="_permission_create_resource_apply_resource_type"><ul><li><p><strong>Apply To Resource Type</strong></p><div class="paragraph"><p>Specifies if the permission is applied to all resources with a given type. When selecting this field, you are prompted to enter the resource type to protect.</p></div>
<div class="ulist"><ul><li><p>Resource Type</p><div class="paragraph"><p>Defines the resource type to protect. When defined, this permission is evaluated for all resources matching that type.</p></div></li></ul></div></li><li><p><strong>Resources</strong></p><div class="paragraph"><p>Defines a set of one or more resources to protect.</p></div></li><li><p><strong>Apply Policy</strong></p><div class="paragraph"><p>Defines a set of one or more policies to associate with a permission. To associate a policy you can either select an existing policy
or create a new one by selecting the type of the policy you want to create.</p></div></li><li><p><strong>Decision Strategy</strong></p><div class="paragraph"><p>The <a href="#_permission_decision_strategies">Decision Strategy</a> for this permission.</p></div></li></ul></div>
<h3>Typed Resource Permission</h3><div class="paragraph"><p>Resource permissions can also be used to define policies that are to be applied to all resources with a given <a href="#_resource_create_type">type</a>. This form of resource-based permission can be useful when you have resources sharing common access requirements and constraints.</p></div>
<div class="paragraph"><p>Frequently, resources within an application can be categorized (or typed) based on the data they encapsulate or the functionality they provide. For example, a financial application can manage different banking accounts where each one belongs to a specific customer. Although they are different banking accounts, they share common security requirements and constraints that are globally defined by the banking organization. With typed resource permissions, you can define common policies to apply to all banking accounts, such as:</p></div>
<div class="ulist"><ul><li><p>Only the owner can manage his account</p></li><li><p>Only allow access from the owner&#8217;s country and/or region</p></li><li><p>Enforce a specific authentication method</p></li></ul></div>
<div class="paragraph"><p>To create a typed resource permission, click <a href="#_permission_create_resource_apply_resource_type">Apply to Resource Type</a> when creating a new resource-based permission. With <code>Apply to Resource Type</code> set to <code>On</code>,
you can specify the type that you want to protect as well as the policies that are to be applied to govern access to all resources with type you have specified.</p></div>
<div class="paragraph"><div class="title">Example of a Typed Resource Permission</div><p><span class="image"><img src="rhsso-images/permission/typed-resource-perm-example.png" alt="Example of a Typed Resource Permission"></span></p></div></section><section id="_permission_create_scope"><h2>Creating Scope-Based Permissions</h2><div class="paragraph"><p>A scope-based permission defines a set of one or more scopes to protect using a set of one or more authorization policies. Unlike resource-based permissions, you can use this permission type to create permissions not only for a resource, but also for the scopes associated with it, providing more granularity when defining the permissions that govern your resources and the actions that can be performed on them.</p></div>
<div class="paragraph"><p>To create a new scope-based permission, select <strong>Scope-based</strong> in the dropdown list in the upper right corner of the permission listing.</p></div>
<div class="paragraph"><div class="title">Add Scope-Based Permission</div><p><span class="image"><img src="rhsso-images/permission/create-scope.png" alt="Add Scope-Based Permission"></span></p></div>
<h3>Configuration</h3><div class="ulist"><ul><li><p><strong>Name</strong></p><div class="paragraph"><p>A human-readable and unique string describing the permission. A best practice is to use names that are closely related to your business and security requirements, so you
can identify them more easily.</p></div></li><li><p><strong>Description</strong></p><div class="paragraph"><p>A string containing details about this permission.</p></div></li><li><p><strong>Resource</strong></p><div class="paragraph"><p>Restricts the scopes to those associated with the selected resource. If none is selected, all scopes are available.</p></div></li><li><p><strong>Scopes</strong></p><div class="paragraph"><p>Defines a set of one or more scopes to protect.</p></div></li><li><p><strong>Apply Policy</strong></p><div class="paragraph"><p>Defines a set of one or more policies to associate with a permission. To associate a policy you can either select an existing policy
or create a new one by selecting the type of the policy you want to create.</p></div></li><li><p><strong>Decision Strategy</strong></p><div class="paragraph"><p>The <a href="#_permission_decision_strategies">Decision Strategy</a> for this permission.</p></div></li></ul></div></section><section id="_permission_decision_strategies"><h2>Policy Decision Strategies</h2><div class="paragraph"><p>When associating policies with a permission, you can also define a decision strategy to specify how to evaluate the outcome of the associated policies to determine access.</p></div>
<div class="ulist"><ul><li><p><strong>Unanimous</strong></p><div class="paragraph"><p>The default strategy if none is provided. In this case, <em>all</em> policies must evaluate to a positive decision for the final decision to be also positive.</p></div></li><li><p><strong>Affirmative</strong></p><div class="paragraph"><p>In this case, <em>at least one</em> policy must evaluate to a positive decision for the final decision to be also positive.</p></div></li><li><p><strong>Consensus</strong></p><div class="paragraph"><p>In this case, the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative decisions is equal, the final decision will be negative.</p></div></li></ul></div></section></section>
<section><section id="_policy_evaluation_overview"><h2>Evaluating and Testing Policies</h2><div class="paragraph"><p>When designing your policies, you can simulate authorization requests to test how your policies are being evaluated.</p></div><div class="paragraph"><p>You can access the Policy Evaluation Tool by clicking the <code>Evaluate</code> tab when editing a resource server. There you can specify different inputs to simulate real authorization requests and test the effect of your policies.</p></div><div class="paragraph"><p><span class="image"><img src="rhsso-images/policy-evaluation-tool/policy-evaluation-tool.png" alt="Policy Evaluation Tool"></span></p></div></section><section id="_providing_identity_information"><h2>Providing Identity Information</h2><div class="paragraph"><p>The <strong>Identity Information</strong> filters can be used to specify the user requesting permissions.</p></div></section><section id="_providing_contextual_information"><h2>Providing Contextual Information</h2><div class="paragraph"><p>The <strong>Contextual Information</strong> filters can be used to define additional attributes to the evaluation context, so that policies can obtain these same attributes.</p></div></section><section id="_providing_the_permissions"><h2>Providing the Permissions</h2><div class="paragraph"><p>The <strong>Permissions</strong> filters can be used to build an authorization request. You can request permissions for a set of one or more resources and scopes. If you want
to simulate authorization requests based on all protected resources and scopes, click <strong>Add</strong> without specifying any <code>Resources</code> or <code>Scopes</code>.</p></div>
<div class="paragraph"><p>When you&#8217;ve specified your desired values, click <strong>Evaluate</strong>.</p></div></section></section>
<section><section id="_service_overview"><h2>Authorization Services</h2><div class="paragraph"><p>Red Hat Single Sign-On Authorization Services are built on top of well-known standards such as the OAuth2 and User-Managed Access specifications.</p></div><div class="paragraph"><p>OAuth2 clients (such as front end applications) can obtain access tokens from the server using the token endpoint and use
these same tokens to access resources protected by a resource server (such as back end services). In the same way,
Red Hat Single Sign-On Authorization Services provide extensions to OAuth2 to allow access tokens to be issued based on the processing
of all policies associated with the resource(s) or scope(s) being requested. This means that resource servers can enforce access
to their protected resources based on the permissions granted by the server and held by an access token. In Red Hat Single Sign-On Authorization Services
the access token with permissions is called a Requesting Party Token or RPT for short.</p></div><div class="paragraph"><p>In addition to the issuance of RPTs, Red Hat Single Sign-On Authorization Services also provides a set of RESTful endpoints that allow resources servers to manage their protected
resources, scopes, permissions and policies, helping developers to extend or integrate these capabilities into their applications in order to support fine-grained authorization.</p></div></section><section id="_service_authorization_api"><h2>Discovering Authorization Services Endpoints and Metadata</h2><div class="paragraph"><p>Red Hat Single Sign-On provides a discovery document from which clients can obtain all necessary information to interact with
Red Hat Single Sign-On Authorization Services, including endpoint locations and capabilities.</p></div>
<div class="paragraph"><p>The discovery document can be obtained from:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X GET \
  http://${host}:${port}/auth/realms/${realm}/.well-known/uma2-configuration</code></pre>
<div class="paragraph"><p>Where <code>${host}:${port}</code> is the hostname (or IP address) and port where Red Hat Single Sign-On is running and <code>${realm}</code> is the name of
a realm in Red Hat Single Sign-On.</p></div>
<div class="paragraph"><p>As a result, you should get a response as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">{

    // some claims are expected here

    // these are the main claims in the discovery document about Authorization Services endpoints location
    "token_endpoint": "http://${host}:${post}/auth/realms/${realm}/protocol/openid-connect/token",
    "token_introspection_endpoint": "http://${host}:${post}/auth/realms/${realm}/protocol/openid-connect/token/introspect",
    "resource_registration_endpoint": "http://${host}:${post}/auth/realms/${realm}/authz/protection/resource_set",
    "permission_endpoint": "http://${host}:${post}/auth/realms/${realm}/authz/protection/permission",
    "policy_endpoint": "http://${host}:${post}/auth/realms/${realm}/authz/protection/uma-policy"
}</code></pre>
<div class="paragraph"><p>Each of these endpoints expose a specific set of capabilities:</p></div>
<div class="ulist"><ul><li><p><strong>token_endpoint</strong></p><div class="paragraph"><p>A OAuth2-compliant Token Endpoint that supports the <code>urn:ietf:params:oauth:grant-type:uma-ticket</code> grant type. Through this
endpoint clients can send authorization requests and obtain an RPT with all permissions granted by Red Hat Single Sign-On.</p></div></li><li><p><strong>token_introspection_endpoint</strong></p><div class="paragraph"><p>A OAuth2-compliant Token Introspection Endpoint which clients can use to query the server to determine the active state of an RPT
and to determine any other information associated with the token, such as the permissions granted by Red Hat Single Sign-On.</p></div></li><li><p><strong>resource_registration_endpoint</strong></p><div class="paragraph"><p>A UMA-compliant Resource Registration Endpoint which resource servers can use to manage their protected resources and scopes. This endpoint provides
operations create, read, update and delete resources and scopes in Red Hat Single Sign-On.</p></div></li><li><p><strong>permission_endpoint</strong></p><div class="paragraph"><p>A UMA-compliant Permission Endpoint which resource servers can use to manage permission tickets. This endpoint provides
operations create, read, update, and delete permission tickets in Red Hat Single Sign-On.</p></div></li></ul></div></section><section id="_service_obtaining_permissions"><h2>Obtaining Permissions</h2><div class="paragraph"><p>To obtain permissions from Red Hat Single Sign-On you send an authorization request to the token endpoint. As a result, Red Hat Single Sign-On will
evaluate all policies associated with the resource(s) and scope(s) being requested and issue an RPT with all permissions
granted by the server.</p></div>
<div class="paragraph"><p>Clients are allowed to send authorization requests to the token endpoint using the following parameters:</p></div>
<div class="ulist"><ul><li><p><strong>grant_type</strong></p><div class="paragraph"><p>This parameter is <strong>required</strong>. Must be <code>urn:ietf:params:oauth:grant-type:uma-ticket</code>.</p></div></li><li><p><strong>ticket</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. The most recent permission ticket received by the client as part of the UMA authorization process.</p></div></li><li><p><strong>claim_token</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A string representing additional claims that should be considered by the server when evaluating
permissions for the resource(s) and scope(s) being requested. This parameter allows clients to push claims to Red Hat Single Sign-On. For more details about all supported token formats see <code>claim_token_format</code> parameter.</p></div></li><li><p><strong>claim_token_format</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A string indicating the format of the token specified in the <code>claim_token</code> parameter. Red Hat Single Sign-On supports two token
formats: <code>urn:ietf:params:oauth:token-type:jwt</code> and <code><a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken" class="bare">https://openid.net/specs/openid-connect-core-1_0.html#IDToken</a></code>. The <code>urn:ietf:params:oauth:token-type:jwt</code> format
indicates that the <code>claim_token</code> parameter references an access token. The <code><a href="https://openid.net/specs/openid-connect-core-1_0.html#IDToken" class="bare">https://openid.net/specs/openid-connect-core-1_0.html#IDToken</a></code> indicates that the
<code>claim_token</code> parameter references an OpenID Connect ID Token.</p></div></li><li><p><strong>rpt</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A previously issued RPT which permissions should also be evaluated and added in a new one. This parameter
allows clients in possession of an RPT to perform incremental authorization where permissions are added on demand.</p></div></li><li><p><strong>permission</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A string representing a set of one or more resources and scopes the client is seeking access. This parameter can be defined multiple times
in order to request permission for multiple resource and scopes. This parameter is an extension to <code>urn:ietf:params:oauth:grant-type:uma-ticket</code> grant type in order to allow clients to send authorization requests without a
permission ticket. The format of the string must be: <code>RESOURCE_ID#SCOPE_ID</code>. For instance: <code>Resource A#Scope A</code>, <code>Resource A#Scope A, Scope B, Scope C</code>, <code>Resource A</code>, <code>#Scope A</code>.</p></div></li><li><p><strong>audience</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. The client identifier of the resource server to which the client is seeking access. This parameter is mandatory
in case the <code>permission</code> parameter is defined. It serves as a hint to Red Hat Single Sign-On to indicate the context in which permissions should be evaluated.</p></div></li><li><p><strong>response_include_resource_name</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A boolean value indicating to the server whether resource names should be included in the RPT&#8217;s permissions. If false, only the resource
identifier is included.</p></div></li><li><p><strong>response_permissions_limit</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. An integer N that defines a limit for the amount of permissions an RPT can have. When used together with
<code>rpt</code> parameter, only the last N requested permissions will be kept in the RPT.</p></div></li><li><p><strong>submit_request</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A boolean value indicating whether the server should create permission requests to the resources and scopes referenced by a permission ticket.
This parameter only have effect if used together with the <code>ticket</code> parameter as part of a UMA authorization process.</p></div></li><li><p><strong>response_mode</strong></p><div class="paragraph"><p>This parameter is <strong>optional</strong>. A string value indicating how the server should respond to authorization requests. This parameter is specially useful when
you are mainly interested in either the overall decision or the permissions granted by the server, instead of a standard OAuth2 response. Possible values are:</p></div>
<div class="ulist"><ul><li><p><code>decision</code></p><div class="paragraph"><p>Indicates that responses from the server should only represent the overall decision by returning a JSON with the following format:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
    'result': true
}</code></pre>
<div class="paragraph"><p>If the authorization request does not map to any permission, a <code>403</code> HTTP status code is returned instead.</p></div></li><li><p><code>permissions</code></p><div class="paragraph"><p>Indicates that responses from the server should contain any permission granted by the server by returning a JSON with the following format:</p></div>
<pre class="highlight listingblock"><code class="json language-json">[
    {
        'rsid': 'My Resource'
        'scopes': ['view', 'update']
    },

    ...
]</code></pre>
<div class="paragraph"><p>If the authorization request does not map to any permission, a <code>403</code> HTTP status code is returned instead.</p></div></li></ul></div></li></ul></div>
<div class="paragraph"><p>Example of a authorization request when a client is seeking access to two resources protected by a resource server.</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "audience={resource_server_client_id}" \
  --data "permission=Resource A#Scope A" \
  --data "permission=Resource B#Scope B"</code></pre>
<div class="paragraph"><p>Example of a authorization request when a client is seeking access to any resource and scope protected by a resource server.</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "audience={resource_server_client_id}"</code></pre>
<div class="paragraph"><p>Example of an authorization request when a client is seeking access to a UMA protected resource after receiving a permission ticket from
the resource server as part of the authorization process:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "ticket=${permission_ticket}</code></pre>
<div class="paragraph"><p>If Red Hat Single Sign-On assessment process results in issuance of permissions, it issues the RPT with which it has associated
the permissions:</p></div>
<div class="title">Red Hat Single Sign-On responds to the client with the RPT</div><pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 200 OK
Content-Type: application/json
...
{
    "access_token": "${rpt}",
}</code></pre>
<div class="paragraph"><p>The response from the server is just like any other response from the token endpoint when using some other grant type. The RPT can be obtained from
the <code>access_token</code> response parameter. If the client is not authorized, Red Hat Single Sign-On responds with a <code>403</code> HTTP status code:</p></div>
<div class="title">Red Hat Single Sign-On denies the authorization request</div><pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 403 Forbidden
Content-Type: application/json
...
{
    "error": "access_denied",
    "error_description": "request_denied"
}</code></pre>
<h3>Client Authentication Methods</h3><div class="paragraph"><p>Clients need to authenticate to the token endpoint in order to obtain an RPT. When using the <code>urn:ietf:params:oauth:grant-type:uma-ticket</code>
grant type, clients can use any of these authentication methods:</p></div>
<div class="ulist"><ul><li><p><strong>Bearer Token</strong></p><div class="paragraph"><p>Clients should send an access token as a Bearer credential in an HTTP Authorization header to the token endpoint.</p></div>
<div class="title">Example: an authorization request using an access token to authenticate to the token endpoint</div><pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket"</code></pre>
<div class="paragraph"><p>This method is especially useful when the client is acting on behalf of a user.
In this case, the bearer token is an access token previously issued by Red Hat Single Sign-On to some client acting on behalf
of a user (or on behalf of itself). Permissions will be evaluated considering the access context represented by the access token.
For instance, if the access token was issued to Client A acting on behalf of User A, permissions will be granted depending on
the resources and scopes to which User A has access.</p></div></li><li><p><strong>Client Credentials</strong></p><div class="paragraph"><p>Client can use any of the client authentication methods supported by Red Hat Single Sign-On. For instance, client_id/client_secret or JWT.</p></div>
<div class="title">Example: an authorization request using client id and client secret to authenticate to the token endpoint</div><pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Basic cGhvdGg6L7Jl13RmfWgtkk==pOnNlY3JldA==" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket"</code></pre></li></ul></div>
<h3>Pushing Claims</h3><div class="paragraph"><p>When obtaining permissions from the server you can push arbitrary claims in order to have these
claims available to your policies when evaluating permissions.</p></div>
<div class="paragraph"><p>If you are obtaining permissions from the server <strong>without</strong> using a permission ticket (UMA flow), you can send
an authorization request to the token endpoint as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "claim_token=ewogICAib3JnYW5pemF0aW9uIjogWyJhY21lIl0KfQ==" \
  --data "claim_token_format=urn:ietf:params:oauth:token-type:jwt" \
  --data "client_id={resource_server_client_id}" \
  --data "client_secret={resource_server_client_secret}" \
  --data "audience={resource_server_client_id}"</code></pre>
<div class="paragraph"><p>The <code>claim_token</code> parameter expects a BASE64 encoded JSON with a format similar to the example below:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
    "organization" : ["acme"]
}</code></pre>
<div class="paragraph"><p>The format expects one or more claims where the value for each claim must be an array of strings.</p></div>
<h4>Pushing Claims Using UMA</h4><div class="paragraph"><p>For more details about how to push claims when using UMA and permission tickets, please take a look at <a href="#_service_protection_permission_api_papi">Permission API</a></p></div></section><section id="_service_user_managed_access"><h2>User-Managed Access</h2><div class="paragraph"><p>Red Hat Single Sign-On Authorization Services is based on User-Managed Access or UMA for short. UMA is a specification that
enhances OAuth2 capabilities in the following ways:</p></div>
<div class="ulist"><ul><li><p><strong>Privacy</strong></p><div class="paragraph"><p>Nowadays, user privacy is becoming a huge concern, as more and more data and devices are available and connected to the cloud. With
UMA and Red Hat Single Sign-On, resource servers can enhance their capabilities in order to improve how their resources are protected in respect
to user privacy where permissions are granted based on policies defined by the user.</p></div></li><li><p><strong>Party-to-Party Authorization</strong></p><div class="paragraph"><p>Resource owners (e.g.: regular end-users) can manage access to their resources and authorize other parties (e.g: regular end-users)
to access these resources. This is different than OAuth2 where consent is given to a client application acting on behalf of a user, with UMA
resource owners are allowed to consent access to other users, in a completely asynchronous manner.</p></div></li><li><p><strong>Resource Sharing</strong></p><div class="paragraph"><p>Resource owners are allowed to manage permissions to their resources and decide who can access a particular resource and how.
Red Hat Single Sign-On can then act as a sharing management service from which resource owners can manage their resources.</p></div></li></ul></div>
<div class="paragraph"><p>Red Hat Single Sign-On is a UMA 2.0 compliant authorization server that provides most UMA capabilities.</p></div>
<div class="paragraph"><p>As an example, consider a user Alice (resource owner) using an Internet Banking Service (resource server) to manage his Bank Account (resource). One day, Alice decides
to open her bank account to Bob (requesting party), a accounting professional. However, Bob should only have access to view (scope) Alice&#8217;s account.</p></div>
<div class="paragraph"><p>As a resource server, the Internet Banking Service must be able to protect Alice&#8217;s Bank Account. For that, it relies on Red Hat Single Sign-On
Resource Registration Endpoint to create a resource in the server representing Alice&#8217;s Bank Account.</p></div>
<div class="paragraph"><p>At this moment, if Bob tries to access Alice&#8217;s Bank Account, access will be denied. The Internet Banking Service defines a few default
policies for banking accounts. One of them is that only the owner, in this case Alice, is allowed to access her bank account.</p></div>
<div class="paragraph"><p>However, Internet Banking Service in respect to Alice&#8217;s privacy also allows her to change specific policies for the banking account. One of these
policies that she can change is to define which people are allowed to view her bank account. For that, Internet Banking Service relies on Red Hat Single Sign-On
to provide to Alice a space where she can select individuals and the operations (or data) they are allowed to access. At any time, Alice
can revoke access or grant additional permissions to Bob.</p></div>
<h3>Authorization Process</h3><div class="paragraph"><p>In UMA, the authorization process starts when a client tries to access a UMA protected resource server.</p></div>
<div class="paragraph"><p>A UMA protected resource server expects a bearer token in the request where the token is an RPT. When a client requests
a resource at the resource server without a permission ticket:</p></div>
<div class="title">Client requests a protected resource without sending an RPT</div><pre class="highlight listingblock"><code class="bash language-bash">curl -X GET \
  http://${host}:${port}/my-resource-server/resource/1bfdfe78-a4e1-4c2d-b142-fc92b75b986f</code></pre>
<div class="paragraph"><p>The resource server sends a response back to the client with a permission <code>ticket</code> and a <code>as_uri</code> parameter with the location
of a Red Hat Single Sign-On server to where the ticket should be sent in order to obtain an RPT.</p></div>
<div class="title">Resource server responds with a permission ticket</div><pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="${realm}",
    as_uri="https://${host}:${port}/auth/realms/${realm}",
    ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"</code></pre>
<div class="paragraph"><p>The permission ticket is a special type of token issued by Red Hat Single Sign-On Permission API. They represent the permissions being requested (e.g.: resources and scopes)
as well any other information associated with the request. Only resource servers are allowed to create those tokens.</p></div>
<div class="paragraph"><p>Now that the client has a permission ticket and also the location of a Red Hat Single Sign-On server, the client can use the discovery document
to obtain the location of the token endpoint and send an authorization request.</p></div>
<div class="title">Client sends an authorization request to the token endpoint to obtain an RPT</div><pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "ticket=${permission_ticket}</code></pre>
<div class="paragraph"><p>If Red Hat Single Sign-On assessment process results in issuance of permissions, it issues the RPT with which it has associated
the permissions:</p></div>
<div class="title">Red Hat Single Sign-On responds to the client with the RPT</div><pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 200 OK
Content-Type: application/json
...
{
    "access_token": "${rpt}",
}</code></pre>
<div class="paragraph"><p>The response from the server is just like any other response from the token endpoint when using some other grant type. The RPT can be obtained from
the <code>access_token</code> response parameter. In case the client is not authorized to have permissions Red Hat Single Sign-On responds with a <code>403</code> HTTP status code:</p></div>
<div class="title">Red Hat Single Sign-On denies the authorization request</div><pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 403 Forbidden
Content-Type: application/json
...
{
    "error": "access_denied",
    "error_description": "request_denied"
}</code></pre>
<h3>Submitting Permission Requests</h3><div class="paragraph"><p>As part of the authorization process, clients need first to obtain a permission ticket from a UMA protected resource server in order
to exchange it with an RPT at the Red Hat Single Sign-On Token Endpoint.</p></div>
<div class="paragraph"><p>By default, Red Hat Single Sign-On responds with a <code>403</code> HTTP status code and a <code>request_denied</code> error in case the client can not be issued with an RPT.</p></div>
<div class="title">Red Hat Single Sign-On denies the authorization request</div><pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 403 Forbidden
Content-Type: application/json
...
{
    "error": "access_denied",
    "error_description": "request_denied"
}</code></pre>
<div class="paragraph"><p>Such response implies that Red Hat Single Sign-On could not issue an RPT with the permissions represented by a permission ticket.</p></div>
<div class="paragraph"><p>In some situations, client applications may want to start an asynchronous authorization flow and let the owner of the resources
being requested decide whether or not access should be granted. For that, clients can use the <code>submit_request</code> request parameter along
with an authorization request to the token endpoint:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm}/protocol/openid-connect/token \
  -H "Authorization: Bearer ${access_token}" \
  --data "grant_type=urn:ietf:params:oauth:grant-type:uma-ticket" \
  --data "ticket=${permission_ticket} \
  --data "submit_request=true"</code></pre>
<div class="paragraph"><p>When using the <code>submit_request</code> parameter, Red Hat Single Sign-On will persist a permission request for each resource to which access was denied.
Once created, resource owners can check their account and manage their permissions requests.</p></div>
<div class="paragraph"><p>You can think about this functionality as a <code>Request Access</code> button in your application, where users can ask other users for access to their resources.</p></div>
<h3>Managing Access to Users Resources</h3><div class="paragraph"><p>Users can manage access to their resources using the Red Hat Single Sign-On User Account Service. To enable
this functionality, you must first enable User-Managed Access for your realm. To do so,
open the realm settings page in Red Hat Single Sign-On Administration Console and enable the User-Managed Access switch.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/service/account-my-resource.png" alt="My Resources"></span></p></div>
<div class="paragraph"><p>On the left side menu, the <code>My Resources</code> option leads to a page where users are able to:</p></div>
<div class="ulist"><ul><li><p>Manage Permission Requests that <strong>Need my approval</strong></p><div class="paragraph"><p>This section contains a list of all permission requests awaiting approval. These requests are connected to the parties (users) requesting access to
a particular resource. Users are allowed to approve or deny these requests.</p></div></li><li><p>Manage <strong>My resources</strong></p><div class="paragraph"><p>This section contains a list of all resources owned by the user. Users can click on a resource for more details
and share the resource with others.</p></div></li><li><p>Manage <strong>Resources shared with me</strong></p><div class="paragraph"><p>This section contains a list of all resources shared with the user.</p></div></li><li><p>Manage <strong>Your requests waiting approval</strong></p><div class="paragraph"><p>This section contains a list of permission requests sent by the user that are waiting for the approval of another user or
resource owner.</p></div></li></ul></div>
<div class="paragraph"><p>When the user choose to detail own of his resources by clicking on any resource in the "My resources" listing, he is redirected to a
page as follows:</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/service/account-my-resource-detail.png" alt="Resource Detail"></span></p></div>
<div class="paragraph"><p>From this page the users are able to:</p></div>
<div class="ulist"><ul><li><p>Manage <strong>People with access to this resource</strong></p><div class="paragraph"><p>This section contains a list of people with access to this resource. Users are allowed to revoke access by clicking
on the <code>Revoke</code> button or by removing a specific <code>Permission</code>.</p></div></li><li><p>Share the resource with others</p><div class="paragraph"><p>By typing the username or e-mail of another user, the user is able to share the resource and select the permissions he wants to grant access.</p></div></li></ul></div></section><section id="_service_protection_api"><h2>Protection API</h2><div class="paragraph"><p>The Protection API provides a UMA-compliant set of endpoints providing:</p></div>
<div class="ulist"><ul><li><p><strong>Resource Management</strong></p><div class="paragraph"><p>With this endpoint, resource servers can manage their resources remotely and enable <a href="#_enforcer_overview">policy enforcers</a> to query the server for the resources that need protection.</p></div></li><li><p><strong>Permission Management</strong></p><div class="paragraph"><p>In the UMA protocol, resource servers access this endpoint to create permission tickets. Red Hat Single Sign-On also provides
endpoints to manage the state of permissions and query permissions.</p></div></li><li><p><strong>Policy API</strong></p><div class="paragraph"><p>Red Hat Single Sign-On leverages the UMA Protection API to allow resource servers to manage permissions for their users. In addition
to the Resource and Permission APIs, Red Hat Single Sign-On provides a Policy API from where permissions can be set to resources by resource
servers on behalf of their users.</p></div></li></ul></div>
<div class="paragraph"><p>An important requirement for this API is that <em>only</em> resource servers are allowed to access its endpoints using a special OAuth2 access token called a protection API token (PAT).
In UMA, a PAT is a token with the scope <strong>uma_protection</strong>.</p></div>
<h3>What is a PAT and How to Obtain It</h3><div class="paragraph"><p>A <strong>protection API token</strong> (PAT) is a special OAuth2 access token with a scope defined as  <strong>uma_protection</strong>. When you create a resource server, Red Hat Single Sign-On automatically
creates a role, <em>uma_protection</em>, for the corresponding client application and associates it with the client&#8217;s service account.</p></div>
<div class="paragraph"><div class="title">Service Account granted with <strong>uma_protection</strong> role</div><p><span class="image"><img src="rhsso-images/service/rs-uma-protection-role.png" alt="Service Account granted with uma_protection role"></span></p></div>
<div class="paragraph"><p>Resource servers can obtain a PAT from Red Hat Single Sign-On like any other OAuth2 access token. For example, using curl:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d 'grant_type=client_credentials&amp;client_id=${client_id}&amp;client_secret=${client_secret}' \
    "http://localhost:8080/auth/realms/${realm_name}/protocol/openid-connect/token"</code></pre>
<div class="paragraph"><p>The example above is using the <strong>client_credentials</strong> grant type to obtain a PAT from the server. As a result, the server returns a response similar to the following:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
  "access_token": ${PAT},
  "expires_in": 300,
  "refresh_expires_in": 1800,
  "refresh_token": ${refresh_token},
  "token_type": "bearer",
  "id_token": ${id_token},
  "not-before-policy": 0,
  "session_state": "ccea4a55-9aec-4024-b11c-44f6f168439e"
}</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Red Hat Single Sign-On can authenticate your client application in different ways. For simplicity, the <strong>client_credentials</strong> grant type is used here,
which requires a <em>client_id</em> and a <em>client_secret</em>. You can choose to use any supported authentication method.</td></tr></table></div>
<h3>Managing Resources</h3><div class="paragraph"><p>Resource servers can manage their resources remotely using a UMA-compliant endpoint.</p></div>
<pre class="highlight listingblock"><code>http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set</code></pre>
<div class="paragraph"><p>This endpoint provides operations outlined as follows (entire path omitted for clarity):</p></div>
<div class="ulist"><ul><li><p>Create resource set description: POST /resource_set</p></li><li><p>Read resource set description: GET /resource_set/{_id}</p></li><li><p>Update resource set description: PUT /resource_set/{_id}</p></li><li><p>Delete resource set description: DELETE /resource_set/{_id}</p></li><li><p>List resource set descriptions: GET /resource_set</p></li></ul></div>
<div class="paragraph"><p>For more information about the contract for each of these operations, see <a href="https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html#reg-api">UMA Resource Registration API</a>.</p></div>
<h4>Creating a Resource</h4><div class="paragraph"><p>To create a resource you must send an HTTP POST request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -v -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "name":"Tweedl Social Service",
     "type":"http://www.example.com/rsrcs/socialstream/140-compatible",
     "icon_uri":"http://www.example.com/icons/sharesocial.png",
     "resource_scopes":[
         "read-public",
         "post-updates",
         "read-private",
         "http://www.example.com/scopes/all"
      ]
  }'</code></pre>
<div class="paragraph"><p>By default, the owner of a resource is the resource server. If you want to define a different owner, such as an
specific user, you can send a request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -v -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "name":"Alice Resource",
     "owner": "alice"
  }'</code></pre>
<div class="paragraph"><p>Where the property <code>owner</code> can be set with the username or the identifier of the user.</p></div>
<h4>Creating User-Managed Resources</h4><div class="paragraph"><p>By default, resources created via Protection API can not be managed by resource owners through the <a href="#_service_authorization_my_resources">User Account Service</a>.</p></div>
<div class="paragraph"><p>To create resources and allow resource owners to manage these resources, you must set <code>ownerManagedAccess</code> property as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -v -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "name":"Alice Resource",
     "owner": "alice",
     "ownerManagedAccess": true
  }'</code></pre>
<h4>Updating Resources</h4><div class="paragraph"><p>To update an existing resource, send an HTTP PUT request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -v -X PUT \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set/{resource_id} \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '{
     "_id": "Alice Resource",
     "name":"Alice Resource",
     "resource_scopes": [
        "read"
     ]
  }'</code></pre>
<h4>Deleting Resources</h4><div class="paragraph"><p>To delete an existing resource, send an HTTP DELETE request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -v -X DELETE \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set/{resource_id} \
  -H 'Authorization: Bearer '$pat</code></pre>
<h4>Querying Resources</h4><div class="paragraph"><p>To query the resources by <code>id</code>, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set/{resource_id}</code></pre>
<div class="paragraph"><p>To query resources given a <code>name</code>, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?name=Alice Resource</code></pre>
<div class="paragraph"><p>To query resources given an <code>uri</code>, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?uri=/api/alice</code></pre>
<div class="paragraph"><p>To query resources given an <code>owner</code>, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?owner=alice</code></pre>
<div class="paragraph"><p>To query resources given an <code>type</code>, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?type=albums</code></pre>
<div class="paragraph"><p>To query resources given an <code>scope</code>, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${port}/auth/realms/${realm_name}/authz/protection/resource_set?scope=read</code></pre>
<div class="paragraph"><p>When querying the server for permissions use parameters <code>first</code> and <code>max</code> results to limit the result.</p></div>
<h3>Managing Permission Requests</h3><div class="paragraph"><p>Resource servers using the UMA protocol can use a specific endpoint to manage permission requests. This endpoint provides a UMA-compliant flow for registering permission requests and obtaining a permission ticket.</p></div>
<pre class="highlight listingblock"><code>http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission</code></pre>
<div class="paragraph"><p>A <a href="#_overview_terminology_permission_ticket">permission ticket</a> is a special security token type representing a permission request. Per the UMA specification, a permission ticket is:</p></div>
<div class="paragraph"><p><code>A correlation handle that is conveyed from an authorization server to a resource server, from a resource server to a client, and ultimately from a client back to an authorization server, to enable the authorization server to assess the correct policies to apply to a request for authorization data.</code></p></div>
<div class="paragraph"><p>In most cases, you won&#8217;t need to deal with this endpoint directly. Red Hat Single Sign-On provides a <a href="#_enforcer_overview">policy enforcer</a> that enables UMA for your
resource server so it can obtain a permission ticket from the authorization server, return this ticket to client application, and enforce authorization decisions based on a final requesting party token (RPT).</p></div>
<div class="paragraph"><p>The process of obtaining permission tickets from Red Hat Single Sign-On is performed by resource servers and not regular client applications,
where permission tickets are obtained when a client tries to access a protected resource without the necessary grants to access the resource. The issuance of
permission tickets is an important aspects when using UMA as it allows resource servers to:</p></div>
<div class="ulist"><ul><li><p>Abstract from clients the data associated with the resources protected by the resource server</p></li><li><p>Register in the Red Hat Single Sign-On authorization requests which in turn can be used later in workflows to grant access based on the resource&#8217;s owner consent</p></li><li><p>Decouple resource servers from authorization servers and allow them to protect and manage their resources using different authorization servers</p></li></ul></div>
<div class="paragraph"><p>Client wise, a permission ticket has also important aspects that its worthy to highlight:</p></div>
<div class="ulist"><ul><li><p>Clients don&#8217;t need to know about how authorization data is associated with protected resources. A permission ticket is completely opaque to clients.</p></li><li><p>Clients can have access to resources on different resource servers and protected by different authorization servers</p></li></ul></div>
<div class="paragraph"><p>These are just some of the benefits brought by UMA where other aspects of UMA are strongly based on permission tickets, specially regarding
privacy and user controlled access to their resources.</p></div>
<h4>Creating Permission Ticket</h4><div class="paragraph"><p>To create a permission ticket, send an HTTP POST request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "resource_id": "{resource_id}",
    "resource_scopes": [
      "view"
    ]
  }
]'</code></pre>
<div class="paragraph"><p>When creating tickets you can also push arbitrary claims and associate these claims with the ticket:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission \
  -H 'Authorization: Bearer '$pat \
  -H 'Content-Type: application/json' \
  -d '[
  {
    "resource_id": "{resource_id}",
    "resource_scopes": [
      "view"
    ],
    "claims": {
        "organization": ["acme"]
    }
  }
]'</code></pre>
<div class="paragraph"><p>Where these claims will be available to your policies when evaluating permissions for the resource and scope(s) associated
with the permission ticket.</p></div>
<h4>Other non UMA-compliant endpoints</h4><h5>Creating permission ticket</h5><div class="paragraph"><p>To grant permissions for a specific resource with id {resource_id} to a user with id {user_id}, as an owner of the resource send an HTTP POST request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
     http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket \
     -H 'Authorization: Bearer '$access_token \
     -H 'Content-Type: application/json' \
     -d '{
       "resource": "{resource_id}",
       "requester": "{user_id}",
       "granted": true,
       "scopeName": "view"
     }'</code></pre>
<h5>Getting permission tickets</h5><pre class="highlight listingblock"><code class="bash language-bash">curl http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket \
     -H 'Authorization: Bearer '$access_token</code></pre>
<div class="paragraph"><p>You can use any of these query parameters:</p></div>
<div class="ulist"><ul><li><p><code>scopeId</code></p></li><li><p><code>resourceId</code></p></li><li><p><code>owner</code></p></li><li><p><code>requester</code></p></li><li><p><code>granted</code></p></li><li><p><code>returnNames</code></p></li><li><p><code>first</code></p></li><li><p><code>max</code></p></li></ul></div>
<h5>Updating permission ticket</h5><pre class="highlight listingblock"><code class="bash language-bash">curl -X PUT \
     http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket \
     -H 'Authorization: Bearer '$access_token \
     -H 'Content-Type: application/json' \
     -d '{
       "id": "{ticket_id}"
       "resource": "{resource_id}",
       "requester": "{user_id}",
       "granted": false,
       "scopeName": "view"
     }'</code></pre>
<h5>Deleting permission ticket</h5><pre class="highlight listingblock"><code class="bash language-bash">curl -X DELETE http://${host}:${port}/auth/realms/${realm_name}/authz/protection/permission/ticket/{ticket_id} \
     -H 'Authorization: Bearer '$access_token</code></pre>
<h3>Managing Resource Permissions using the Policy API</h3><div class="paragraph"><p>Red Hat Single Sign-On leverages the UMA Protection API to allow resource servers to manage permissions for their users. In addition
to the Resource and Permission APIs, Red Hat Single Sign-On provides a Policy API from where permissions can be set to resources by resource
servers on behalf of their users.</p></div>
<div class="paragraph"><p>The Policy API is available at:</p></div>
<pre class="highlight listingblock"><code>http://${host}:${port}/auth/realms/${realm_name}/authz/protection/uma-policy/{resource_id}</code></pre>
<div class="paragraph"><p>This API is protected by a bearer token that must represent a consent granted by the user to the resource server to manage permissions on his behalf. The bearer token can be a regular access token obtained from the
token endpoint using:</p></div>
<div class="ulist"><ul><li><p>Resource Owner Password Credentials Grant Type</p></li><li><p>Token Exchange, in order to exchange an access token granted to some client (public client) for a token
where audience is the resource server</p></li></ul></div>
<h4>Associating a Permission with a Resource</h4><div class="paragraph"><p>To associate a permission with a specific resource you must send a HTTP POST request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"roles": ["people-manager"]
}'</code></pre>
<div class="paragraph"><p>In the example above we are creating and associating a new permission to a resource represented by <code>resource_id</code> where
any user with a role <code>people-manager</code> should be granted with the <code>read</code> scope.</p></div>
<div class="paragraph"><p>You can also create policies using other access control mechanisms, such as using groups:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"groups": ["/Managers/People Managers"]
}'</code></pre>
<div class="paragraph"><p>Or a specific client:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"clients": ["my-client"]
}'</code></pre>
<div class="paragraph"><p>Or even using a custom policy using JavaScript:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{resource_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Cache-Control: no-cache' \
  -H 'Content-Type: application/json' \
  -d '{
	"name": "Any people manager",
	"description": "Allow access to any people manager",
	"scopes": ["read"],
	"condition": "if (isPeopleManager()) {$evaluation.grant()}"
}'</code></pre>
<div class="paragraph"><p>It is also possible to set any combination of these access control mechanisms.</p></div>
<div class="paragraph"><p>To update an existing permission, send an HTTP PUT request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X PUT \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{permission_id} \
  -H 'Authorization: Bearer '$access_token \
  -H 'Content-Type: application/json' \
  -d '{
    "id": "21eb3fed-02d7-4b5a-9102-29f3f09b6de2",
    "name": "Any people manager",
    "description": "Allow access to any people manager",
    "type": "uma",
    "scopes": [
        "album:view"
    ],
    "logic": "POSITIVE",
    "decisionStrategy": "UNANIMOUS",
    "owner": "7e22131a-aa57-4f5f-b1db-6e82babcd322",
    "roles": [
        "user"
    ]
}'</code></pre>
<h4>Removing a Permission</h4><div class="paragraph"><p>To remove a permission associated with a resource, send an HTTP DELETE request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X DELETE \
  http://localhost:8180/auth/realms/photoz/authz/protection/uma-policy/{permission_id} \
  -H 'Authorization: Bearer '$access_token</code></pre>
<h4>Querying Permission</h4><div class="paragraph"><p>To query the permissions associated with a resource, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${post}/auth/realms/${realm}/authz/protection/uma-policy?resource={resource_id}</code></pre>
<div class="paragraph"><p>To query the permissions given its name, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${post}/auth/realms/${realm}/authz/protection/uma-policy?name=Any people manager</code></pre>
<div class="paragraph"><p>To query the permissions associated with a specific scope, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${post}/auth/realms/${realm}/authz/protection/uma-policy?scope=read</code></pre>
<div class="paragraph"><p>To query all permissions, send an HTTP GET request as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">http://${host}:${post}/auth/realms/${realm}/authz/protection/uma-policy</code></pre>
<div class="paragraph"><p>When querying the server for permissions use parameters <code>first</code> and <code>max</code> results to limit the result.</p></div></section><section id="_service_rpt_overview"><h2>Requesting Party Token</h2><div class="paragraph"><p>A requesting party token (RPT) is a <a href="https://tools.ietf.org/html/rfc7519">JSON web token (JWT)</a> digitally signed using <a href="https://www.rfc-editor.org/rfc/rfc7515.txt">JSON web signature (JWS)</a>. The token is built based on the OAuth2 access token previously issued by Red Hat Single Sign-On to a specific client acting on behalf of a user
or on its own behalf.</p></div>
<div class="paragraph"><p>When you decode an RPT, you see a payload similar to the following:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
  "authorization": {
      "permissions": [
        {
          "resource_set_id": "d2fe9843-6462-4bfc-baba-b5787bb6e0e7",
          "resource_set_name": "Hello World Resource"
        }
      ]
  },
  "jti": "d6109a09-78fd-4998-bf89-95730dfd0892-1464906679405",
  "exp": 1464906971,
  "nbf": 0,
  "iat": 1464906671,
  "sub": "f1888f4d-5172-4359-be0c-af338505d86c",
  "typ": "kc_ett",
  "azp": "hello-world-authz-service"
}</code></pre>
<div class="paragraph"><p>From this token you can obtain all permissions granted by the server from the <strong>permissions</strong> claim.</p></div>
<div class="paragraph"><p>Also note that permissions are directly related with the resources/scopes you are protecting and completely decoupled from
the access control methods that were used to actually grant and issue these same permissions.</p></div>
<h3>Introspecting a Requesting Party Token</h3><div class="paragraph"><p>Sometimes you might want to introspect a requesting party token (RPT) to check its validity or obtain the permissions within the token to enforce authorization decisions on the resource server side.</p></div>
<div class="paragraph"><p>There are two main use cases where token introspection can help you:</p></div>
<div class="ulist"><ul><li><p>When client applications need to query the token validity to obtain a new one with the same or additional permissions</p></li><li><p>When enforcing authorization decisions at the resource server side, especially when none of the built-in <a href="#_enforcer_overview">policy enforcers</a> fits your application</p></li></ul></div>
<h3>Obtaining Information about an RPT</h3><div class="paragraph"><p>The token introspection is essentially a <a href="https://tools.ietf.org/html/rfc7662">OAuth2 token introspection</a>-compliant endpoint from which you can obtain information about an RPT.</p></div>
<pre class="highlight listingblock"><code>http://${host}:${port}/auth/realms/${realm_name}/protocol/openid-connect/token/introspect</code></pre>
<div class="paragraph"><p>To introspect an RPT using this endpoint, you can send a request to the server as follows:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">curl -X POST \
    -H "Authorization: Basic aGVsbG8td29ybGQtYXV0aHotc2VydmljZTpzZWNyZXQ=" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d 'token_type_hint=requesting_party_token&amp;token=${RPT}' \
    "http://localhost:8080/auth/realms/hello-world-authz/protocol/openid-connect/token/introspect"</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">The request above is using HTTP BASIC and passing the client&#8217;s credentials (client ID and secret) to authenticate the client attempting to introspect the token, but you can use any other client authentication method supported by Red Hat Single Sign-On.</td></tr></table></div>
<div class="paragraph"><p>The introspection endpoint expects two parameters:</p></div>
<div class="ulist"><ul><li><p><strong>token_type_hint</strong></p><div class="paragraph"><p>Use <strong>requesting_party_token</strong> as the value for this parameter, which indicates that you want to introspect an RPT.</p></div></li><li><p><strong>token</strong></p><div class="paragraph"><p>Use the token string as it was returned by the server during the authorization process as the value for this parameter.</p></div></li></ul></div>
<div class="paragraph"><p>As a result, the server response is:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
  "permissions": [
    {
      "resource_id": "90ccc6fc-b296-4cd1-881e-089e1ee15957",
      "resource_name": "Hello World Resource"
    }
  ],
  "exp": 1465314139,
  "nbf": 0,
  "iat": 1465313839,
  "aud": "hello-world-authz-service",
  "active": true
}</code></pre>
<div class="paragraph"><p>If the RPT is not active, this response is returned instead:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
  "active": false
}</code></pre>
<h3>Do I Need to Invoke the Server Every Time I Want to Introspect an RPT?</h3><div class="paragraph"><p>No. Just like a regular access token issued by a Red Hat Single Sign-On server, RPTs also use the
 <a href="https://tools.ietf.org/html/rfc7519">JSON web token (JWT)</a> specification as the default format.</p></div>
<div class="paragraph"><p>If you want to validate these tokens without a call to the remote introspection endpoint, you can decode the RPT and query for its validity locally. Once you decode the token,
you can also use the permissions within the token to enforce authorization decisions.</p></div>
<div class="paragraph"><p>This is essentially what the <a href="#_enforcer_overview">policy enforcers</a> do. Be sure to:</p></div>
<div class="ulist"><ul><li><p>Validate the signature of the RPT (based on the realm&#8217;s public key)</p></li><li><p>Query for token validity based on its <em>exp</em>, <em>iat</em>, and <em>aud</em> claims</p></li></ul></div></section><section id="_service_client_api"><h2>Authorization Client Java API</h2><div class="paragraph"><p>Depending on your requirements, a resource server should be able to manage resources remotely or even check for permissions programmatically.
If you are using Java, you can access the Red Hat Single Sign-On Authorization Services using the Authorization Client API.</p></div>
<div class="paragraph"><p>It is targeted for resource servers that want to access the different endpoints provided by the server such as the Token Endpoint, Resource, and Permission management endpoints.</p></div>
<h3>Maven Dependency</h3><pre class="highlight listingblock"><code class="xml language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.keycloak&lt;/groupId&gt;
        &lt;artifactId&gt;keycloak-authz-client&lt;/artifactId&gt;
        &lt;version&gt;${KEYCLOAK_VERSION}&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
<h3>Configuration</h3><div class="paragraph"><p>The client configuration is defined in a <code>keycloak.json</code> file as follows:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
  "realm": "hello-world-authz",
  "auth-server-url" : "http://localhost:8080/auth",
  "resource" : "hello-world-authz-service",
  "credentials": {
    "secret": "secret"
  }
}</code></pre>
<div class="ulist"><ul><li><p><strong>realm</strong> (required)</p><div class="paragraph"><p>The name of the realm.</p></div></li><li><p><strong>auth-server-url</strong> (required)</p><div class="paragraph"><p>The base URL of the Red Hat Single Sign-On server. All other Red Hat Single Sign-On pages and REST service endpoints are derived from this. It is usually in the form <a href="https://host:port/auth" class="bare">https://host:port/auth</a>.</p></div></li><li><p><strong>resource</strong> (required)</p><div class="paragraph"><p>The client-id of the application. Each application has a client-id that is used to identify the application.</p></div></li><li><p><strong>credentials</strong> (required)</p><div class="paragraph"><p>Specifies the credentials of the application. This is an object notation where the key is the credential type and the value is the value of the credential type.</p></div></li></ul></div>
<div class="paragraph"><p>The configuration file is usually located in your application&#8217;s classpath, the default location from where the client is going to try to find a <code><code>keycloak.json</code></code> file.</p></div>
<h3>Creating the Authorization Client</h3><div class="paragraph"><p>Considering you have a <code><code>keycloak.json</code></code> file in your classpath, you can create a new <code><code>AuthzClient</code></code> instance as follows:</p></div>
<pre class="highlight listingblock"><code class="java language-java">    // create a new instance based on the configuration defined in a keycloak.json located in your classpath
    AuthzClient authzClient = AuthzClient.create();</code></pre>
<h3>Obtaining User Entitlements</h3><div class="paragraph"><p>Here is an example illustrating how to obtain user entitlements:</p></div>
<pre class="highlight listingblock"><code class="java language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// create an authorization request
AuthorizationRequest request = new AuthorizationRequest();

// send the entitlement request to the server in order to
// obtain an RPT with all permissions granted to the user
AuthorizationResponse response = authzClient.authorization("alice", "alice").authorize(request);
String rpt = response.getToken();

System.out.println("You got an RPT: " + rpt);

// now you can use the RPT to access protected resources on the resource server</code></pre>
<div class="paragraph"><p>Here is an example illustrating how to obtain user entitlements for a set of one or more resources:</p></div>
<pre class="highlight listingblock"><code class="java language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// create an authorization request
AuthorizationRequest request = new AuthorizationRequest();

// add permissions to the request based on the resources and scopes you want to check access
request.addPermission("Default Resource");

// send the entitlement request to the server in order to
// obtain an RPT with permissions for a single resource
AuthorizationResponse response = authzClient.authorization("alice", "alice").authorize(request);
String rpt = response.getToken();

System.out.println("You got an RPT: " + rpt);

// now you can use the RPT to access protected resources on the resource server</code></pre>
<h3>Creating a Resource Using the Protection API</h3><pre class="highlight listingblock"><code class="java language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// create a new resource representation with the information we want
ResourceRepresentation newResource = new ResourceRepresentation();

newResource.setName("New Resource");
newResource.setType("urn:hello-world-authz:resources:example");

newResource.addScope(new ScopeRepresentation("urn:hello-world-authz:scopes:view"));

ProtectedResource resourceClient = authzClient.protection().resource();
ResourceRepresentation existingResource = resourceClient.findByName(newResource.getName());

if (existingResource != null) {
    resourceClient.delete(existingResource.getId());
}

// create the resource on the server
ResourceRepresentation response = resourceClient.create(newResource);
String resourceId = response.getId();

// query the resource using its newly generated id
ResourceRepresentation resource = resourceClient.findById(resourceId);

System.out.println(resource);</code></pre>
<h3>Introspecting an RPT</h3><pre class="highlight listingblock"><code class="java language-java">// create a new instance based on the configuration defined in keycloak.json
AuthzClient authzClient = AuthzClient.create();

// send the authorization request to the server in order to
// obtain an RPT with all permissions granted to the user
AuthorizationResponse response = authzClient.authorization("alice", "alice").authorize();
String rpt = response.getToken();

// introspect the token
TokenIntrospectionResponse requestingPartyToken = authzClient.protection().introspectRequestingPartyToken(rpt);

System.out.println("Token status is: " + requestingPartyToken.getActive());
System.out.println("Permissions granted by the server: ");

for (Permission granted : requestingPartyToken.getPermissions()) {
    System.out.println(granted);
}</code></pre></section></section>
<section><section id="_enforcer_overview"><h2>Policy Enforcers</h2><div class="paragraph"><p>Policy Enforcement Point (PEP) is a design pattern and as such you can implement it in different ways. Red Hat Single Sign-On provides all the necessary means
to implement PEPs for different platforms, environments, and programming languages. Red Hat Single Sign-On Authorization Services presents a RESTful API,
and leverages OAuth2 authorization capabilities for fine-grained authorization using a centralized authorization server.</p></div><div class="paragraph"><p><span class="image"><img src="images/pep-pattern-diagram.png" alt="PEP Overview"></span></p></div><div class="paragraph"><p>A PEP is responsible for enforcing access decisions from the Red Hat Single Sign-On server where these decisions are taken by evaluating the policies
associated with a protected resource. It acts as a filter or interceptor in your application in order to check whether or not a particular request
to a protected resource can be fulfilled based on the permissions granted by these decisions.</p></div><div class="paragraph"><p>Permissions are enforced depending on the protocol you are using. When using UMA, the policy enforcer always expects an RPT as a bearer token in order
to decide whether or not a request can be served. That means clients should first obtain an RPT from Red Hat Single Sign-On before sending requests to the resource server.</p></div><div class="paragraph"><p>However, if you are not using UMA, you can also send regular access tokens to the resource server. In this case, the policy enforcer will try to obtain permissions directly from the server.</p></div><div class="paragraph"><p>If you are using any of the Red Hat Single Sign-On OIDC adapters, you can easily enable the policy enforcer by adding the following property to your <strong>keycloak.json</strong> file:</p></div><div class="title">keycloak.json</div><pre class="highlight listingblock"><code class="json language-json">{
 "policy-enforcer": {}
}</code></pre><div class="paragraph"><p>When you enable the policy enforcer all requests sent your application are intercepted and access to protected resources will be granted
depending on the permissions granted by Red Hat Single Sign-On to the identity making the request.</p></div><div class="paragraph"><p>Policy enforcement is strongly linked to your application&#8217;s paths and the <a href="#_resource_overview">resources</a> you created for a resource server using the Red Hat Single Sign-On Administration Console. By default,
when you create a resource server, Red Hat Single Sign-On creates a <a href="#_resource_server_default_config">default configuration</a> for your resource server so you can enable policy enforcement quickly.</p></div></section><section id="_enforcer_filter"><h2>Configuration</h2><div class="paragraph"><p>To enable policy enforcement for your application, add the following property to your <strong>keycloak.json</strong> file:</p></div>
<div class="title">keycloak.json</div><pre class="highlight listingblock"><code class="json language-json">{
  "policy-enforcer": {}
}</code></pre>
<div class="paragraph"><p>Or a little more verbose if you want to manually define the resources being protected:</p></div>
<pre class="highlight listingblock"><code class="json language-json">{
  "policy-enforcer": {
    "user-managed-access" : {},
    "enforcement-mode" : "ENFORCING"
    "paths": [
      {
        "path" : "/someUri/*",
        "methods" : [
          {
            "method": "GET",
            "scopes" : ["urn:app.com:scopes:view"]
          },
          {
            "method": "POST",
            "scopes" : ["urn:app.com:scopes:create"]
          }
        ]
      },
      {
        "name" : "Some Resource",
        "path" : "/usingPattern/{id}",
        "methods" : [
          {
            "method": "DELETE",
            "scopes" : ["urn:app.com:scopes:delete"]
          }
        ]
      },
      {
        "path" : "/exactMatch"
      },
      {
        "name" : "Admin Resources",
        "path" : "/usingWildCards/*"
      }
    ]
  }
}</code></pre>
<div class="paragraph"><p>Here is a description of each configuration option:</p></div>
<div class="ulist"><ul><li><p><strong>policy-enforcer</strong></p><div class="paragraph"><p>Specifies the configuration options that define how policies are actually enforced and optionally the paths you want to protect. If not specified, the policy enforcer queries the server
for all resources associated with the resource server being protected. In this case, you need to ensure the resources are properly configured with a <a href="#_resource_create_uri">URIS</a> property that matches the paths you want to protect.</p></div>
<div class="ulist"><ul><li><p><strong>user-managed-access</strong></p><div class="paragraph"><p>Specifies that the adapter uses the UMA protocol. If specified, the adapter queries the server for permission tickets and returns them to clients according to the UMA specification. If not specified, the policy enforcer will be able to enforce permissions based on regular access tokens or RPTs. In this case,
before denying access to the resource when the token lacks permission, the policy enforcer will try to obtain permissions directly from the server.</p></div></li><li><p><strong>enforcement-mode</strong></p><div class="paragraph"><p>Specifies how policies are enforced.</p></div>
<div class="ulist"><ul><li><p><strong>ENFORCING</strong></p><div class="paragraph"><p>(default mode) Requests are denied by default even when there is no policy associated with a given resource.</p></div></li><li><p><strong>PERMISSIVE</strong></p><div class="paragraph"><p>Requests are allowed even when there is no policy associated with a given resource.</p></div></li><li><p><strong>DISABLED</strong></p><div class="paragraph"><p>Completely disables the evaluation of policies and allows access to any resource. When <code>enforcement-mode</code> is <code>DISABLED</code>
applications are still able to obtain all permissions granted by Red Hat Single Sign-On through the <a href="#_enforcer_authorization_context">Authorization Context</a></p></div></li></ul></div></li><li><p><strong>on-deny-redirect-to</strong></p><div class="paragraph"><p>Defines a URL where a client request is redirected when an "access denied" message is obtained from the server. By default, the adapter responds with a 403 HTTP status code.</p></div></li><li><p><strong>path-cache</strong></p><div class="paragraph"><p>Defines how the policy enforcer should track associations between paths in your application and resources defined in Red Hat Single Sign-On. The cache is needed to avoid
unnecessary requests to a Red Hat Single Sign-On server by caching associations between paths and protected resources.</p></div>
<div class="ulist"><ul><li><p><strong>lifespan</strong></p><div class="paragraph"><p>Defines the time in milliseconds when the entry should be expired. If not provided, default value is <strong>3000</strong>. A value
less than or equal to 0 can be set to completely disable the cache.</p></div></li><li><p><strong>max-entries</strong></p><div class="paragraph"><p>Defines the limit of entries that should be kept in the cache. If not provided, default value is <strong>1000</strong>.</p></div></li></ul></div></li><li><p><strong>paths</strong></p><div class="paragraph"><p>Specifies the paths to protect. This configuration is optional. If not defined, the policy enforcer will discover all paths by fetching the resources you defined to your application in Red Hat Single Sign-On, where these resources are defined with <code>URIS</code> representing some paths in your application.</p></div>
<div class="ulist"><ul><li><p><strong>name</strong></p><div class="paragraph"><p>The name of a resource on the server that is to be associated with a given path. When used in conjunction with a <strong>path</strong>, the policy enforcer ignores the resource&#8217;s <strong>URIS</strong> property and uses the path you provided instead.</p></div></li><li><p><strong>path</strong></p><div class="paragraph"><p>(required) A URI relative to the application&#8217;s context path. If this option is specified, the policy enforcer queries the server for a resource with a <strong>URI</strong> with the same value.
Currently a very basic logic for path matching is supported. Examples of valid paths are:</p></div>
<div class="ulist"><ul><li><p>Wildcards: <code>/*</code></p></li><li><p>Suffix: <code>/*.html</code></p></li><li><p>Sub-paths: <code>/path/*</code></p></li><li><p>Path parameters: /resource/{id}</p></li><li><p>Exact match: /resource</p></li><li><p>Patterns: /{version}/resource, /api/{version}/resource, /api/{version}/resource/*</p></li></ul></div></li><li><p><strong>methods</strong></p><div class="paragraph"><p>The HTTP methods (for example, GET, POST, PATCH) to protect and how they are associated with the scopes for a given resource in the server.</p></div>
<div class="ulist"><ul><li><p><strong>method</strong></p><div class="paragraph"><p>The name of the HTTP method.</p></div></li><li><p><strong>scopes</strong></p><div class="paragraph"><p>An array of strings with the scopes associated with the method. When you associate scopes with a specific method, the client trying to access a protected resource (or path) must provide an RPT that grants permission to all scopes specified in the list. For example, if you define a method <em>POST</em> with a scope <em>create</em>, the RPT must contain a permission granting access to the <em>create</em> scope when performing a POST to the path.</p></div></li><li><p><strong>scopes-enforcement-mode</strong></p><div class="paragraph"><p>A string referencing the enforcement mode for the scopes associated with a method. Values can be <strong>ALL</strong> or <strong>ANY</strong>. If <strong>ALL</strong>,
all defined scopes must be granted in order to access the resource using that method. If <strong>ANY</strong>, at least one scope should be
granted in order to gain access to the resource using that method. By default, enforcement mode is set to <strong>ALL</strong>.</p></div></li></ul></div></li><li><p><strong>enforcement-mode</strong></p><div class="paragraph"><p>Specifies how policies are enforced.</p></div>
<div class="ulist"><ul><li><p><strong>ENFORCING</strong></p><div class="paragraph"><p>(default mode) Requests are denied by default even when there is no policy associated with a given resource.</p></div></li><li><p><strong>DISABLED</strong></p></li></ul></div></li><li><p><strong>claim-information-point</strong></p><div class="paragraph"><p>Defines a set of one or more claims that must be resolved and pushed to the Red Hat Single Sign-On server in order to make these claims available to policies. See <a href="#_enforcer_claim_information_point">Claim Information Point</a> for more details.</p></div></li></ul></div></li><li><p><strong>lazy-load-paths</strong></p><div class="paragraph"><p>Specifies how the adapter should fetch the server for resources associated with paths in your application. If <strong>true</strong>, the policy
enforcer is going to fetch resources on-demand accordingly with the path being requested. This configuration is specially useful
when you don&#8217;t want to fetch all resources from the server during deployment (in case you have provided no <code>paths</code>) or in case
you have defined only a sub set of <code>paths</code> and want to fetch others on-demand.</p></div></li><li><p><strong>http-method-as-scope</strong></p><div class="paragraph"><p>Specifies how scopes should be mapped to HTTP methods. If set to <strong>true</strong>, the policy enforcer will use the HTTP method from the current request to
check whether or not access should be granted. When enabled, make sure your resources in Red Hat Single Sign-On are associated with scopes representing each HTTP method you are protecting.</p></div></li><li><p><strong>claim-information-point</strong></p><div class="paragraph"><p>Defines a set of one or more <strong>global</strong> claims that must be resolved and pushed to the Red Hat Single Sign-On server in order to make these claims available to policies. See <a href="#_enforcer_claim_information_point">Claim Information Point</a> for more details.</p></div></li></ul></div></li></ul></div></section><section id="_enforcer_claim_information_point"><h2>Claim Information Point</h2><div class="paragraph"><p>A Claim Information Point (CIP) is responsible for resolving claims and pushing these claims to the Red Hat Single Sign-On server
in order to provide more information about the access context to policies. They can be defined as a configuration option
to the policy-enforcer in order to resolve claims from different sources, such as:</p></div>
<div class="ulist"><ul><li><p>HTTP Request (parameters, headers, body, etc)</p></li><li><p>External HTTP Service</p></li><li><p>Static values defined in configuration</p></li><li><p>Any other source by implementing the Claim Information Provider SPI</p></li></ul></div>
<div class="paragraph"><p>When pushing claims to the Red Hat Single Sign-On server, policies can base decisions not only on who a user is but also by taking
context and contents into account, based on who, what, why, when, where, and which for a given transaction. It is all about
Contextual-based Authorization and how to use runtime information in order to support fine-grained authorization decisions.</p></div>
<h3>Obtaining information from the HTTP Request</h3><div class="paragraph"><p>Here are several examples showing how you can extract claims from an HTTP request:</p></div>
<div class="title">keycloak.json</div><pre class="highlight listingblock"><code class="json language-json">"policy-enforcer": {
    "paths": [
      {
        "path": "/protected/resource",
        "claim-information-point": {
          "claims": {
            "claim-from-request-parameter": "{request.parameter['a']}",
            "claim-from-header": "{request.header['b']}",
            "claim-from-cookie": "{request.cookie['c']}",
            "claim-from-remoteAddr": "{request.remoteAddr}",
            "claim-from-method": "{request.method}",
            "claim-from-uri": "{request.uri}",
            "claim-from-relativePath": "{request.relativePath}",
            "claim-from-secure": "{request.secure}",
            "claim-from-json-body-object": "{request.body['/a/b/c']}",
            "claim-from-json-body-array": "{request.body['/d/1']}",
            "claim-from-body": "{request.body}",
            "claim-from-static-value": "static value",
            "claim-from-multiple-static-value": ["static", "value"],
            "param-replace-multiple-placeholder": "Test {keycloak.access_token['/custom_claim/0']} and {request.parameter['a']} "
          }
        }
      }
    ]
  }</code></pre>
<h3>Obtaining information from an External HTTP Service</h3><div class="paragraph"><p>Here are several examples showing how you can extract claims from an external HTTP Service:</p></div>
<div class="title">keycloak.json</div><pre class="highlight listingblock"><code class="json language-json">"policy-enforcer": {
    "paths": [
      {
        "path": "/protected/resource",
        "claim-information-point": {
          "http": {
            "claims": {
              "claim-a": "/a",
              "claim-d": "/d",
              "claim-d0": "/d/0",
              "claim-d-all": ["/d/0", "/d/1"]
            },
            "url": "http://mycompany/claim-provider",
            "method": "POST",
            "headers": {
              "Content-Type": "application/x-www-form-urlencoded",
              "header-b": ["header-b-value1", "header-b-value2"],
              "Authorization": "Bearer {keycloak.access_token}"
            },
            "parameters": {
              "param-a": ["param-a-value1", "param-a-value2"],
              "param-subject": "{keycloak.access_token['/sub']}",
              "param-user-name": "{keycloak.access_token['/preferred_username']}",
              "param-other-claims": "{keycloak.access_token['/custom_claim']}"
            }
          }
        }
      }
    ]
  }</code></pre>
<h3>Static Claims</h3><div class="title">keycloak.json</div><pre class="highlight listingblock"><code class="json language-json">"policy-enforcer": {
    "paths": [
      {
        "path": "/protected/resource",
        "claim-information-point": {
          "claims": {
            "claim-from-static-value": "static value",
            "claim-from-multiple-static-value": ["static", "value"],
          }
        }
      }
    ]
  }</code></pre>
<h3>Claim Information Provider SPI</h3><div class="paragraph"><p>The Claim Information Provider SPI can be used by developers to support different claim information points in case none of the
built-ins providers are enough to address their requirements.</p></div>
<div class="paragraph"><p>For example, to implement a new CIP provider you need to implement <code>org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory</code>
and <code>ClaimInformationPointProvider</code> and also provide the file <code>META-INF/services/org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory</code>
in your application`s classpath.</p></div>
<div class="paragraph"><p>Example of <code>org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory</code>:</p></div>
<pre class="highlight listingblock"><code class="java language-java">public class MyClaimInformationPointProviderFactory implements ClaimInformationPointProviderFactory&lt;MyClaimInformationPointProvider&gt; {

    @Override
    public String getName() {
        return "my-claims";
    }

    @Override
    public void init(PolicyEnforcer policyEnforcer) {

    }

    @Override
    public MyClaimInformationPointProvider create(Map&lt;String, Object&gt; config) {
        return new MyClaimInformationPointProvider(config);
    }
}</code></pre>
<div class="paragraph"><p>Every CIP provider must be associated with a name, as defined above in the <code>MyClaimInformationPointProviderFactory.getName</code> method. The name
will be used to map the configuration from the <code>claim-information-point</code> section in the <code>policy-enforcer</code> configuration to the implementation.</p></div>
<div class="paragraph"><p>When processing requests, the policy enforcer will call the MyClaimInformationPointProviderFactory.create method in order to obtain an
instance of MyClaimInformationPointProvider. When called, any configuration defined for this particular CIP provider
(via claim-information-point) is passed as a map.</p></div>
<div class="paragraph"><p>Example of <code>ClaimInformationPointProvider</code>:</p></div>
<pre class="highlight listingblock"><code class="java language-java">public class MyClaimInformationPointProvider implements ClaimInformationPointProvider {

    private final Map&lt;String, Object&gt; config;

    public ClaimsInformationPointProvider(Map&lt;String, Object&gt; config) {
        this.config = config;
    }

    @Override
    public Map&lt;String, List&lt;String&gt;&gt; resolve(HttpFacade httpFacade) {
        Map&lt;String, List&lt;String&gt;&gt; claims = new HashMap&lt;&gt;();

        // put whatever claim you want into the map

        return claims;
    }
}</code></pre></section><section id="_enforcer_authorization_context"><h2>Obtaining the Authorization Context</h2><div class="paragraph"><p>When policy enforcement is enabled, the permissions obtained from the server are available through <code>org.keycloak.AuthorizationContext</code>.
This class provides several methods you can use to obtain permissions and ascertain whether a permission was granted for a particular resource or scope.</p></div>
<div class="paragraph"><p>Obtaining the Authorization Context in a Servlet Container</p></div>
<pre class="highlight listingblock"><code class="java language-java">    HttpServletRequest request = ... // obtain javax.servlet.http.HttpServletRequest
    KeycloakSecurityContext keycloakSecurityContext =
        (KeycloakSecurityContext) request
            .getAttribute(KeycloakSecurityContext.class.getName());
    AuthorizationContext authzContext =
        keycloakSecurityContext.getAuthorizationContext();</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">For more details about how you can obtain a <code>KeycloakSecurityContext</code> consult the adapter configuration. The example above should be sufficient
to obtain the context when running an application using any of the servlet containers supported by Red Hat Single Sign-On.</td></tr></table></div>
<div class="paragraph"><p>The authorization context helps give you more control over the decisions made and returned by the server. For example, you can use it
to build a dynamic menu where items are hidden or shown depending on the permissions associated with a resource or scope.</p></div>
<pre class="highlight listingblock"><code class="java language-java">if (authzContext.hasResourcePermission("Project Resource")) {
    // user can access the Project Resource
}

if (authzContext.hasResourcePermission("Admin Resource")) {
    // user can access administration resources
}

if (authzContext.hasScopePermission("urn:project.com:project:create")) {
    // user can create new projects
}</code></pre>
<div class="paragraph"><p>The <code>AuthorizationContext</code> represents one of the main capabilities of Red Hat Single Sign-On Authorization Services. From the examples above, you can see that the protected resource is not directly associated with the policies that govern them.</p></div>
<div class="paragraph"><p>Consider some similar code using role-based access control (RBAC):</p></div>
<pre class="highlight listingblock"><code class="java language-java">if (User.hasRole('user')) {
    // user can access the Project Resource
}

if (User.hasRole('admin')) {
    // user can access administration resources
}

if (User.hasRole('project-manager')) {
    // user can create new projects
}</code></pre>
<div class="paragraph"><p>Although both examples address the same requirements, they do so in different ways. In RBAC, roles only <em>implicitly</em> define access for their resources. With Red Hat Single Sign-On you gain the capability to create more manageable code that focuses directly on your resources whether you are using RBAC, attribute-based access control (ABAC), or any other BAC variant. Either you have the permission for a given resource or scope, or you don&#8217;t.</p></div>
<div class="paragraph"><p>Now, suppose your security requirements have changed and in addition to project managers, PMOs can also create new projects.</p></div>
<div class="paragraph"><p>Security requirements change, but with Red Hat Single Sign-On there is no need to change your application code to address the new requirements. Once your application is based on the resource and scope identifier, you need only change the configuration of the permissions or policies associated with a particular resource in the authorization server. In this case, the permissions and policies associated with the <code>Project Resource</code> and/or the scope <code>urn:project.com:project:create</code> would be changed.</p></div></section><section id="_using_the_authorizationcontext_to_obtain_an_authorization_client_instance"><h2>Using the AuthorizationContext to obtain an Authorization Client Instance</h2><div class="paragraph"><p>The <code><code>AuthorizationContext</code></code> can also be used to obtain a reference to the <a href="#_service_client_api">Authorization Client API</a> configured to your application:</p></div>
<pre class="highlight listingblock"><code class="java language-java">    ClientAuthorizationContext clientContext = ClientAuthorizationContext.class.cast(authzContext);
    AuthzClient authzClient = clientContext.getClient();</code></pre>
<div class="paragraph"><p>In some cases, resource servers protected by the policy enforcer need to access the APIs provided by the authorization server. With an <code><code>AuthzClient</code></code> instance in hands, resource servers can interact with the server in order to create resources or check for specific permissions programmatically.</p></div></section><section id="_enforcer_js_adapter"><h2>JavaScript Integration</h2><div class="paragraph"><p>The Red Hat Single Sign-On Server comes with a JavaScript library you can use to interact with a resource server protected by a policy enforcer.
This library is based on the Red Hat Single Sign-On JavaScript adapter, which can be integrated to allow your client to obtain permissions from a Red Hat Single Sign-On Server.</p></div>
<div class="paragraph"><p>You can obtain this library from a running a Red Hat Single Sign-On Server instance by including the following <code>script</code> tag in your web page:</p></div>
<pre class="highlight listingblock"><code class="html language-html">&lt;script src="http://.../auth/js/keycloak-authz.js"&gt;&lt;/script&gt;</code></pre>
<div class="paragraph"><p>Once you do that, you can create a <code>KeycloakAuthorization</code> instance as follows:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var keycloak = ... // obtain a Keycloak instance from keycloak.js library
var authorization = new KeycloakAuthorization(keycloak);</code></pre>
<div class="paragraph"><p>The <strong>keycloak-authz.js</strong> library provides two main features:</p></div>
<div class="ulist"><ul><li><p>Obtain permissions from the server using a permission ticket, if you are accessing a UMA protected resource server.</p></li><li><p>Obtain permissions from the server by sending the resources and scopes the application wants to access.</p></li></ul></div>
<div class="paragraph"><p>In both cases, the library allows you to easily interact with both resource server and Red Hat Single Sign-On Authorization Services to obtain tokens with
permissions your client can use as bearer tokens to access the protected resources on a resource server.</p></div>
<h3>Handling Authorization Responses from a UMA-Protected Resource Server</h3><div class="paragraph"><p>If a resource server is protected by a policy enforcer, it responds to client requests based on the permissions carried along with a bearer token.
Typically, when you try to access a resource server with a bearer token that is lacking permissions to access a protected resource, the resource server
responds with a <strong>401</strong> status code and a <code>WWW-Authenticate</code> header.</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">HTTP/1.1 401 Unauthorized
WWW-Authenticate: UMA realm="${realm}",
    as_uri="https://${host}:${post}/auth/realms/${realm}",
    ticket="016f84e8-f9b9-11e0-bd6f-0021cc6004de"</code></pre>
<div class="paragraph"><p>See <a href="#_service_uma_authorization_process">UMA Authorization Process</a> for more information.</p></div>
<div class="paragraph"><p>What your client needs to do is extract the permission ticket from the <code><code>WWW-Authenticate</code></code> header returned by the resource server
and use the library to send an authorization request as follows:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">// prepare a authorization request with the permission ticket
var authorizationRequest = {};
authorizationRequest.ticket = ticket;

// send the authorization request, if successful retry the request
Identity.authorization.authorize(authorizationRequest).then(function (rpt) {
    // onGrant
}, function () {
    // onDeny
}, function () {
    // onError
});</code></pre>
<div class="paragraph"><p>The <code>authorize</code> function is completely asynchronous and supports a few callback functions to receive notifications from the server:</p></div>
<div class="ulist"><ul><li><p><code>onGrant</code>: The first argument of the function. If authorization was successful and the server returned an RPT with the requested permissions, the callback receives the RPT.</p></li><li><p><code>onDeny</code>: The second argument of the function. Only called if the server has denied the authorization request.</p></li><li><p><code>onError</code>: The third argument of the function. Only called if the server responds unexpectedly.</p></li></ul></div>
<div class="paragraph"><p>Most applications should use the <code>onGrant</code> callback to retry a request after a 401 response. Subsequent requests should include the RPT as a bearer token for retries.</p></div>
<h3>Obtaining Entitlements</h3><div class="paragraph"><p>The <code><code>keycloak-authz.js</code></code> library provides an <code>entitlement</code> function that you can use to obtain an RPT from the server by providing
the resources and scopes your client wants to access.</p></div>
<div class="title">Example about how to obtain an RPT with permissions for all resources and scopes the user can access</div><pre class="highlight listingblock"><code class="javascript language-javascript">authorization.entitlement('my-resource-server-id').then(function (rpt) {
    // onGrant callback function.
    // If authorization was successful you'll receive an RPT
    // with the necessary permissions to access the resource server
});</code></pre>
<div class="title">Example about how to obtain an RPT with permissions for specific resources and scopes</div><pre class="highlight listingblock"><code class="javascript language-javascript">authorization.entitlement('my-resource-server', {
    "permissions": [
        {
            "id" : "Some Resource"
        }
    ]
}).then(function (rpt) {
    // onGrant
});</code></pre>
<div class="paragraph"><p>When using the <code>entitlement</code> function, you must provide the <em>client_id</em> of the resource server you want to access.</p></div>
<div class="paragraph"><p>The <code>entitlement</code> function is completely asynchronous and supports a few callback functions to receive notifications from the server:</p></div>
<div class="ulist"><ul><li><p><code>onGrant</code>: The first argument of the function. If authorization was successful and the server returned an RPT with the requested permissions, the callback receives the RPT.</p></li><li><p><code>onDeny</code>: The second argument of the function. Only called if the server has denied the authorization request.</p></li><li><p><code>onError</code>: The third argument of the function. Only called if the server responds unexpectedly.</p></li></ul></div>
<h3>Authorization Request</h3><div class="paragraph"><p>Both <code><code>authorize</code></code> and <code><code>entitlement</code></code> functions accept an authorization request object. This object can be set with the following
properties:</p></div>
<div class="ulist"><ul><li><p><strong>permissions</strong></p><div class="paragraph"><p>An array of objects representing the resource and scopes. For instance:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var authorizationRequest = {
   "permissions": [
       {
           "id" : "Some Resource",
           "scopes" : ["view", "edit"]
       }
   ]
}</code></pre></li><li><p><strong>metadata</strong></p><div class="paragraph"><p>An object where its properties define how the authorization request should be processed by the server.</p></div>
<div class="ulist"><ul><li><p><strong>response_include_resource_name</strong></p><div class="paragraph"><p>A boolean value indicating to the server if resource names should be included in the RPT&#8217;s permissions. If false, only the resource
identifier is included.</p></div></li><li><p><strong>response_permissions_limit</strong></p><div class="paragraph"><p>An integer N that defines a limit for the amount of permissions an RPT can have. When used together with
<code>rpt</code> parameter, only the last N requested permissions will be kept in the RPT</p></div></li></ul></div></li><li><p><strong>submit_request</strong></p><div class="paragraph"><p>A boolean value indicating whether the server should create permission requests to the resources and scopes referenced by a permission ticket.
This parameter will only take effect when used together with the <code>ticket</code> parameter as part of a UMA authorization process.</p></div></li></ul></div>
<h3>Obtaining the RPT</h3><div class="paragraph"><p>If you have already obtained an RPT using any of the authorization functions provided by the library, you can always obtain the RPT as follows from the authorization object (assuming that it has been initialized by one of the techniques shown earlier):</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var rpt = authorization.rpt;</code></pre></section><section id="_enforcer_filter_using_https"><h2>Setting Up TLS/HTTPS</h2><div class="paragraph"><p>When the server is using HTTPS, ensure your adapter is configured as follows:</p></div>
<div class="title">keycloak.json</div><pre class="highlight listingblock"><code class="json language-json">{
  "truststore": "path_to_your_trust_store",
  "truststore-password": "trust_store_password"
}</code></pre>
<div class="paragraph"><p>The configuration above enables TLS/HTTPS to the Authorization Client, making possible to access a
Red Hat Single Sign-On Server remotely using the HTTPS scheme.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">It is strongly recommended that you enable TLS/HTTPS when accessing the Red Hat Single Sign-On Server endpoints.</td></tr></table></div></section></section></div></div><script src="node_modules/reveal.js/lib/js/head.min.js"></script><script src="node_modules/reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'node_modules/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'node_modules/reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>