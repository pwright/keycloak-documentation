<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Server Administration Guide</title><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui" name="viewport"><link href="node_modules/reveal.js/css/reveal.css" rel="stylesheet"><link rel="stylesheet" href="node_modules/reveal.js/css/theme/black.css" id="theme"><!--This CSS is generated by the Asciidoctor-Reveal.js converter to further integrate AsciiDoc's existing semantic with Reveal.js--><style type="text/css">.reveal div.right {
  float: right;
}

/* callouts */
.conum[data-value] {display:inline-block;color:#fff!important;background-color:rgba(50,150,50,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}</style><link href="node_modules/reveal.js/lib/css/zenburn.css" rel="stylesheet"><script>var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? "node_modules/reveal.js/css/print/pdf.css" : "node_modules/reveal.js/css/print/paper.css";
document.getElementsByTagName( 'head' )[0].appendChild( link );</script><!--[if lt IE 9]><script src="node_modules/reveal.js/lib/js/html5shiv.js"></script><![endif]--></head><body><div class="reveal"><div class="slides"><section class="title" data-state="title"><h1>Server Administration Guide</h1></section><section><section id="_overview"><h2>Overview</h2><div class="paragraph"><p>Red Hat Single Sign-On is a single sign on solution for web apps and RESTful web services.  The goal of Red Hat Single Sign-On
is to make security simple so that it is easy for application developers to secure the apps and services they have deployed
in their organization.  Security features that developers normally have to write for themselves are provided out of the box
and are easily tailorable to the individual requirements of your organization.  Red Hat Single Sign-On provides customizable
user interfaces for login, registration, administration, and account management.  You can also use Red Hat Single Sign-On as an
integration platform to hook it into existing LDAP and Active Directory servers.  You can also delegate authentication to third
party identity providers like Facebook and Google+.</p></div></section><section id="_features"><h2>Features</h2><div class="ulist"><ul><li><p>Single-Sign On and Single-Sign Out for browser applications.</p></li><li><p>OpenID Connect support.</p></li><li><p>OAuth 2.0 support.</p></li><li><p>SAML support.</p></li><li><p>Identity Brokering - Authenticate with external OpenID Connect or SAML Identity Providers.</p></li><li><p>Social Login - Enable login with Google, GitHub, Facebook, Twitter, and other social networks.</p></li><li><p>User Federation - Sync users from LDAP and Active Directory servers.</p></li><li><p>Kerberos bridge - Automatically authenticate users that are logged-in to a Kerberos server.</p></li><li><p>Admin Console for central management of users, roles, role mappings, clients and configuration.</p></li><li><p>Account Management console that allows users to centrally manage their account.</p></li><li><p>Theme support - Customize all user facing pages to integrate with your applications and branding.</p></li><li><p>Two-factor Authentication - Support for TOTP/HOTP via Google Authenticator or FreeOTP.</p></li><li><p>Login flows - optional user self-registration, recover password, verify email, require password update, etc.</p></li><li><p>Session management - Admins and users themselves can view and manage user sessions.</p></li><li><p>Token mappers - Map user attributes, roles, etc. how you want into tokens and statements.</p></li><li><p>Not-before revocation policies per realm, application and user.</p></li><li><p>CORS support - Client adapters have built-in support for CORS.</p></li><li><p>Client adapters for JavaScript applications, JBoss EAP, Fuse, etc.</p></li><li><p>Supports any platform/language that has an OpenID Connect Relying Party library or SAML 2.0 Service Provider library.</p></li></ul></div></section><section id="_how_does_security_work"><h2>How Does Security Work?</h2><div class="paragraph"><p>Red Hat Single Sign-On is a separate server that you manage on your network.  Applications are configured to point to and
be secured by this server.  Red Hat Single Sign-On uses open protocol standards like <a href="https://openid.net/connect/">OpenID Connect</a>
or <a href="http://saml.xml.org/saml-specifications">SAML 2.0</a> to secure
your applications.  Browser applications redirect a user&#8217;s browser from the application to the Red Hat Single Sign-On authentication
server where they enter their credentials.  This is important because users are completely isolated from applications and
applications never see a user&#8217;s credentials.  Applications instead are given an identity token or assertion that is cryptographically
signed.  These tokens can have identity information like username, address, email, and other profile data.  They can also
hold permission data so that applications can make authorization decisions.  These tokens can also be used to make secure
invocations on REST-based services.</p></div></section><section id="_core_concepts_and_terms"><h2>Core Concepts and Terms</h2><div class="paragraph"><p>There are some key concepts and terms you should be aware of before attempting to use Red Hat Single Sign-On to secure your web applications
and REST services.</p></div>
<div class="dlist"><dl><dt class="hdlist1">users</dt><dd><p>Users are entities that are able to log into your system.  They can have attributes associated with themselves like email,
username, address, phone number, and birth day.  They can be assigned group membership and have specific roles assigned to them.</p></dd><dt class="hdlist1">authentication</dt><dd><p>The process of identifying and validating a user.</p></dd><dt class="hdlist1">authorization</dt><dd><p>The process of granting access to a user.</p></dd><dt class="hdlist1">credentials</dt><dd><p>Credentials are pieces of data that Red Hat Single Sign-On uses to verify the identity of a user.  Some examples are passwords,
one-time-passwords, digital certificates, or even fingerprints.</p></dd><dt class="hdlist1">roles</dt><dd><p>Roles identify a type or category of user.  <code>Admin</code>, <code>user</code>, <code>manager</code>, and <code>employee</code> are all typical roles that may exist
in an organization.  Applications often assign access and permissions to specific roles rather than individual users as dealing
with users can be too fine grained and hard to manage.</p></dd><dt class="hdlist1">user role mapping</dt><dd><p>A user role mapping defines a mapping between a role and a user.  A user can be associated with zero or more roles.  This
role mapping information can be encapsulated into tokens and assertions so that applications can decide access permissions on
various resources they manage.</p></dd><dt class="hdlist1">composite roles</dt><dd><p>A composite role is a role that can be associated with other roles.  For example a <code>superuser</code> composite role could be associated with the
<code>sales-admin</code> and <code>order-entry-admin</code> roles.  If a user is mapped to the <code>superuser</code> role they also inherit the <code>sales-admin</code> and <code>order-entry-admin</code> roles.</p></dd><dt class="hdlist1">groups</dt><dd><p>Groups manage groups of users.  Attributes can be defined for a group.  You can map roles to a group as well.  Users that become members of a group
inherit the attributes and role mappings that group defines.</p></dd><dt class="hdlist1">realms</dt><dd><p>A realm manages a set of users, credentials, roles, and groups.  A user belongs to and logs into a realm.  Realms are isolated from one another
and can only manage and authenticate the users that they control.</p></dd><dt class="hdlist1">clients</dt><dd><p>Clients are entities that can request Red Hat Single Sign-On to authenticate a user.  Most often, clients are applications and services that
want to use Red Hat Single Sign-On to secure themselves and provide a single sign-on solution.  Clients can also be entities that just want to request
identity information or an access token so that they can securely invoke other services on the network that are secured by Red Hat Single Sign-On.</p></dd><dt class="hdlist1">client adapters</dt><dd><p>Client adapters are plugins that you install into your application environment to be able to communicate and be secured by Red Hat Single Sign-On.  Red Hat Single Sign-On
has a number of adapters for different platforms that you can download.  There are also third-party adapters you can get for environments that we don&#8217;t cover.</p></dd><dt class="hdlist1">consent</dt><dd><p>Consent is when you as an admin want a user to give permission to a client before that client can participate in the authentication process.
After a user provides their credentials, Red Hat Single Sign-On will pop up a screen identifying the client requesting a login and what identity
information is requested of the user.  User can decide whether or not to grant the request.</p></dd><dt class="hdlist1">client scopes</dt><dd><p>When a client is registered, you must define protocol mappers and role scope mappings for that client. It is often useful to store
a client scope, to make creating new clients easier by sharing some common settings. This is also useful for requesting some
claims or roles to be conditionally based on the value of <code>scope</code> parameter. Red Hat Single Sign-On provides the concept of a client scope for this.</p></dd><dt class="hdlist1">client role</dt><dd><p>Clients can define roles that are specific to them.  This is basically a role namespace dedicated to the client.</p></dd><dt class="hdlist1">identity token</dt><dd><p>A token that provides identity information about the user.  Part of the OpenID Connect specification.</p></dd><dt class="hdlist1">access token</dt><dd><p>A token that can be provided as part of an HTTP request that grants access to the service being invoked on.  This is part of
the OpenID Connect and OAuth 2.0 specification.</p></dd><dt class="hdlist1">assertion</dt><dd><p>Information about a user.  This usually pertains to an XML blob that is included in a SAML authentication response that
provided identity metadata about an authenticated user.</p></dd><dt class="hdlist1">service account</dt><dd><p>Each client has a built-in service account which allows it to obtain an access token.</p></dd><dt class="hdlist1">direct grant</dt><dd><p>A way for a client to obtain an access token on behalf of a user via a REST invocation.</p></dd><dt class="hdlist1">protocol mappers</dt><dd><p>For each client you can tailor what claims and assertions are stored in the OIDC token or SAML assertion.  You do this per client by creating and configuring
protocol mappers.</p></dd><dt class="hdlist1">session</dt><dd><p>When a user logs in, a session is created to manage the login session.  A session contains information like when the user logged in and what
applications have participated within single-sign on during that session.  Both admins and users can view session information.</p></dd><dt class="hdlist1">user federation provider</dt><dd><p>Red Hat Single Sign-On can store and manage users.  Often, companies already have LDAP or Active Directory services that store user and credential
information.  You can point Red Hat Single Sign-On to validate credentials from those external stores and pull in identity information.</p></dd><dt class="hdlist1">identity provider</dt><dd><p>An identity provider (IDP) is a service that can authenticate a user.  Red Hat Single Sign-On is an IDP.</p></dd><dt class="hdlist1">identity provider federation</dt><dd><p>Red Hat Single Sign-On can be configured to delegate authentication to one or more IDPs.  Social login via
Facebook or Google+ is an example of identity provider federation.  You can also hook Red Hat Single Sign-On to delegate
authentication to any other OpenID Connect or SAML 2.0 IDP.</p></dd><dt class="hdlist1">identity provider mappers</dt><dd><p>When doing IDP federation you can map incoming tokens and assertions to user and session attributes.  This helps you propagate identity information from the external IDP
to your client requesting authentication.</p></dd><dt class="hdlist1">required actions</dt><dd><p>Required actions are actions a user must perform during the authentication process.  A user will not be able to complete the authentication process until these actions
are complete.  For example, an admin may schedule users to reset their passwords every month.  An <code>update password</code> required action would be set for all these
users.</p></dd><dt class="hdlist1">authentication flows</dt><dd><p>Authentication flows are work flows a user must perform when interacting with certain aspects of the system.  A login flow can define
what credential types are required.  A registration flow defines what profile information a user must enter and whether something like reCAPTCHA
must be used to filter out bots.  Credential reset flow defines what actions a user must do before they can reset their password.</p></dd><dt class="hdlist1">events</dt><dd><p>Events are audit streams that admins can view and hook into.</p></dd><dt class="hdlist1">themes</dt><dd><p>Every screen provided by Red Hat Single Sign-On is backed by a theme.  Themes define HTML templates and stylesheets which you can override as needed.</p></dd></dl></div></section></section>
<section id="_server_initialization"><h2>Server Initialization</h2><div class="paragraph"><p>After performing all the installation and configuration tasks defined in the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a>,
you will need to create an initial admin account.
Red Hat Single Sign-On does not have any configured admin account out of the box.
This account will allow you to create an admin that can log into the <em>master</em> realm&#8217;s administration console so that
you can start creating realms, users and registering applications to be secured by Red Hat Single Sign-On.</p></div>
<div class="paragraph"><p>If your
server is accessible from <code>localhost</code>, you can boot it up and create this admin user by going to the <a href="http://localhost:8080/auth" class="bare">http://localhost:8080/auth</a> URL.</p></div>
<div class="paragraph"><div class="title">Welcome Page</div><p><span class="image"><img src="rhsso-images/initial-welcome-page.png" alt="initial welcome page"></span></p></div>
<div class="paragraph"><p>Simply specify the username and password you want for this initial admin.</p></div>
<div class="paragraph"><p>If you cannot access the server via a <code>localhost</code> address, or just want to provision Red Hat Single Sign-On from the command line
you can do this with the <code>&#8230;&#8203;/bin/add-user-keycloak</code> script.</p></div>
<div class="paragraph"><div class="title">add-user-keycloak script</div><p><span class="image"><img src="rhsso-images/add-user-script.png" alt="add user script"></span></p></div>
<div class="paragraph"><p>The parameters are a little different depending if you are using the standalone operation mode or domain operation mode.  For
standalone mode, here is how you use the script.</p></div>
<div class="title">Linux/Unix</div><pre class="highlight listingblock"><code>$ .../bin/add-user-keycloak.sh -r master -u &lt;username&gt; -p &lt;password&gt;</code></pre>
<div class="title">Windows</div><pre class="highlight listingblock"><code>&gt; ...\bin\add-user-keycloak.bat -r master -u &lt;username&gt; -p &lt;password&gt;</code></pre>
<div class="paragraph"><p>For domain mode, you have to point the script to one of your server hosts using the <code>-sc</code> switch.</p></div>
<div class="title">Linux/Unix</div><pre class="highlight listingblock"><code>$ .../bin/add-user-keycloak.sh --sc domain/servers/server-one/configuration -r master -u &lt;username&gt; -p &lt;password&gt;</code></pre>
<div class="title">Windows</div><pre class="highlight listingblock"><code>&gt; ...\bin\add-user-keycloak.bat --sc domain/servers/server-one/configuration -r master -u &lt;username&gt; -p &lt;password&gt;</code></pre></section>
<section><section id="_admin_console"><h2>Admin Console</h2><div class="paragraph"><p>The bulk of your administrative tasks will be done through the Red Hat Single Sign-On Admin Console.
You can go to the console url directly at <a href="http://localhost:8080/auth/admin/" class="bare">http://localhost:8080/auth/admin/</a></p></div><div class="paragraph"><div class="title">Login Page</div><p><span class="image"><img src="rhsso-images/login-page.png" alt="login page"></span></p></div><div class="paragraph"><p>Enter the username and password you created on the Welcome Page or the <code>add-user-keycloak</code> script in the bin directory.
This will bring you to the Red Hat Single Sign-On Admin Console.</p></div><div class="paragraph"><div class="title">Admin Console</div><p><span class="image"><img src="rhsso-images/admin-console.png" alt="admin console"></span></p></div><div class="paragraph"><p>The left drop down menu allows you to pick a realm you want to manage or to create a new one.  The right drop down menu allows you to view your user account or logout.
If you are curious about a certain feature, button, or field within the Admin Console, simply hover your mouse
over any question mark <code>?</code> icon.  This will pop up tooltip text to describe the area of the console you are interested in.
The image above shows the tooltip in action.</p></div></section><section id="_the_master_realm"><h2>The Master Realm</h2><div class="paragraph"><p>When you boot Red Hat Single Sign-On for the first time Red Hat Single Sign-On creates a
pre-defined realm for you. This initial realm is the <em>master</em> realm. It is the
highest level in the hierarchy of realms. Admin accounts in this realm have
permissions to view and manage any other realm created on the server instance.
When you define your initial admin account, you create an account in the
<em>master</em> realm. Your initial login to the admin console will also be via the
<em>master</em> realm.</p></div>
<div class="paragraph"><p>We recommend that you do not use the <em>master</em> realm to manage the users
and applications in your organization. Reserve use of the <em>master</em> realm for
<em>super</em> admins to create and manage the realms in your system. Following this
security model helps prevent accidental changes and follows the tradition
of permitting user accounts access to only those privileges and powers necessary
for the successful completion of their current task.</p></div>
<div class="paragraph"><p>It is possible to disable the <em>master</em> realm and define admin accounts within
each individual new realm you create. Each realm has its own dedicated Admin
Console that you can log into with local accounts. This guide talks more about
this in the <a href="#_per_realm_admin_permissions">Dedicated Realm Admin Consoles</a>
chapter.</p></div></section><section id="_create-realm"><h2>Create a New Realm</h2><div class="paragraph"><p>Creating a new realm is very simple.
Mouse over the top left corner drop down menu that is titled with <code>Master</code>.  If you are logged in the master realm
this drop down menu lists all the realms created.  The last entry of this drop down menu is always <code>Add Realm</code>.  Click
this to add a realm.</p></div>
<div class="paragraph"><div class="title">Add Realm Menu</div><p><span class="image"><img src="rhsso-images/add-realm-menu.png" alt="add realm menu"></span></p></div>
<div class="paragraph"><p>This menu option will bring you to the <code>Add Realm</code> page.  Specify the realm name you want to define and click the <code>Create</code> button.
Alternatively you can import a JSON document that defines your new realm.  We&#8217;ll go over this in more detail in the
<a href="#_export_import">Export and Import</a> chapter.</p></div>
<div class="paragraph"><div class="title">Create Realm</div><p><span class="image"><img src="rhsso-images/create-realm.png" alt="create realm"></span></p></div>
<div class="paragraph"><p>After creating the realm you are brought back to the main Admin Console page. The current realm will now be set to
the realm you just created.  You can switch between managing different realms by doing a mouse over on the
top left corner drop down menu.</p></div></section><section id="_ssl_modes"><h2>SSL Mode</h2><div class="paragraph"><p>Each realm has an SSL Mode associated with it.  The SSL Mode defines the SSL/HTTPS requirements for interacting with the realm.
Browsers and applications that interact with the realm must honor the SSL/HTTPS requirements defined by the SSL Mode or they
will not be allowed to interact with the server.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">Red Hat Single Sign-On generates a self-signed certificate the first time it runs.  Please note that self-signed certificates are not secure, and should only be used for testing purposes.  It is highly recommended that you install a CA-signed certificate on the Red Hat Single Sign-On server itself or on a reverse proxy in front of the Red Hat Single Sign-On server.  See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a>.</td></tr></table></div>
<div class="paragraph"><p>To configure the SSL Mode of your realm, you need to click on the <code>Realm Settings</code> left menu item and go to the <code>Login</code> tab.</p></div>
<div class="paragraph"><div class="title">Login Tab</div><p><span class="image"><img src="rhsso-images/login-tab.png" alt="login tab"></span></p></div>
<div class="paragraph"><p>The <code>Require SSL</code> option allows you to pick the SSL Mode you want.  Here is an explanation of each mode:</p></div>
<div class="dlist"><dl><dt class="hdlist1">external requests</dt><dd><p>Users can interact with Red Hat Single Sign-On without SSL so long as they stick to private IP addresses like <code>localhost</code>, <code>127.0.0.1</code>, <code>10.0.x.x</code>, <code>192.168.x.x</code>, and <code>172.16.x.x</code>.
If you try to access Red Hat Single Sign-On without SSL from a non-private IP address you will get an error.</p></dd><dt class="hdlist1">none</dt><dd><p>Red Hat Single Sign-On does not require SSL.  This should really only be used in development when you are playing around with things and don&#8217;t want to bother
configuring SSL on your server.</p></dd><dt class="hdlist1">all requests</dt><dd><p>Red Hat Single Sign-On requires SSL for all IP addresses.</p></dd></dl></div></section><section id="_clear-cache"><h2>Clearing Server Caches</h2><div class="paragraph"><p>Red Hat Single Sign-On will cache everything it can in memory within the limits of your JVM and/or the limits you&#8217;ve configured
it for.  If the Red Hat Single Sign-On database is modified by a third party (i.e. a DBA) outside the scope of the server&#8217;s REST APIs or Admin Console
there&#8217;s a chance parts of the in-memory cache may be stale.  You can clear the realm cache, user cache or cache of external public keys (Public keys of
 external clients or Identity providers, which Red Hat Single Sign-On usually uses to verify signatures of particular external entity) from the Admin Console by going
to the <code>Realm Settings</code> left menu item and the <code>Cache</code> tab.</p></div>
<div class="paragraph"><div class="title">Cache tab</div><p><span class="image"><img src="rhsso-images/cache-tab.png" alt="cache tab"></span></p></div>
<div class="paragraph"><p>Just click the <code>clear</code> button on the cache you want to evict.</p></div></section><section id="_email"><h2>Email Settings</h2><div class="paragraph"><p>Red Hat Single Sign-On sends emails to users to verify their email address, when they forget their passwords, or when an admin needs to
receive notifications about a server event.
To enable Red Hat Single Sign-On to send emails you need to provide Red Hat Single Sign-On with your SMTP server settings.
This is configured per realm.  Go to the <code>Realm Settings</code> left menu
item and click the <code>Email</code> tab.</p></div>
<div class="paragraph"><div class="title">Email Tab</div><p><span class="image"><img src="rhsso-images/email-tab.png" alt="email tab"></span></p></div>
<div class="dlist"><dl><dt class="hdlist1">Host</dt><dd><p><code>Host</code> denotes the SMTP server hostname used for sending emails.</p></dd><dt class="hdlist1">Port</dt><dd><p><code>Port</code> denotes the SMTP server port.</p></dd><dt class="hdlist1">From</dt><dd><p><code>From</code> denotes the address used for the <code>From</code> SMTP-Header for the emails sent.</p></dd><dt class="hdlist1">From Display Name</dt><dd><p><code>From Display Name</code> allows to configure a user friendly email address aliases (optional). If not set the plain <code>From</code> email address will be displayed in email clients.</p></dd><dt class="hdlist1">Reply To</dt><dd><p><code>Reply To</code> denotes the address used for the <code>Reply-To</code> SMTP-Header for the mails sent (optional). If not set the plain <code>From</code> email address will be used.</p></dd><dt class="hdlist1">Reply To Display Name</dt><dd><p><code>Reply To Display Name</code> allows to configure a user friendly email address aliases (optional). If not set the plain <code>Reply To</code> email address will be displayed.</p></dd><dt class="hdlist1">Envelope From</dt><dd><p><code>Envelope From</code> denotes the <a href="https://en.wikipedia.org/wiki/Bounce_address">Bounce Address</a> used for the <code>Return-Path</code> SMTP-Header for the mails sent (optional).</p></dd></dl></div>
<div class="paragraph"><p>As emails are used for recovering usernames and passwords it&#8217;s recommended to use SSL or TLS, especially if the SMTP server is on an external network.
To enable SSL click on <code>Enable SSL</code> or to enable TLS click on <code>Enable TLS</code>.
You will most likely also need to change the <code>Port</code> (the default port for SSL/TLS is 465).</p></div>
<div class="paragraph"><p>If your SMTP server requires authentication click on <code>Enable Authentication</code> and insert the <code>Username</code> and <code>Password</code>. The value of the <code>Password</code> field can refer a value from an external <a href="#_vault-administration">vault</a>.</p></div></section><section id="_themes"><h2>Themes and Internationalization</h2><div class="paragraph"><p>Themes allow you to change the look and feel of any UI in Red Hat Single Sign-On.  Themes are configured per realm.  To change
a theme go to the <code>Realm Settings</code> left menu item and click on the <code>Themes</code> tab.</p></div>
<div class="paragraph"><div class="title">Themes Tab</div><p><span class="image"><img src="rhsso-images/themes-tab.png" alt="themes tab"></span></p></div>
<div class="paragraph"><p>Pick the theme you want for each UI category and click <code>Save</code>.</p></div>
<div class="dlist"><dl><dt class="hdlist1">Login Theme</dt><dd><p>Username password entry, OTP entry, new user registration, and other similar screens related to login.</p></dd><dt class="hdlist1">Account Theme</dt><dd><p>Each user has an User Account Management UI.</p></dd><dt class="hdlist1">Admin Console Theme</dt><dd><p>The skin of the Red Hat Single Sign-On Admin Console.</p></dd><dt class="hdlist1">Email Theme</dt><dd><p>Whenever Red Hat Single Sign-On has to send out an email, it uses templates defined in this theme to craft the email.</p></dd></dl></div>
<div class="paragraph"><p>The <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> goes into how to create a new themes or modify existing ones.</p></div>
<h3>Internationalization</h3><div class="paragraph"><p>Every UI screen is internationalized in Red Hat Single Sign-On.  The default language is English, but if you turn on the
<code>Internationalization</code> switch on the <code>Theme</code> tab you can choose which locales you want to support and what the default locale
will be.  The next time a user logs in, they will be able to choose a language on the login page to use for the login screens,
User Account Management UI, and Admin Console.  The <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> explains
how you can offer additional languages.</p></div></section></section>
<section><section id="_user_management"><h2>User Management</h2><div class="paragraph"><p>This section describes the administration functions for managing users.</p></div></section><section id="_searching_for_users"><h2>Searching For Users</h2><div class="paragraph"><p>If you need to manage a specific user, click on <code>Users</code> in the left menu bar.</p></div>
<div class="paragraph"><div class="title">Users</div><p><span class="image"><img src="rhsso-images/users.png" alt="users"></span></p></div>
<div class="paragraph"><p>This menu option brings you to the user list page.  In the search box you can type in a full name, last name, or email address
you want to search for in the user database.  The query will bring up all users that match your criteria.  The <code>View all users</code> button
will list every user in the system.  This will search just local Red Hat Single Sign-On database and not the federated database (ie. LDAP)
because some backends like LDAP don&#8217;t have a way to page through users. So if you want the users from federated backend to be synced into Red Hat Single Sign-On
database you need to either:</p></div>
<div class="ulist"><ul><li><p>Adjust search criteria. That will sync just the backend users matching the criteria into Red Hat Single Sign-On database.</p></li><li><p>Go to <code>User Federation</code> tab and click <code>Sync all users</code> or <code>Sync changed users</code> in the page with your federation provider.</p></li></ul></div>
<div class="paragraph"><p>See <a href="#_user-storage-federation">User Federation</a> for more details.</p></div></section><section id="_create-new-user"><h2>Creating New Users</h2><div class="paragraph"><p>To create a user click on <code>Users</code> in the left menu bar.</p></div>
<div class="paragraph"><div class="title">Users</div><p><span class="image"><img src="rhsso-images/users.png" alt="users"></span></p></div>
<div class="paragraph"><p>This menu option brings you to the user list page.  On the right side of the empty user list, you should see an <code>Add User</code>
button.  Click that to start creating your new user.</p></div>
<div class="paragraph"><div class="title">Add User</div><p><span class="image"><img src="rhsso-images/add-user.png" alt="add user"></span></p></div>
<div class="paragraph"><p>The only required field is <code>Username</code>.  Click save.  This will bring you to the management page for your new user.</p></div></section><section id="_delete-user"><h2>Deleting Users</h2><div class="paragraph"><p>To delete a user click on <code>Users</code> in the left menu bar.</p></div>
<div class="paragraph"><div class="title">Users</div><p><span class="image"><img src="rhsso-images/users.png" alt="users"></span></p></div>
<div class="paragraph"><p>This menu option brings you to the user list page. Click <code>View all users</code> or search to find the user you intend to delete.</p></div>
<div class="paragraph"><div class="title">Add User</div><p><span class="image"><img src="rhsso-images/delete-user.png" alt="delete user"></span></p></div>
<div class="paragraph"><p>In the list of users, click <code>Delete</code> next to the user you want to remove. You will be asked to confirm that you are sure you want to delete this user. Click <code>Delete</code> in the confirmation box to confirm.</p></div></section><section id="_user_attributes"><h2>User Attributes</h2><div class="paragraph"><p>Beyond basic user metadata like name and email, you can store arbitrary user attributes.  Choose a user to manage
then click on the <code>Attributes</code> tab.</p></div>
<div class="paragraph"><div class="title">Users</div><p><span class="image"><img src="rhsso-images/user-attributes.png" alt="user attributes"></span></p></div>
<div class="paragraph"><p>Enter in the attribute name and value in the empty fields and click the <code>Add</code> button next to it to add a new field.
Note that any edits you make on this page will not be stored until you hit the <code>Save</code> button.</p></div></section><section id="_user_credentials"><h2>User Credentials</h2><div class="paragraph"><p>When viewing a user if you go to the <code>Credentials</code> tab you can manage a user&#8217;s credentials.</p></div>
<div class="paragraph"><div class="title">Credential Management</div><p><span class="image"><img src="rhsso-images/user-credentials.png" alt="user credentials"></span></p></div>
<h3>Changing Passwords</h3><div class="paragraph"><p>To change a user&#8217;s password, type in a new one.  A <code>Reset Password</code> button will show up that you click after you&#8217;ve typed everything in.
If the <code>Temporary</code> switch is on, this new password can only be used once and the user will be asked to change their password after they have
logged in.</p></div>
<div class="paragraph"><p>Alternatively, if you have <a href="#_email">email</a> set up, you can send an email to the user that asks
them to reset their password.  Choose <code>Update Password</code> from the <code>Reset Actions</code> list box and click <code>Send Email</code>. You can optionally
set the validity of the e-mail link which defaults to the one preset in <code>Tokens</code> tab in the realm settings.
The sent email contains a link that will bring the user to the update password screen.</p></div>
<h3>Changing OTPs</h3><div class="paragraph"><p>You cannot configure One-Time Passwords for a specific user within the Admin Console.  This is the responsibility of the user.
If the user has lost their OTP generator all you can do is disable OTP for them on the <code>Credentials</code> tab.
If OTP is optional in your realm, the user will have to go to the User Account Management service to re-configure a new
OTP generator. If OTP is required, then the user will be asked to re-configure a new OTP generator when they log in.</p></div>
<div class="paragraph"><p>Like passwords, you can alternatively send an email to the user that will ask them to reset their OTP generator.  Choose
<code>Configure OTP</code> in the <code>Reset Actions</code> list box and click the <code>Send Email</code> button.  The sent email
contains a link that will bring the user to the OTP setup screen.</p></div></section><section id="_required_actions"><h2>Required Actions</h2><div class="paragraph"><p>Required Actions are tasks that a user must finish before they are allowed to log in.  A user must provide their credentials before required actions are executed.  Once a required action is completed, the user will not have
to perform the action again.
Here are explanations of some of the built-in required action types:</p></div>
<div class="dlist"><dl><dt class="hdlist1">Update Password</dt><dd><p>When set, a user must change their password.</p></dd><dt class="hdlist1">Configure OTP</dt><dd><p>When set, a user must configure a one-time password generator on their mobile device using either the Free OTP or Google Authenticator application.</p></dd><dt class="hdlist1">Verify Email</dt><dd><p>When set, a user must verify that they have a valid email account.  An email will be sent to the user with a link they have to click.  Once this workflow
is successfully completed, they will be allowed to log in.</p></dd><dt class="hdlist1">Update Profile</dt><dd><p>This required action asks the user to update their profile information, i.e. their name, address, email, and/or phone number.</p></dd></dl></div>
<div class="paragraph"><p>Admins can add required actions for each individual user within the user&#8217;s <code>Details</code> tab in the Admin Console.</p></div>
<div class="paragraph"><div class="title">Setting Required Action</div><p><span class="image"><img src="rhsso-images/user-required-action.png" alt="user required action"></span></p></div>
<div class="paragraph"><p>In the <code>Required User Actions</code> list box, select all the actions you want to add to the account.  If you want to remove one, click the <code>X</code> next to the
action name.  Also remember to click the <code>Save</code> button after you&#8217;ve decided what actions to add.</p></div>
<h3>Default Required Actions</h3><div class="paragraph"><p>You can also specify required actions that will be added to an account whenever a new user is created, i.e. through the <code>Add User</code> button the user
list screen, or via the <a href="#_user-registration">user registration</a> link on the login page.  To specify
the default required actions go to the <code>Authentication</code> left menu item and click on the <code>Required Actions</code> tab.</p></div>
<div class="paragraph"><div class="title">Default Required Actions</div><p><span class="image"><img src="rhsso-images/default-required-actions.png" alt="default required actions"></span></p></div>
<div class="paragraph"><p>Simply click the checkbox in the <code>Default Action</code> column of the required actions that you want to be executed when a brand new user logs in.</p></div>
<h3>Terms and Conditions</h3><div class="paragraph"><p>Many organizations have a requirement that when a new user logs in for the first time, they need to agree to the terms and conditions
of the website.  Red Hat Single Sign-On has this functionality implemented as a required action, but it requires some configuration.  For one, you
have to go to the <code>Required Actions</code> tab described earlier and enable the <code>Terms and Conditions</code> action.  You must also edit the
<em>terms.ftl</em> file in the <em>base</em> login theme.  See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more information on extending and
creating themes.</p></div></section><section id="_impersonation"><h2>Impersonation</h2><div class="paragraph"><p>It is often useful for an admin to impersonate a user.  For example, a user may be experiencing a bug in one of your applications and
an admin may want to impersonate the user to see if they can duplicate the problem.  Admins with the appropriate permission
can impersonate a user.  There are two locations an admin can initiate impersonation.  The first is on the <code>Users</code> list tab.</p></div>
<div class="paragraph"><div class="title">Users</div><p><span class="image"><img src="rhsso-images/user-search.png" alt="user search"></span></p></div>
<div class="paragraph"><p>You can see here that the admin has searched for <code>john</code>.  Next to John&#8217;s account you can see an impersonate button.  Click that
to impersonate the user.</p></div>
<div class="paragraph"><p>Also, you can impersonate the user from the user <code>Details</code> tab.</p></div>
<div class="paragraph"><div class="title">User Details</div><p><span class="image"><img src="rhsso-images/user-details.png" alt="user details"></span></p></div>
<div class="paragraph"><p>Near the bottom of the page you can see the <code>Impersonate</code> button.  Click that to impersonate the user.</p></div>
<div class="paragraph"><p>When impersonating, if the admin and the user are in the same realm, then the admin will be logged out and automatically logged
in as the user being impersonated.  If the admin and user are not in the same realm, the admin will remain logged in, but additionally
be logged in as the user in that user&#8217;s realm.  In both cases, the browser will be redirected to the impersonated user&#8217;s User Account Management
page.</p></div>
<div class="paragraph"><p>Any user with the realm&#8217;s <code>impersonation</code> role can impersonate a user.  Please see the <a href="#_admin_permissions">Admin Console Access Control</a> chapter
for more details on assigning administration permissions.</p></div></section><section id="_user-registration"><h2>User Registration</h2><div class="paragraph"><p>You can enable Red Hat Single Sign-On to allow user self registration.  When enabled, the login page has a registration
link the user can click on to create their new account.</p></div>
<div class="paragraph"><p>When user self registration is enabled it is possible to use the registration form to detect valid usernames and emails.
It is also possible to enable <a href="#_recaptcha">reCAPTCHA Support</a>.</p></div>
<div class="paragraph"><p>Enabling registration is pretty simple.  Go to the
<code>Realm Settings</code> left menu and click it.  Then go to the <code>Login</code> tab.  There is a <code>User Registration</code> switch on this
tab.  Turn it on, then click the <code>Save</code> button.</p></div>
<div class="paragraph"><div class="title">Login Tab</div><p><span class="image"><img src="rhsso-images/login-tab.png" alt="login tab"></span></p></div>
<div class="paragraph"><p>After you enable this setting, a <code>Register</code> link should show up on the login page.</p></div>
<div class="paragraph"><div class="title">Registration Link</div><p><span class="image"><img src="rhsso-images/registration-link.png" alt="registration link"></span></p></div>
<div class="paragraph"><p>Clicking on this link will bring the user to the registration page where they have to enter in some user profile information
and a new password.</p></div>
<div class="paragraph"><div class="title">Registration Form</div><p><span class="image"><img src="rhsso-images/registration-form.png" alt="registration form"></span></p></div>
<div class="paragraph"><p>You can change the look and feel of the registration form as well as removing or adding additional fields that must be entered.
See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more information.</p></div>
<h3>reCAPTCHA Support</h3><div class="paragraph"><p>To safeguard registration against bots, Red Hat Single Sign-On has integration with Google reCAPTCHA.
To enable this you need to first go to <a href="https://developers.google.com/recaptcha/">Google Recaptcha Website</a>
and create an API key so that you can get your reCAPTCHA site key and secret.
(FYI, localhost works by default so you don&#8217;t have to specify a domain).</p></div>
<div class="paragraph"><p>Next, there are a few steps you need to perform in the Red Hat Single Sign-On Admin Console.
Click the <code>Authentication</code> left menu item and go to the <code>Flows</code> tab.  Select the <code>Registration</code> flow from the drop down
list on this page.</p></div>
<div class="paragraph"><div class="title">Registration Flow</div><p><span class="image"><img src="rhsso-images/registration-flow.png" alt="registration flow"></span></p></div>
<div class="paragraph"><p>Set the 'reCAPTCHA' requirement to <code>Required</code> by clicking the appropriate radio button.  This will enable
reCAPTCHA on the screen.  Next, you have to enter in the reCAPTCHA site key and secret that you generated at the Google reCAPTCHA Website.
Click on the 'Actions' button that is to the right of the reCAPTCHA flow entry, then "Config" link, and enter in the reCAPTCHA site key and secret on this config page.</p></div>
<div class="paragraph"><div class="title">Recaptcha Config Page</div><p><span class="image"><img src="rhsso-images/recaptcha-config.png" alt="recaptcha config"></span></p></div>
<div class="paragraph"><p>The final step you have to do is to change some default HTTP response headers that Red Hat Single Sign-On sets.  Red Hat Single Sign-On
will prevent a website from including any login page within an iframe.  This is to prevent clickjacking attacks.  You need to
authorize Google to use the registration page within an iframe.  Go to
the <code>Realm Settings</code> left menu item and then go to the <code>Security Defenses</code> tab.  You will need to add <code>https://www.google.com</code> to the
values of both the <code>X-Frame-Options</code> and <code>Content-Security-Policy</code> headers.</p></div>
<div class="paragraph"><div class="title">Authorizing Iframes</div><p><span class="image"><img src="rhsso-images/security-headers.png" alt="security headers"></span></p></div>
<div class="paragraph"><p>Once you do this, reCAPTCHA should show up on your registration page.  You may want to edit <em>register.ftl</em> in your login
theme to muck around with the placement and styling of the reCAPTCHA button.  See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a>
for more information on extending and creating themes.</p></div></section></section>
<section><section id="_login_page_settings"><h2>Login Page Settings</h2><div class="paragraph"><p>There are several nice built-in login page features you can enable if you need the functionality.</p></div></section><section id="_forgot_password"><h2>Forgot Password</h2><div class="paragraph"><p>If you enable it, users are able to reset their credentials if they forget their password or lose their OTP generator.
Go to the <code>Realm Settings</code> left menu item, and click on the <code>Login</code> tab.  Switch on the <code>Forgot Password</code> switch.</p></div>
<div class="paragraph"><div class="title">Login Tab</div><p><span class="image"><img src="rhsso-images/login-tab.png" alt="login tab"></span></p></div>
<div class="paragraph"><p>A <code>forgot password</code> link will now show up on your login pages.</p></div>
<div class="paragraph"><div class="title">Forgot Password Link</div><p><span class="image"><img src="rhsso-images/forgot-password-link.png" alt="forgot password link"></span></p></div>
<div class="paragraph"><p>Clicking on this link will bring the user
to a page where they can enter in their username or email and receive an email with a link to reset their credentials.</p></div>
<div class="paragraph"><div class="title">Forgot Password Page</div><p><span class="image"><img src="rhsso-images/forgot-password-page.png" alt="forgot password page"></span></p></div>
<div class="paragraph"><p>The text sent in the email is completely configurable. You just need to extend or edit the theme associated with it.
See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more information.</p></div>
<div class="paragraph"><p>When the user clicks on the email link, they will be asked to update their password, and, if they have an OTP generator
set up, they will also be asked to reconfigure this as well.  Depending on the security requirements of your organization
you may not want users to be able to reset their OTP generator through email.  You can change this behavior by
going to the <code>Authentication</code> left menu item, clicking on the <code>Flows</code> tab, and selecting the <code>Reset Credentials</code> flow:</p></div>
<div class="paragraph"><div class="title">Reset Credentials Flow</div><p><span class="image"><img src="rhsso-images/reset-credentials-flow.png" alt="reset credentials flow"></span></p></div>
<div class="paragraph"><p>If you do not want OTP reset, then just chose the <code>disabled</code> radio button to the right of <code>Reset OTP</code>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Be sure to leave Update Password enabled on the Required Actions tab.  Otherwise, Forgot Password does not work.</td></tr></table></div></section><section id="_remember_me"><h2>Remember Me</h2><div class="paragraph"><p>If a logged in user closes their browser, their session is destroyed and they will have to log in again.  You can set things
up so that if a user checks a <em>remember me</em> checkbox, they will remain logged in even if the browser is closed.  This basically
turns the login cookie from a session-only cookie to a persistence cookie.</p></div>
<div class="paragraph"><p>To enable this feature go to <code>Realm Settings</code> left menu item and click on the <code>Login</code> tab and turn on the <code>Remember Me</code> switch:</p></div>
<div class="paragraph"><div class="title">Login Tab</div><p><span class="image"><img src="rhsso-images/login-tab.png" alt="login tab"></span></p></div>
<div class="paragraph"><p>Once you save this setting, a <code>remember me</code> checkbox will be displayed on the realm&#8217;s login page.</p></div>
<div class="paragraph"><div class="title">Remember Me</div><p><span class="image"><img src="rhsso-images/remember-me.png" alt="remember me"></span></p></div></section></section>
<section><section id="_authentication"><h2>Authentication</h2><div class="paragraph"><p>There are a few features you should be aware of when configuring authentication for your realm.  Many organizations
have strict password and OTP policies that you can enforce via settings in the Admin Console.  You may or may not
want to require different credential types for authentication.  You may want to give users the option to login via
Kerberos or disable or enable various built-in credential types.  This chapter covers all of these topics.</p></div></section><section id="_password-policies"><h2>Password Policies</h2><div class="paragraph"><p>Each new realm created has no password policies associated with it.  Users can have as short, as long, as complex,
as insecure a password, as they want.  Simple settings are fine for development or learning Red Hat Single Sign-On,
but unacceptable in production environments.  Red Hat Single Sign-On has a rich set of password policies you can enable
through the Admin Console.</p></div>
<div class="paragraph"><p>Click on the <code>Authentication</code> left menu item and go to the <code>Password Policy</code> tab.  Choose the policy you want to add in the
right side drop down list box.  This will add the policy in the table on the screen.  Choose the parameters for the policy.
Hit the <code>Save</code> button to store your changes.</p></div>
<div class="paragraph"><div class="title">Password Policy</div><p><span class="image"><img src="rhsso-images/password-policy.png" alt="password policy"></span></p></div>
<div class="paragraph"><p>After saving your policy, user registration and the Update Password required action will enforce your new policy.  An example of a user
failing the policy check:</p></div>
<div class="paragraph"><div class="title">Failed Password Policy</div><p><span class="image"><img src="rhsso-images/failed-password-policy.png" alt="failed password policy"></span></p></div>
<div class="paragraph"><p>If the password policy is updated, an Update Password action must be set for every user. An automatic trigger is scheduled as a future enhancement.</p></div>
<h3>Password Policy Types</h3><div class="paragraph"><p>Here&#8217;s an explanation of each policy type:</p></div>
<div class="dlist"><dl><dt class="hdlist1">Hashing Algorithm</dt><dd><p>Passwords are not stored as clear text. Instead they are hashed using standard hashing algorithms before they are stored or validated.
Supported values are pbkdf2, pbkdf2-sha256 and pbkdf2-sha512.</p></dd><dt class="hdlist1">Hashing Iterations</dt><dd><p>This value specifies the number of times a password will be hashed before it is stored or verified. The default value is 20,000.
This hashing is done in the rare case that a hacker gets access to your password database. Once they have access to the database,
they can reverse engineer user passwords.
The industry recommended value for this parameter changes every year as CPU power improves. A higher hashing iteration value takes more CPU power for hashing,
and can impact performance. You&#8217;ll have to weigh what is more important to you: performance or protecting your passwords stores.
There may be more cost effective ways of protecting your password stores.</p></dd><dt class="hdlist1">Digits</dt><dd><p>The number of digits required to be in the password string.</p></dd><dt class="hdlist1">Lowercase Characters</dt><dd><p>The number of lower case letters required to be in the password string.</p></dd><dt class="hdlist1">Uppercase Characters</dt><dd><p>The number of upper case letters required to be in the password string.</p></dd><dt class="hdlist1">Special Characters</dt><dd><p>The number of special characters like '?!#%$' required to be in the password string.</p></dd><dt class="hdlist1">Not Username</dt><dd><p>When set, the password is not allowed to be the same as the username.</p></dd><dt class="hdlist1">Regular Expression</dt><dd><p>Define one or more Perl regular expression patterns that passwords must match.</p></dd><dt class="hdlist1">Expire Password</dt><dd><p>The number of days for which the password is valid. After the number of days has expired, the user is required to change their password.</p></dd><dt class="hdlist1">Not Recently Used</dt><dd><p>This policy saves a history of previous passwords. The number of old passwords stored is configurable. When a user changes their password
they cannot use any stored passwords.</p></dd><dt class="hdlist1">Password Blacklist</dt><dd><p>This policy checks if a given password is contained in a blacklist file, which is potentially a very large file.
Password blacklists are UTF-8 plain-text files with Unix line endings where every line represents a blacklisted password.
The file name of the blacklist file must be provided as the password policy value, e.g. <code>10_million_password_list_top_1000000.txt</code>.
Blacklist files are resolved against <code>${jboss.server.data.dir}/password-blacklists/</code> by default.
This path can be customized via the <code>keycloak.password.blacklists.path</code> system property,
or the <code>blacklistsPath</code> property of the <code>passwordBlacklist</code> policy SPI configuration.</p></dd></dl></div></section><section id="_otp_policies"><h2>OTP Policies</h2><div class="paragraph"><p>Red Hat Single Sign-On has a number of policies you can set up for your FreeOTP or Google Authenticator One-Time Password
generator.  Click on the <code>Authentication</code> left menu item and go to the <code>OTP Policy</code> tab.</p></div>
<div class="paragraph"><div class="title">OTP Policy</div><p><span class="image"><img src="rhsso-images/otp-policy.png" alt="otp policy"></span></p></div>
<div class="paragraph"><p>Any policies you set here will be used to validate one-time passwords.  When configuring OTP, FreeOTP and Google Authenticator
can scan a QR code that is generated on the OTP set up page that Red Hat Single Sign-On has.  The bar code is also
generated from information configured on the <code>OTP Policy</code> tab.</p></div>
<h3>TOTP vs. HOTP</h3><div class="paragraph"><p>There are two different algorithms to choose from for your OTP generators.  Time Based (TOTP) and Counter Based (HOTP).
For TOTP, your token generator will hash the current time and a shared secret.  The server validates the OTP by comparing
all the hashes within a certain window of time to the submitted value.  So, TOTPs are valid only for a short window of time (usually 30 seconds).
For HOTP a shared counter is used instead of the current time.  The server increments the counter with each successful OTP login.  So, valid OTPs only
change after a successful login.</p></div>
<div class="paragraph"><p>TOTP is considered a little more secure because the matchable OTP is only valid for a short window of time while the OTP for HOTP can
be valid for an indeterminate amount of time.  HOTP is much more user friendly as the user won&#8217;t have to hurry to enter in their
OTP before the time interval is up.  With the way Red Hat Single Sign-On has implemented TOTP this distinction becomes a little more
blurry.  HOTP requires a database update every time the server wants to increment the counter.  This can be a performance drain
on the authentication server when there is heavy load.  So, to provide a more efficient alternative, TOTP does not remember passwords
used.  This bypasses the need to do any DB updates, but the downside is that TOTPs can be re-used in the valid time interval.  For future
versions of Red Hat Single Sign-On it is planned that you will be able to configure whether TOTP checks older OTPs in the time interval.</p></div>
<h3>TOTP Configuration Options</h3><div class="dlist"><dl><dt class="hdlist1">OTP Hash Algorithm</dt><dd><p>Default is SHA1, more secure options are SHA256 and SHA512.</p></dd><dt class="hdlist1">Number of Digits</dt><dd><p>How many characters is the OTP?  Short means more user friendly as it is less the user has to type.  More means more security.</p></dd><dt class="hdlist1">Look Ahead Window</dt><dd><p>How many intervals ahead should the server try and match the hash?  This exists so just in case the clock of the TOTP generator
or authentication server get out of sync.  The default value of 1 is usually good enough.  For example, if the time interval
for a new token is every 30 seconds, the default value of 1 means that it will only accept valid tokens in that 30 second window.
Each increment of this config value will increase the valid window by 30 seconds.</p></dd><dt class="hdlist1">OTP Token Period</dt><dd><p>Time interval in seconds during which the server will match a hash. Each time the interval passes, a new TOTP will be generated by the token generator.</p></dd></dl></div>
<h3>HOTP Configuration Options</h3><div class="dlist"><dl><dt class="hdlist1">OTP Hash Algorithm</dt><dd><p>Default is SHA1, more secure options are SHA256 and SHA512.</p></dd><dt class="hdlist1">Number of Digits</dt><dd><p>How many characters is the OTP?  Short means more user friendly as it is less the user has to type.  More means more security.</p></dd><dt class="hdlist1">Look Ahead Window</dt><dd><p>How many counters ahead should the server try and match the hash?  The default value is 1.  This exists to cover the case
where the user&#8217;s counter gets ahead of the server&#8217;s.  This can often happen as users often increment the counter
manually too many times by accident.  This value really should be increased to a value of 10 or so.</p></dd><dt class="hdlist1">Initial Counter</dt><dd><p>What is the value of the initial counter?</p></dd></dl></div></section><section id="_authentication-flows"><h2>Authentication Flows</h2><div class="paragraph"><p>An <em>authentication flow</em> is a container for all authentications, screens, and actions that must happen during login, registration, and other
Red Hat Single Sign-On workflows.
If you go to the admin console <code>Authentication</code> left menu item and go to the <code>Flows</code> tab, you can view all the defined flows
in the system and what actions and checks each flow requires.  This section does a walk-through of the browser login flow.  In the
left drop-down list select <code>browser</code> to come to the screen shown below:</p></div>
<div class="paragraph"><div class="title">Browser Flow</div><p><span class="image"><img src="rhsso-images/browser-flow.png" alt="browser flow"></span></p></div>
<div class="paragraph"><p>If you hover over the tooltip (the tiny question mark) to the right of the flow selection list, this will describe what the
flow is and does.</p></div>
<div class="paragraph"><p>The <code>Auth Type</code> column is the name of authentication or action that will be executed.  If an authentication is indented
this means it is in a sub-flow and may or may not be executed depending on the behavior of its parent.  The <code>Requirement</code>
column is a set of radio buttons which define whether or not the action will execute.  Let&#8217;s describe what each radio
button means:</p></div>
<div class="dlist"><dl><dt class="hdlist1">Required</dt><dd><p>This authentication execution must execute successfully.  If the user doesn&#8217;t have that type of authentication mechanism
configured and there is a required action associated with that authentication type, then a required action will be attached
to that account.  For example, if you switch <code>OTP Form</code> to <code>Required</code>, users that don&#8217;t have an OTP generator configured
will be asked to do so.</p></dd><dt class="hdlist1">Optional</dt><dd><p>If the user has the authentication type configured, it will be executed.  Otherwise, it will be ignored.</p></dd><dt class="hdlist1">Disabled</dt><dd><p>If disabled, the authentication type is not executed.</p></dd><dt class="hdlist1">Alternative</dt><dd><p>This means that at least one alternative authentication type must execute successfully at that level of the flow.</p></dd></dl></div>
<div class="paragraph"><p>This is better described in an example.  Let&#8217;s walk through the <code>browser</code> authentication flow.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>The first authentication type is <code>Cookie</code>.  When a user successfully logs in for the first time, a session cookie is set.
If this cookie has already been set, then this authentication type is successful.
Since the cookie provider returned success and each execution at this level of the flow is <em>alternative</em>, no other execution is executed and this results in a successful login.</p></li><li><p>Next the flow looks at the Kerberos execution.  This authenticator is disabled by default and will be skipped.</p></li><li><p>The next execution is a subflow called Forms.  Since this subflow is marked as <em>alternative</em> it will not be executed if the <code>Cookie</code> authentication type passed.
This subflow contains additional authentication type that needs to be executed.
The executions for this subflow are loaded and the same processing logic occurs</p></li><li><p>The first execution in the Forms subflow is the Username Password Form.  This authentication type renders the username and password page.
It is marked as <em>required</em> so the user must enter in a valid username and password.</p></li><li><p>The next execution is the OTP Form.
This is marked as <em>optional</em>.  If the user has OTP set up, then this authentication type must run and be successful.  If the user doesn&#8217;t
have OTP set up, this authentication type is ignored.</p></li></ol></div></section><section id="_kerberos"><h2>Kerberos</h2><div class="paragraph"><p>Red Hat Single Sign-On supports login with a Kerberos ticket through the SPNEGO protocol.
SPNEGO (Simple and Protected GSSAPI Negotiation Mechanism) is used to authenticate transparently through the web browser after the user
has been authenticated when logging-in his session.
For non-web cases or when ticket is not available during login, Red Hat Single Sign-On also supports login with Kerberos username/password.</p></div>
<div class="paragraph"><p>A typical use case for web authentication is the following:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>User logs into his desktop (Such as a Windows machine in Active Directory domain or Linux machine with Kerberos integration enabled).</p></li><li><p>User then uses his browser (IE/Firefox/Chrome) to access a web application secured by Red Hat Single Sign-On.</p></li><li><p>Application redirects to Red Hat Single Sign-On login.</p></li><li><p>Red Hat Single Sign-On renders HTML login screen together with status 401 and HTTP header <code>WWW-Authenticate: Negotiate</code></p></li><li><p>In case that the browser has Kerberos ticket from desktop login, it transfers the desktop sign on information to the Red Hat Single Sign-On
in header <code>Authorization: Negotiate 'spnego-token'</code> . Otherwise it just displays the login screen.</p></li><li><p>Red Hat Single Sign-On validates token from the browser and authenticates the user.
It provisions user data from LDAP (in case of LDAPFederationProvider with Kerberos authentication support) or let user
to update his profile and prefill data (in case of KerberosFederationProvider).</p></li><li><p>Red Hat Single Sign-On returns back to the application.
Communication between Red Hat Single Sign-On and application happens through OpenID Connect or SAML messages.
The fact that Red Hat Single Sign-On was authenticated through Kerberos is hidden from the application.
So Red Hat Single Sign-On acts as broker to Kerberos/SPNEGO login.</p></li></ol></div>
<div class="paragraph"><p>For setup there are 3 main parts:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Setup and configuration of Kerberos server (KDC)</p></li><li><p>Setup and configuration of Red Hat Single Sign-On server</p></li><li><p>Setup and configuration of client machines</p></li></ol></div>
<h3>Setup of Kerberos server</h3><div class="paragraph"><p>This is platform dependent.
Exact steps depend on your OS and the Kerberos vendor you&#8217;re going to use.
Consult Windows Active Directory, MIT Kerberos and your OS documentation for how exactly to setup and configure Kerberos server.</p></div>
<div class="paragraph"><p>At least you will need to:</p></div>
<div class="ulist"><ul><li><p>Add some user principals to your Kerberos database.
You can also integrate your Kerberos with LDAP, which means that user accounts will be provisioned from LDAP server.</p></li><li><p>Add service principal for "HTTP" service.
For example if your Red Hat Single Sign-On server will be running on <code>www.mydomain.org</code> you may need to add principal <code>HTTP/www.mydomain.org@MYDOMAIN.ORG</code>
assuming that MYDOMAIN.ORG will be your Kerberos realm.</p><div class="paragraph"><p>For example on MIT Kerberos you can run a "kadmin" session.
If you are on the same machine where is MIT Kerberos, you can simply use the command:</p></div></li></ul></div>
<pre class="highlight listingblock"><code>sudo kadmin.local</code></pre>
<div class="paragraph"><p>Then add HTTP principal and export his key to a keytab file with the commands like:</p></div>
<pre class="highlight listingblock"><code>addprinc -randkey HTTP/www.mydomain.org@MYDOMAIN.ORG
ktadd -k /tmp/http.keytab HTTP/www.mydomain.org@MYDOMAIN.ORG</code></pre>
<div class="paragraph"><p>The Keytab file <code>/tmp/http.keytab</code> will need to be accessible on the host where Red Hat Single Sign-On server will be running.</p></div>
<h3>Setup and configuration of Red Hat Single Sign-On server</h3><div class="paragraph"><p>You need to install a kerberos client on your machine.  This is also platform dependent.
If you are on Fedora, Ubuntu or RHEL, you can install the package <code>freeipa-client</code>, which contains a Kerberos client and several other utilities.
Configure the kerberos client (on Linux it&#8217;s in file <code>/etc/krb5.conf</code> ). You need to put your Kerberos realm and at least configure the HTTP domains your server will be running on.
For the example realm MYDOMAIN.ORG you may configure the <code>domain_realm</code> section like this:</p></div>
<pre class="highlight listingblock"><code>[domain_realm]
  .mydomain.org = MYDOMAIN.ORG
  mydomain.org = MYDOMAIN.ORG</code></pre>
<div class="paragraph"><p>Next you need to export the keytab file with the HTTP principal and make sure the file is accessible to the process under which Red Hat Single Sign-On server is running.
For production, it&#8217;s ideal if it&#8217;s readable just by this process and not by someone else.
For the MIT Kerberos example above, we already exported keytab to <code>/tmp/http.keytab</code> . If your KDC and Red Hat Single Sign-On are running on same host,
you have that file already available.</p></div>
<h4>Enable SPNEGO Processing</h4><div class="paragraph"><p>Red Hat Single Sign-On does not have the SPNEGO protocol support turned on by default.  So, you have to go to the <a href="#_authentication-flows">browser flow</a>
and enable <code>Kerberos</code>.</p></div>
<div class="paragraph"><div class="title">Browser Flow</div><p><span class="image"><img src="rhsso-images/browser-flow.png" alt="browser flow"></span></p></div>
<div class="paragraph"><p>Switch the <code>Kerberos</code> requirement from <em>disabled</em> to either <em>alternative</em> or <em>required</em>.  <em>Alternative</em> basically means that Kerberos is optional.  If
the user&#8217;s browser hasn&#8217;t been configured to work with SPNEGO/Kerberos, then Red Hat Single Sign-On will fall back to the regular login screens.  If you set the requirement
to <em>required</em> then all users must have Kerberos enabled for their browser.</p></div>
<h4>Configure Kerberos User Storage Federation Provider</h4><div class="paragraph"><p>Now that the SPNEGO protocol is turned on at the authentication server, you&#8217;ll need to configure how Red Hat Single Sign-On interprets the Kerberos ticket.
This is done through <a href="#_user-storage-federation">User Storage Federation</a>. We have 2 different federation providers with Kerberos authentication support.</p></div>
<div class="paragraph"><p>If you want to authenticate with Kerberos backed by an LDAP server, you have to first configure the <a href="#_ldap">LDAP Federation Provider</a>.
If you look at the configuration page for your LDAP provider you&#8217;ll see a <code>Kerberos Integration</code> section.</p></div>
<div class="paragraph"><div class="title">LDAP Kerberos Integration</div><p><span class="image"><img src="rhsso-images/ldap-kerberos.png" alt="ldap kerberos"></span></p></div>
<div class="paragraph"><p>Turning on the switch <code>Allow Kerberos authentication</code> will make Red Hat Single Sign-On use the Kerberos principal to lookup information about the user so that it can
be imported into the Red Hat Single Sign-On environment.</p></div>
<div class="paragraph"><p>If your Kerberos solution is not backed by an LDAP server, you have to use the <code>Kerberos</code> User Storage Federation Provider.  Go to the <code>User Federation</code>
left menu item and select <code>Kerberos</code> from the <code>Add provider</code> select box.</p></div>
<div class="paragraph"><div class="title">Kerberos User Storage Provider</div><p><span class="image"><img src="rhsso-images/kerberos-provider.png" alt="kerberos provider"></span></p></div>
<div class="paragraph"><p>This provider parses the Kerberos ticket for simple principal information and does a small import into the local Red Hat Single Sign-On database.
User profile information like first name, last name, and email are not provisioned.</p></div>
<h3>Setup and configuration of client machines</h3><div class="paragraph"><p>Clients need to install kerberos client and setup krb5.conf as described above.
Additionally they need to enable SPNEGO login support in their browser.
See <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/configuring_applications_for_sso">configuring Firefox for Kerberos</a> if you are using that browser.
URI <code>.mydomain.org</code> must be allowed in the <code>network.negotiate-auth.trusted-uris</code> config option.</p></div>
<div class="paragraph"><p>In a Windows domain, clients usually don&#8217;t need to configure anything special as IE is already able to participate in SPNEGO authentication for the Windows domain.</p></div>
<h3>Credential Delegation</h3><div class="paragraph"><p>Kerberos 5 supports the concept of credential delegation.  In this scenario, your applications may want access to the Kerberos ticket so that
they can re-use it to interact with other services secured by Kerberos.  Since the SPNEGO protocol is processed in the Red Hat Single Sign-On server,
you have to propagate the GSS credential to your application
within the  OpenID Connect token claim or a SAML assertion attribute that is transmitted to your application from the Red Hat Single Sign-On server.
To have this claim inserted into the token or assertion, each application will need to enable the built-in protocol mapper called <code>gss delegation credential</code>.
This is enabled in the <code>Mappers</code> tab of the application&#8217;s
client page.  See <a href="#_protocol-mappers">Protocol Mappers</a> chapter for more details.</p></div>
<div class="paragraph"><p>Applications will need to deserialize the claim it receives from Red Hat Single Sign-On before it can use it to make GSS calls against other services.
Once you deserialize the credential from the access token to the GSSCredential object, the GSSContext will need to be created with this credential
passed to the method <code>GSSManager.createContext</code> for example like this:</p></div>
<pre class="highlight listingblock"><code class="java language-java">// Obtain accessToken in your application.
KeycloakPrincipal keycloakPrincipal = (KeycloakPrincipal) servletReq.getUserPrincipal();
AccessToken accessToken = keycloakPrincipal.getKeycloakSecurityContext().getToken();

// Retrieve kerberos credential from accessToken and deserialize it
String serializedGssCredential = (String) accessToken.getOtherClaims().
    get(org.keycloak.common.constants.KerberosConstants.GSS_DELEGATION_CREDENTIAL);

GSSCredential deserializedGssCredential = org.keycloak.common.util.KerberosSerializationUtils.
    deserializeCredential(serializedGssCredential);

// Create GSSContext to call other kerberos-secured services
GSSContext context = gssManager.createContext(serviceName, krb5Oid,
    deserializedGssCredential, GSSContext.DEFAULT_LIFETIME);</code></pre>
<div class="paragraph"><p>Note that you also need to configure <code>forwardable</code> kerberos tickets in <code>krb5.conf</code> file and add support for delegated credentials to your browser.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">Credential delegation has some security implications so only use it if you really need it.
         It&#8217;s highly recommended to use it together with HTTPS.
         See for example <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/configuring_applications_for_sso">this article</a> for more details.</td></tr></table></div>
<h3>Cross-realm trust</h3><div class="paragraph"><p>In the Kerberos V5 protocol, the <code>realm</code> is a set of Kerberos principals defined in the Kerberos database (typically LDAP server).
The Kerberos protocol has a concept of cross-realm trust. For example, if there are 2 kerberos realms A and B, the cross-realm trust
will allow the users from realm A to access resources (services) of realm B. This means that realm B trusts the realm A.</p></div>
<div class="paragraph"><div class="title">Kerberos cross-realm trust</div><p><span class="image"><img src="images/kerberos-trust-basic.png" alt="kerberos trust basic"></span></p></div>
<div class="paragraph"><p>The Red Hat Single Sign-On server has support for cross-realm trust. There are few things which need to be done to achieve this:</p></div>
<div class="ulist"><ul><li><p>Configure the Kerberos servers for the cross-realm trust. This step is dependent on the concrete Kerberos server implementations used.
In general, it is needed to add the Kerberos principal <code>krbtgt/B@A</code> to both Kerberos databases of realm A and B. It is needed that
this principal has same keys on both Kerberos realms. This is usually achieved when the principals have same password, key version number
and there are same ciphers used in both realms. It is recommended to consult the Kerberos server documentation for more details.</p></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">The cross-realm trust is unidirectional by default. If you want bidirectional trust to have realm A also trust realm B,
you must also add the principal <code>krbtgt/A@B</code> to both Kerberos databases. However, trust is transitive by default. If realm B
trusts realm A and realm C trusts realm B, then realm C automatically trusts realm A without a need to have principal <code>krbtgt/C@A</code>
available. Some additional configuration (for example <code>capaths</code>) may be needed to configure on Kerberos client side, so that
the clients are able to find the trust path. Consult the Kerberos documentation for more details.</td></tr></table></div>
<div class="ulist"><ul><li><p>Configure Red Hat Single Sign-On server</p><div class="ulist"><ul><li><p>If you use an LDAP storage provider with Kerberos support, you need to configure the server principal for realm B as in this
example: <code>HTTP/mydomain.com@B</code>. The LDAP server must be able to find the users from realm A if you want users from realm A to
successfully authenticate to Red Hat Single Sign-On, as Red Hat Single Sign-On server must be able to do SPNEGO flow and then find the users.
For example, kerberos principal user <code>john@A</code> must be available as a user in the LDAP under an LDAP DN
such as <code>uid=john,ou=People,dc=example,dc=com</code>. If you want both users from realm A and B to authenticate, you need to ensure
that LDAP is able to find users from both realms A and B. We want to improve this limitation in future versions, so you can
potentially create more separate LDAP providers for separate realms and ensure that SPNEGO works for both of them.</p></li><li><p>If you use a Kerberos user storage provider (typically the Kerberos without LDAP integration), you need to configure the
server principal as <code>HTTP/mydomain.com@B</code> and users from both Kerberos realms A and B should be able to authenticate.</p></li></ul></div></li></ul></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">For the Kerberos user storage provider, it is recommended that there are no conflicting users among kerberos realms. If
conflicting users exist, they will be mapped to the same Red Hat Single Sign-On user. This is also something, which we want to improve in
future versions and provide some more flexible mappings from Kerberos principals to Red Hat Single Sign-On usernames.</td></tr></table></div>
<h3>Troubleshooting</h3><div class="paragraph"><p>If you have issues, we recommend that you enable additional logging to debug the problem:</p></div>
<div class="ulist"><ul><li><p>Enable <code>Debug</code> flag in admin console for Kerberos or LDAP federation providers</p></li><li><p>Enable TRACE logging for category <code>org.keycloak</code> in logging section of <code>standalone/configuration/standalone.xml</code> to receive more info <code>standalone/log/server.log</code></p></li><li><p>Add system properties <code>-Dsun.security.krb5.debug=true</code> and <code>-Dsun.security.spnego.debug=true</code></p></li></ul></div></section><section id="_x509"><h2>X.509 Client Certificate User Authentication</h2><div class="paragraph"><p>Red Hat Single Sign-On supports login with a X.509 client certificate if the server is configured for mutual SSL authentication.</p></div>
<div class="paragraph"><p>A typical workflow is as follows:</p></div>
<div class="ulist"><ul><li><p>A client sends an authentication request over SSL/TLS channel</p></li><li><p>During SSL/TLS handshake, the server and the client exchange their x.509/v3 certificates</p></li><li><p>The container (JBoss EAP) validates the certificate PKIX path and the certificate expiration</p></li><li><p>The x.509 client certificate authenticator validates the client certificate as follows:</p><div class="ulist"><ul><li><p>Optionally checks the certificate revocation status using CRL and/or CRL Distribution Points</p></li><li><p>Optionally checks the Certificate revocation status using OCSP (Online Certificate Status Protocol)</p></li><li><p>Optionally validates whether the key usage in the certificate matches the expected key usage</p></li><li><p>Optionally validates whether the extended key usage in the certificate matches the expected extended key usage</p></li></ul></div></li><li><p>If any of the above checks fails, the x.509 authentication fails</p></li><li><p>Otherwise, the authenticator extracts the certificate identity and maps it to an existing user</p></li><li><p>Once the certificate is mapped to an existing user, the behavior diverges depending on the authentication flow:</p><div class="ulist"><ul><li><p>In the Browser Flow, the server prompts the user to confirm identity or to ignore it and instead sign in with username/password</p></li><li><p>In the case of the Direct Grant Flow, the server signs in the user</p></li></ul></div></li></ul></div>
<h3>Features</h3><div class="dlist"><dl><dt class="hdlist1">Supported Certificate Identity Sources</dt><dd><div class="ulist"><ul><li><p>Match SubjectDN using regular expression</p></li><li><p>X500 Subject&#8217;s e-mail attribute</p></li><li><p>X500 Subject&#8217;s e-mail from Subject Alternative Name Extension (RFC822Name General Name)</p></li><li><p>X500 Subject&#8217;s other name from Subject Alternative Name Extension. This is typically UPN (User Principal Name)</p></li><li><p>X500 Subject&#8217;s Common Name attribute</p></li><li><p>Match IssuerDN using regular expression</p></li><li><p>Certificate Serial Number</p></li><li><p>Certificate Serial Number and IssuerDN</p></li><li><p>SHA-256 Certificate thumbprint</p></li><li><p>Full certificate in PEM format</p></li></ul></div></dd><dt class="hdlist1">Regular Expressions</dt><dd><p>The certificate identity can be extracted from either Subject DN or Issuer DN using a regular expression as a filter. For example, the regular expression below will match the e-mail attribute:</p></dd></dl></div>
<pre class="highlight listingblock"><code>emailAddress=(.*?)(?:,|$)</code></pre>
<div class="paragraph"><p>The regular expression filtering is applicable only if the <code>Identity Source</code> is set to either <code>Match SubjectDN using regular expression</code> or <code>Match IssuerDN using regular expression</code>.</p></div>
<div class="dlist"><dl><dt class="hdlist1">Mapping certificate identity to an existing user</dt><dd><p>The certificate identity mapping can be configured to map the extracted user identity to an existing user&#8217;s username or e-mail or to a custom attribute which value matches the certificate identity. For example, setting the <code>Identity source</code> to <em>Subject&#8217;s e-mail</em> and <code>User mapping method</code> to <em>Username or email</em> will have the X.509 client certificate authenticator use the e-mail attribute in the certificate&#8217;s Subject DN  as a search criteria to look up an existing user by username or by e-mail.</p></dd></dl></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">Please notice that if we disable <code>Login with email</code> at realm settings, the same rules will be applied to certificate authentication. In other words, users won&#8217;t be able to log in using e-mail attribute.</td></tr></table></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">Usage of <code>Certificate Serial Number and IssuerDN</code> as an identity source requires two custom attributes - one for serial number and the other for IssuerDN.</td></tr></table></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content"><code>SHA-256 Certificate thumbprint</code> is lowercase hexadecimal representation of SHA-256 certificate thumbprint.</td></tr></table></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">Usage of <code>Full certificate in PEM format</code> as an identity source is limited to custom attributes mapped to external federation sources like LDAP. You must enable <code>Always Read Value From LDAP</code> in this case, because certificates cannot be stored in Keycloak database due to a length limitation.</td></tr></table></div>
<div class="dlist"><dl><dt class="hdlist1">Other Features: Extended Certificate Validation</dt><dd><div class="ulist"><ul><li><p>Revocation status checking using CRL</p></li><li><p>Revocation status checking using CRL/Distribution Point</p></li><li><p>Revocation status checking using OCSP/Responder URI</p></li><li><p>Certificate KeyUsage validation</p></li><li><p>Certificate ExtendedKeyUsage validation</p></li></ul></div></dd></dl></div>
<h3>Enable X.509 Client Certificate User Authentication</h3><div class="paragraph"><p>The following sections describe how to configure JBoss EAP/Undertow and the Red Hat Single Sign-On Server to enable X.509 client certificate authentication.</p></div>
<div class="dlist" id="_enable-mtls-wildfly"><dl><dt class="hdlist1">Enable mutual SSL in JBoss EAP</dt><dd><p>See <a href="https://docs.jboss.org/author/display/WFLY10/Admin+Guide#AdminGuide-EnableSSL">Enable SSL</a> and <a href="https://docs.jboss.org/author/display/WFLY10/Admin+Guide#AdminGuide-%7B%7B%3Cssl%2F%3E%7D%7D">SSL</a> for the instructions how to enable SSL in JBoss EAP.</p><div class="ulist"><ul><li><p>Open RHSSO_HOME/standalone/configuration/standalone.xml and add a new realm:</p></li></ul></div></dd></dl></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;security-realms&gt;
    &lt;security-realm name="ssl-realm"&gt;
        &lt;server-identities&gt;
            &lt;ssl&gt;
                &lt;keystore path="servercert.jks"
                          relative-to="jboss.server.config.dir"
                          keystore-password="servercert password"/&gt;
            &lt;/ssl&gt;
        &lt;/server-identities&gt;
        &lt;authentication&gt;
            &lt;truststore path="truststore.jks"
                        relative-to="jboss.server.config.dir"
                        keystore-password="truststore password"/&gt;
        &lt;/authentication&gt;
    &lt;/security-realm&gt;
&lt;/security-realms&gt;</code></pre>
<div class="dlist"><dl><dt class="hdlist1"><code>ssl/keystore</code></dt><dd><p>The <code>ssl</code> element contains the <code>keystore</code> element that defines how to load the server public key pair from a JKS keystore</p></dd><dt class="hdlist1"><code>ssl/keystore/path</code></dt><dd><p>A path to a JKS keystore</p></dd><dt class="hdlist1"><code>ssl/keystore/relative-to</code></dt><dd><p>Defines a path the keystore path is relative to</p></dd><dt class="hdlist1"><code>ssl/keystore/keystore-password</code></dt><dd><p>The password to open the keystore</p></dd><dt class="hdlist1"><code>ssl/keystore/alias</code> (optional)</dt><dd><p>The alias of the entry in the keystore. Set it if the keystore contains multiple entries</p></dd><dt class="hdlist1"><code>ssl/keystore/key-password</code> (optional)</dt><dd><p>The private key password, if different from the keystore password.</p></dd><dt class="hdlist1"><code>authentication/truststore</code></dt><dd><p>Defines how to load a trust store to verify the certificate presented by the remote side of the inbound/outgoing connection. Typically, the truststore contains a collection of trusted CA certificates.</p></dd><dt class="hdlist1"><code>authentication/truststore/path</code></dt><dd><p>A path to a JKS keystore that contains the certificates of the trusted CAs (certificate authorities)</p></dd><dt class="hdlist1"><code>authentication/truststore/relative-to</code></dt><dd><p>Defines a path the truststore path is relative to</p></dd><dt class="hdlist1"><code>authentication/truststore/keystore-password</code></dt><dd><p>The password to open the truststore</p></dd><dt class="hdlist1">Enable https listener</dt><dd><p>See <a href="https://docs.jboss.org/author/display/WFLY10/Admin+Guide#AdminGuide-HTTPSlistener">HTTPS Listener</a> for the instructions how to enable HTTPS in WildFly.</p><div class="ulist"><ul><li><p>Add the &lt;https-listener&gt; element as shown below:</p></li></ul></div></dd></dl></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
	....
    &lt;server name="default-server"&gt;
	    &lt;https-listener name="default"
                        socket-binding="https"
                        security-realm="ssl-realm"
                        verify-client="REQUESTED"/&gt;
    &lt;/server&gt;
&lt;/subsystem&gt;</code></pre>
<div class="dlist"><dl><dt class="hdlist1"><code>https-listener/security-realm</code></dt><dd><p>The value must match the name of the realm from the previous section</p></dd><dt class="hdlist1"><code>https-listener/verify-client</code></dt><dd><p>If set to <code>REQUESTED</code>, the server will optionally ask for a client certificate. Setting the attribute to <code>REQUIRED</code> will have the server to refuse inbound connections if no client certificate has been provided.</p></dd></dl></div>
<h3>Adding X.509 Client Certificate Authentication to a Browser Flow</h3><div class="ulist"><ul><li><p>Select a realm, click on Authentication link, select the "Browser" flow</p></li><li><p>Make a copy of the built-in "Browser" flow. You may want to give the new flow a distinctive name, i.e. "X.509 Browser"</p></li><li><p>Using the drop down, select the copied flow, and click on "Add execution"</p></li><li><p>Select "X509/Validate Username Form" using the drop down and click on "Save"</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/x509-execution.png" alt="x509 execution"></span></p></div>
<div class="ulist"><ul><li><p>Using the up/down arrows, change the order of the "X509/Validate Username Form" by moving it above the "Browser Forms" execution, and set the requirement to "ALTERNATIVE"</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/x509-browser-flow.png" alt="x509 browser flow"></span></p></div>
<div class="ulist"><ul><li><p>Select the "Bindings" tab, find the drop down for "Browser Flow". Select the newly created X509 browser flow from the drop down and click on "Save".</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/x509-browser-flow-bindings.png" alt="x509 browser flow bindings"></span></p></div>
<div class="dlist"><dl><dt class="hdlist1">Configuring X.509 Client Certificate Authentication</dt><dd><p><span class="image"><img src="images/x509-configuration.png" alt="x509 configuration"></span></p></dd><dt class="hdlist1"><code>User Identity Source</code></dt><dd><p>Defines how to extract the user identity from a client certificate.</p></dd><dt class="hdlist1"><code>Canonical DN representation enabled</code> (optional)</dt><dd><p>Defines whether to use the canonical format to determine a distinguished name.
The format is described in detail in the official <a href="https://docs.oracle.com/javase/8/docs/api/javax/security/auth/x500/X500Principal.html#getName-java.lang.String-">Java API documentation</a> .
This option only affects the two User Identity Sources <em>Match SubjectDN using regular expression</em> and <em>Match IssuerDN using regular expression</em>.
If you setup a new keycloak instance it is recommended to enable this option. Leave this option disabled to remain beckward compatible with existing Keycloak instances.</p></dd><dt class="hdlist1"><code>Enable Serial Number hexadecimal representation</code> (optional)</dt><dd><p>An option to use hexadecimal representation of the Serial Number. See <a href="https://tools.ietf.org/html/rfc5280#section-4.1.2.2">RFC5280, Section-4.1.2.2</a>. Serial Number with sign bit set to 1 should be left padded with 00 octet. E.g. Serial number with decimal value <em>161</em>, or <em>a1</em> in hexadecimal representation according to RFC5280 must be encoded as <em>00a1</em>. More details can be found: <a href="https://tools.ietf.org/html/rfc5280#appendix-B">RFC5280, appendix-B</a>.</p></dd><dt class="hdlist1"><code>A regular expression</code> (optional)</dt><dd><p>Defines a regular expression to use as a filter to extract the certificate identity. The regular expression must contain a single group.</p></dd><dt class="hdlist1"><code>User Mapping Method</code></dt><dd><p>Defines how to match the certificate identity to an existing user. <em>Username or e-mail</em> will search for an existing user by username or e-mail. <em>Custom Attribute Mapper</em> will  search for an existing user with a custom attribute which value matches the certificate identity. The name of the custom attribute is configurable.</p></dd><dt class="hdlist1"><code>A name of user attribute</code> (optional)</dt><dd><p>A custom attribute which value will be matched against the certificate identity. Multiple custom attributes are relevant when attribute mapping is related to multiple values, e.g. 'Certificate Serial Number and IssuerDN'.</p></dd><dt class="hdlist1"><code>CRL Checking Enabled</code> (optional)</dt><dd><p>Defines whether to check the revocation status of the certificate using Certificate Revocation List.</p></dd><dt class="hdlist1"><code>Enable CRL Distribution Point to check certificate revocation status</code> (optional)</dt><dd><p>Defines whether to use CDP to check the certificate revocation status. Most PKI authorities include CDP in their certificates.</p></dd><dt class="hdlist1"><code>CRL file path</code> (optional)</dt><dd><p>Defines a path to a file that contains a CRL list. The value must be a path to a valid file if <code>CRL Checking Enabled</code> option is turned on.</p></dd><dt class="hdlist1"><code>OCSP Checking Enabled</code>(optional)</dt><dd><p>Defines whether to check the certificate revocation status using Online Certificate Status Protocol.</p></dd><dt class="hdlist1"><code>OCSP Responder URI</code> (optional)</dt><dd><p>Allows to override a value of the OCSP responder URI in the certificate.</p></dd><dt class="hdlist1"><code>Validate Key Usage</code> (optional)</dt><dd><p>Verifies whether the certificate&#8217;s KeyUsage extension bits are set. For example, "digitalSignature,KeyEncipherment" will verify if  bits 0 and 2 in the KeyUsage extension are asserted. Leave the parameter empty to disable the Key Usage validation. See <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.3">RFC5280, Section-4.2.1.3</a>. The server will raise an error only when flagged as critical by the issuing CA and there is a key usage extension mismatch.</p></dd><dt class="hdlist1"><code>Validate Extended Key Usage</code> (optional)</dt><dd><p>Verifies one or more purposes as defined in the Extended Key Usage extension. See <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.12">RFC5280, Section-4.2.1.12</a>. Leave the parameter empty to disable the Extended Key Usage validation. The server will raise an error only when flagged as critical by the issuing CA and there is a key usage extension mismatch.</p></dd><dt class="hdlist1"><code>Bypass identity confirmation</code></dt><dd><p>If set, X.509 client certificate authentication will not prompt the user to confirm the certificate identity and will automatically sign in the user upon successful authentication.</p></dd></dl></div>
<h3>Adding X.509 Client Certificate Authentication to a Direct Grant Flow</h3><div class="ulist"><ul><li><p>Using Red Hat Single Sign-On admin console, click on "Authentication" and select the "Direct Grant" flow,</p></li><li><p>Make a copy of the build-in "Direct Grant" flow. You may want to give the new flow a distinctive name, i.e. "X509 Direct Grant",</p></li><li><p>Delete "Username Validation" and "Password" authenticators,</p></li><li><p>Click on "Add execution" and add "X509/Validate Username" and click on "Save" to add the execution step to the parent flow.</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/x509-directgrant-execution.png" alt="x509 directgrant execution"></span></p></div>
<div class="ulist"><ul><li><p>Change the <code>Requirement</code> to <em>REQUIRED</em>.</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/x509-directgrant-flow.png" alt="x509 directgrant flow"></span></p></div>
<div class="ulist"><ul><li><p>Set up the x509 authentication configuration by following the steps described earlier in the x.509 Browser Flow section.</p></li><li><p>Select the "Bindings" tab, find the drop down for "Direct Grant Flow". Select the newly created X509 direct grant flow from the drop down and click on "Save".</p></li></ul></div>
<div class="paragraph"><p><span class="image"><img src="images/x509-directgrant-flow-bindings.png" alt="x509 directgrant flow bindings"></span></p></div>
<h3>Client certificate lookup</h3><div class="paragraph"><p>When an HTTP request is sent directly to Red Hat Single Sign-On server, the JBoss EAP undertow subsystem will establish an SSL handshake and extract the client certificate. The client certificate will be then saved to the attribute <code>javax.servlet.request.X509Certificate</code> of the HTTP request, as specified in the servlet specification. The Red Hat Single Sign-On X509 authenticator will be then able to lookup the certificate from this attribute.</p></div>
<div class="paragraph"><p>However, when the Red Hat Single Sign-On server listens to HTTP requests behind a load balancer or reverse proxy, it may be the proxy server which extracts the client certificate and establishes the mutual SSL connection. A reverse proxy usually puts the authenticated client certificate in the HTTP header of the underlying request and forwards it to the back end Red Hat Single Sign-On server. In this case, Red Hat Single Sign-On must be able to look up the X.509 certificate chain from the HTTP headers instead of from the attribute of HTTP request, as is done for Undertow.</p></div>
<div class="paragraph"><p>If Red Hat Single Sign-On is behind a reverse proxy, you usually need to configure alternative provider of the <code>x509cert-lookup</code> SPI in RHSSO_HOME/standalone/configuration/standalone.xml. Along with the <code>default</code> provider, which looks up the certificate from the HTTP header, we also have two additional built-in providers: <code>haproxy</code> and <code>apache</code>, which are described next.</p></div>
<h4>HAProxy certificate lookup provider</h4><div class="paragraph"><p>You can use this provider when your Red Hat Single Sign-On server is behind an HAProxy reverse proxy. Configure the server like this:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;spi name="x509cert-lookup"&gt;
    &lt;default-provider&gt;haproxy&lt;/default-provider&gt;
    &lt;provider name="haproxy" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="sslClientCert" value="SSL_CLIENT_CERT"/&gt;
            &lt;property name="sslCertChainPrefix" value="CERT_CHAIN"/&gt;
            &lt;property name="certificateChainLength" value="10"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</code></pre>
<div class="paragraph"><p>In this example configuration, the client certificate will be looked up from the HTTP header, <code>SSL_CLIENT_CERT</code>, and the other certificates from its chain will be looked up from HTTP headers like <code>CERT_CHAIN_0</code> , <code>CERT_CHAIN_1</code>, &#8230;&#8203;, <code>CERT_CHAIN_9</code> . The attribute <code>certificateChainLength</code> is the maximum length of the chain, so the last one tried attribute would be <code>CERT_CHAIN_9</code> .</p></div>
<div class="paragraph"><p>Consult the <a href="http://www.haproxy.org/#docs">HAProxy documentation</a> for the details of how the HTTP Headers for the client certificate and client certificate chain can be configured and their proper names.</p></div>
<h4>Apache certificate lookup provider</h4><div class="paragraph"><p>You can use this provider when your Red Hat Single Sign-On server is behind an Apache reverse proxy. Configure the server like this:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;spi name="x509cert-lookup"&gt;
    &lt;default-provider&gt;apache&lt;/default-provider&gt;
    &lt;provider name="apache" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="sslClientCert" value="SSL_CLIENT_CERT"/&gt;
            &lt;property name="sslCertChainPrefix" value="CERT_CHAIN"/&gt;
            &lt;property name="certificateChainLength" value="10"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</code></pre>
<div class="paragraph"><p>The configuration is same as for the <code>haproxy</code> provider. Consult the Apache documentation on <a href="https://httpd.apache.org/docs/current/mod/mod_ssl.html">mod_ssl</a> and <a href="https://httpd.apache.org/docs/current/mod/mod_headers.html">mod_headers</a> for the details of how the HTTP Headers for the client certificate and client certificate chain can be configured and their proper names.</p></div>
<h4>Nginx certificate lookup provider</h4><div class="paragraph"><p>You can use this provider when your Red Hat Single Sign-On server is behind an Nginx reverse proxy. Configure the server like this:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;spi name="x509cert-lookup"&gt;
    &lt;default-provider&gt;nginx&lt;/default-provider&gt;
    &lt;provider name="nginx" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="sslClientCert" value="ssl-client-cert"/&gt;
            &lt;property name="sslCertChainPrefix" value="USELESS"/&gt;
            &lt;property name="certificateChainLength" value="2"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">NGINX <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#variables">SSL/TLS module</a> does not expose the client certificate chain, so Keycloak NGINX certificate lookup provider is rebuilding it using the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/#_truststore">Keycloak truststore</a>. Please populate Keycloak truststore using keytool CLI with all root and intermediate CA&#8217;s needed for rebuilding client certificate chain.</td></tr></table></div>
<div class="paragraph"><p>Consult the NGINX documentation for the details of how the HTTP Headers for the client certificate can be configured.
Example of NGINX configuration file :</p></div>
<pre class="highlight listingblock"><code class="txt language-txt"> ...
 server {
    ...
    ssl_client_certificate                  trusted-ca-list-for-client-auth.pem;
    ssl_verify_client                       optional_no_ca;
    ssl_verify_depth                        2;
    ...
    location / {
      ...
      proxy_set_header ssl-client-cert        $ssl_client_escaped_cert;
      ...
    }
    ...
}</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">all certificates in trusted-ca-list-for-client-auth.pem must be added to <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/#_truststore">Keycloak truststore</a>.</td></tr></table></div>
<h4>Other reverse proxy implementations</h4><div class="paragraph"><p>We do not have built-in support for other reverse proxy implementations. However, it is possible that other reverse proxies can be made to behave in a similar way to <code>apache</code> or <code>haproxy</code> and that some of those providers can be used. If none of those works, you may need to create your own implementation of the <code>org.keycloak.services.x509.X509ClientCertificateLookupFactory</code> and <code>org.keycloak.services.x509.X509ClientCertificateLookup</code> provider. See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for the details on how to add your own provider.</p></div>
<h3>Troubleshooting</h3><div class="dlist"><dl><dt class="hdlist1">Dumping HTTP headers</dt><dd><p>If you want to view what the reverse proxy is sending to Keycloak, simply activate <a href="https://mirocupak.com/logging-requests-with-undertow/">RequestDumpingHandler</a> and consult <code>server.log</code> file.</p></dd><dt class="hdlist1">Enable TRACE logging under the logging subsystem</dt></dl></div>
<pre class="highlight listingblock"><code class="xml language-xml">...
    &lt;profile&gt;
        &lt;subsystem xmlns="urn:jboss:domain:logging:3.0"&gt;
...
            &lt;logger category="org.keycloak.authentication.authenticators.x509"&gt;
                &lt;level name="TRACE"/&gt;
            &lt;/logger&gt;
            &lt;logger category="org.keycloak.services.x509"&gt;
                &lt;level name="TRACE"/&gt;
            &lt;/logger&gt;</code></pre>
<div class="literalblock"><div class="content"><pre>WARNING: Don't use RequestDumpingHandler or TRACE logging in production.</pre></div></div>
<div class="dlist"><dl><dt class="hdlist1">Direct Grant authentication with X.509</dt><dd><p>The following template can be used to request a token using the Resource Owner Password Credentials Grant:</p></dd></dl></div>
<pre class="highlight listingblock"><code>$ curl https://[host][:port]/auth/realms/master/protocol/openid-connect/token \
       --insecure \
       --data "grant_type=password&amp;scope=openid profile&amp;username=&amp;password=&amp;client_id=CLIENT_ID&amp;client_secret=CLIENT_SECRET" \
       -E /path/to/client_cert.crt \
       --key /path/to/client_cert.key</code></pre>
<div class="dlist"><dl><dt class="hdlist1"><code>[host][:port]</code></dt><dd><p>The host and the port number of a remote Red Hat Single Sign-On server that has been configured to allow users authenticate with x.509 client certificates using the Direct Grant Flow.</p></dd><dt class="hdlist1"><code>CLIENT_ID</code></dt><dd><p>A client id.</p></dd><dt class="hdlist1"><code>CLIENT_SECRET</code></dt><dd><p>For confidential clients, a client secret; otherwise, leave it empty.</p></dd><dt class="hdlist1"><code>client_cert.crt</code></dt><dd><p>A public key certificate that will be used to verify the identity of the client in mutual SSL authentication. The certificate should be in PEM format.</p></dd><dt class="hdlist1"><code>client_cert.key</code></dt><dd><p>A private key in the public key pair. Also expected in PEM format.</p></dd></dl></div></section><section id="_webauthn"><h2>W3C Web Authentication (WebAuthn)</h2><div class="paragraph"><p>Red Hat Single Sign-On provides the limited support for <a href="https://www.w3.org/TR/webauthn/">W3C Web Authentication (WebAuthn)</a>. Red Hat Single Sign-On works as WebAuthn&#8217;s <a href="https://www.w3.org/TR/webauthn/#rp-operations">Relying Party (RP)</a>.</p></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">Please note that WebAuthn support is still in development and not yet complete, so we recommend that you use this feature experimentally. Also, this support&#8217;s specification and user interfaces may change.</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Whether WebAuthn&#8217;s operations succeed depends on a user&#8217;s WebAuthn supporting authenticator, browser and platform. If you use this WebAuthn support, please clarify to what extent those entities support the WebAuthn specification.</td></tr></table></div>
<div class="paragraph"><p>The major restriction is as follows :</p></div>
<div class="ulist"><ul><li><p>A user can register only one WebAuthn supporting Authenticator (called WebAuthn authenticator here).</p></li><li><p>On registering the WebAuthn authenticator, its <a href="https://www.w3.org/TR/webauthn/#attestation-statement">Attestation Statement</a> is not verified.</p></li><li><p>Only the Two-Factor Authentication (2FA) scenario is supported.</p></li></ul></div>
<h3>Setup</h3><div class="paragraph"><p>The setup procedure of WebAuthn support for 2FA is the following :</p></div>
<div class="dlist"><dl><dt class="hdlist1">Enable User Registration</dt><dd><p>An administrator carries out the following operations on the <code>Admin Console</code> :</p><div class="ulist"><ul><li><p>Open the <code>Realm Settings &#8594; Login</code> tab.</p></li><li><p>Set the <code>User Registration</code> to ON and click <code>Save</code>.</p></li></ul></div></dd><dt class="hdlist1">Enable Webauthn Authenticator Registration</dt><dd><p>An administrator carries out the following operations on the <code>Admin Console</code> :</p><div class="ulist"><ul><li><p>Open the <code>Authentication &#8594; Required Actions</code> tab.</p></li><li><p>Click <code>Register</code>.</p></li><li><p>Select <code>Webauthn Register</code> as <code>Required Action</code>.</p></li><li><p>Mark <code>Enabled</code> and <code>Default Action</code> checkbox.</p></li></ul></div></dd><dt class="hdlist1">Enable 2FA by Webauthn Authenticator</dt><dd><p>An administrator carries out the following operations on the <code>Admin Console</code> :</p><div class="ulist"><ul><li><p>Open the <code>Authentication &#8594; Flows</code> tab.</p></li><li><p>Copy and create the new browser flow.</p></li><li><p>Add the <code>WebAuthn Authenticator</code> execution below the <code>User Password Form</code> execution.</p></li><li><p>Set <code>REQUIRED</code> to the <code>WebAuthn Authenticator</code> execution&#8217;s requirement.</p></li><li><p>Open the <code>Authentication &#8594; Bindings</code> tab.</p></li><li><p>Select the created new browser flow as <code>Browser Flow</code>.</p></li><li><p>Click <code>Save</code>.</p></li></ul></div></dd></dl></div>
<h3>Register WebAuthn Authenticator</h3><div class="paragraph"><p>The appropriate method to register a WebAuthen authenticator depends on if the user has or has not already registered an account on Red Hat Single Sign-On.</p></div>
<div class="dlist"><dl><dt class="hdlist1">User without their account</dt><dd><p>A user carries out the following operations :</p><div class="ulist"><ul><li><p>Open the login form.</p></li><li><p>Click the <code>Register</code> link.</p></li><li><p>Fill in items on the register form and click <code>Register</code>.</p></li><li><p>The user&#8217;s browser asks the user to register their WebAuthn authenticator.</p></li><li><p>After successful registration, the user&#8217;s browser asks the user to enter the text as their just registered WebAuthn authenticator&#8217;s label.</p></li></ul></div></dd><dt class="hdlist1">User with their account</dt><dd><p>When such the users try to log in, they are required to register their WebAuthn authenticator automatically :</p><div class="ulist"><ul><li><p>Open the login form.</p></li><li><p>Fill in items, click <code>Save</code> and  click <code>Login</code>.</p></li><li><p>When the users log in, they are required to register their WebAuthn authenticator.</p></li><li><p>After successful registration, the user&#8217;s browser asks the user to enter the text as their just registered WebAuthn authenticator&#8217;s label.</p></li></ul></div></dd></dl></div>
<h3>Authenticate by WebAuthn Authenticator</h3><div class="paragraph"><p>After registering their WebAuthn authenticator, the user carries out the following operations :</p></div>
<div class="ulist"><ul><li><p>Open the login form.</p></li><li><p>Fill in items, click <code>Save</code> and  click <code>Login</code>.</p></li><li><p>The list of registered Webauthn Authenticators' labels appears. Click <code>Authenticate</code>.</p></li><li><p>The user&#8217;s browser asks the user to authenticate by their WebAuthn authenticator.</p></li></ul></div>
<h3>View Registered WebAuthn Authenticator</h3><div class="paragraph"><p>An administrator and a user can view the following information :</p></div>
<div class="ulist"><ul><li><p><a href="https://www.w3.org/TR/webauthn/#credential-id">Credential ID</a></p></li><li><p>Label (WebAuthn authenticator&#8217;s label the user entered on registering it)</p></li><li><p><a href="https://fidoalliance.org/specs/fido-v2.0-rd-20180702/fido-metadata-statement-v2.0-rd-20180702.html#authenticator-attestation-guid-aaguid-typedef">AAGUID</a></p></li></ul></div>
<div class="paragraph"><p>An administrator carries out the following operations on the <code>Admin Console</code> :</p></div>
<div class="ulist"><ul><li><p>Open the <code>Users &#8594; (user) &#8594; Credentials</code> tab.</p></li><li><p>View the <code>Manage WebAuthn Authenticator</code> area.</p></li></ul></div>
<div class="paragraph"><p>A user carries out the following operations on the <a href="#_account-service"><code>User Account Service</code></a>  :</p></div>
<div class="ulist"><ul><li><p>View the <code>Account</code> page.</p></li></ul></div>
<h3>Edit Registered WebAuthn Authenticator</h3><div class="paragraph"><p>A user can edit the following information :</p></div>
<div class="ulist"><ul><li><p>Label (WebAuthn authenticator&#8217;s label the user entered on registering it)</p></li></ul></div>
<div class="paragraph"><p>A user carries out the following operations on the <a href="#_account-service"><code>User Account Service</code></a>  :</p></div>
<div class="ulist"><ul><li><p>View the <code>Account</code> page.</p></li><li><p>Edit the text in <code>Public Key Credential Label</code>.</p></li><li><p>Click <code>Save</code>.</p></li></ul></div>
<h3>Delete Registered WebAuthn Authenticator</h3><div class="paragraph"><p>An administrator can delete the users' registered WebAuthn authenticators.</p></div>
<div class="paragraph"><p>An Administrator carries out the following operations on the <code>Admin Console</code> :</p></div>
<div class="ulist"><ul><li><p>Open the <code>Users &#8594; (user) &#8594; Credentials</code> tab.</p></li><li><p>On the <code>Disable Credentials</code> area, add <code>webauthn</code> to <code>Disable Types</code>.</p></li><li><p>Click <code>Disable Credential Types</code>.</p></li></ul></div>
<h3>Re-Register WebAuthn Authenticator</h3><div class="paragraph"><p>A user can re-register their WebAuthn authenticator. Newly registered WebAuthn authenticator overrides the old registered one.</p></div>
<div class="paragraph"><p>At first, an administrator carries out the following operations on the <code>Admin Console</code> to require the user to register their WebAuthn authenticator after their login :</p></div>
<div class="ulist"><ul><li><p>Open the <code>Users &#8594; (user) &#8594; Details</code> tab.</p></li><li><p>Set <code>WebAuthn Register</code> on <code>Required User Actions</code>.</p></li><li><p>Click <code>Save</code>.</p></li></ul></div>
<div class="paragraph"><p>After that, the user carries out the following operations :</p></div>
<div class="ulist"><ul><li><p>Open the login form.</p></li><li><p>Fill in items, click <code>Save</code> and  click <code>Login</code>.</p></li><li><p>When the users log in, they are required to register their WebAuthn authenticator.</p></li><li><p>After successful registration, the user&#8217;s browser asks the user to enter the text as their just registered WebAuthn authenticator&#8217;s label.</p></li></ul></div>
<h3>Configuration</h3><div class="paragraph"><p>An administrator can configure WebAuthn related operations as <code>WebAuthn Policy</code> per realm.</p></div>
<div class="paragraph"><p>An administrator carries out the following operations on the <code>Admin Console</code> :</p></div>
<div class="ulist"><ul><li><p>Open the <code>Authentication &#8594; WebAuthn Policy</code> tab.</p></li><li><p>Configure items and click <code>Save</code>.</p></li></ul></div>
<div class="paragraph"><p>The configurable items and their description follow.</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Configuration</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Relying Party Entity Name</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Human-readable server name as WebAuthn Relying Party. This is a mandatory configuration, which is applied to the operation of registering the WebAuthn authenticator. The default setting is "keycloak".
 For more details, see <a href="https://www.w3.org/TR/webauthn/#dictionary-pkcredentialentity">WebAuthn Specification</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Signature Algorithms</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">It tells the WebAuthn authenticator which signature algorithms to use for the <a href="https://www.w3.org/TR/webauthn/#public-key-credential">Public Key Credential</a> that can be used for signing and verifying the <a href="https://www.w3.org/TR/webauthn/#authentication-assertion">Authentication Assertion</a>. Multiple algorithms can be specified. If no algorithm is specified, <a href="https://tools.ietf.org/html/rfc8152#section-8.1">ES256</a> is adapted. The default setting is ES256. This is an optional configuration item that is applied to the operation of registering WebAuthn authenticator.
 For more details, see <a href="https://www.w3.org/TR/webauthn/#dictdef-publickeycredentialparameters">WebAuthn Specification</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Relying Party ID</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This is the ID as WebAuthn Relying Party and determines the scope of Public Key Credentials. It must be origin&#8217;s effective domain. This is an optional configuration item that is applied to the operation of registering WebAuthn authenticator. If no entry is entered, the host part of the base URL of Red Hat Single Sign-On&#8217;s server is adapted.
 For more details, see <a href="https://www.w3.org/TR/webauthn/#rp-id">WebAuthn Specification</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Attestation Conveyance Preference</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">It tells the WebAuthn API implementation on the browser (<a href="https://www.w3.org/TR/webauthn/#webauthn-client">WebAuthn Client</a>) the preference of how to generate an Attestation Statement. However, Red Hat Single Sign-On does not verify the Attestation Statement so that only "none" option can be selected. This is an optional configuration item that is applied to the operation of registering WebAuthn authenticator. If no option is selected, its behavior is the same as selecting "none".
 For more details, see <a href="https://www.w3.org/TR/webauthn/#attestation-convey">WebAuthn Specification</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Authenticator Attachment</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">It tells the WebAuthn Client an acceptable attachment pattern of a WebAuthn authenticator. This is an optional configuration item that is applied to the operation of registering WebAuthn authenticator. If no option is selected, the WebAuthn Client does not consider the attachment pattern.
 For more details, see <a href="https://www.w3.org/TR/webauthn/#enumdef-authenticatorattachment">WebAuthn Specification</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Require Resident Key</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">It tells the WebAuthn authenticator to generate the Public Key Credential as <a href="https://www.w3.org/TR/webauthn/#client-side-resident-public-key-credential-source">Client-side-resident Public Key Credential Source</a>. This is an optional configuration item that is applied to the operation of registering WebAuthn authenticator. If no option is selected, its behavior is the same as selecting "No".
 For more details, see <a href="https://www.w3.org/TR/webauthn/#dom-authenticatorselectioncriteria-requireresidentkey">WebAuthn Specification</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">User Verification Requirement</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">It tells the WebAuthn authenticator to confirm actually verifying a user. This is an optional configuration item that is applied to the operation of registering WebAuthn authenticator and authenticating the user by WebAuthn authenticator. If no option is selected, its behavior is the same as selecting "preferred".
 For more details, see <a href="https://www.w3.org/TR/webauthn/#dom-authenticatorselectioncriteria-userverification">WebAuthn Specification for registering WebAuthn authenticator</a> and <a href="https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-userverification">WebAuthn Specification for authenticating the user by WebAuthn authenticator</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Timeout</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">It specifies the timeout value in seconds for registering WebAuthn authenticator and authenticating the user by WebAuthn authenticator. If set to 0, its behavior depends on the WebAuthn authenticator&#8217;s implementation. The default value is 0.
 For more details, see <a href="https://www.w3.org/TR/webauthn/#dom-publickeycredentialcreationoptions-timeout">WebAuthn Specification for registering WebAuthn authenticator</a> and <a href="https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-timeout">WebAuthn Specification for authenticating the user by WebAuthn authenticator</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Avoid Same Authenticator Registration</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If set to "ON", the WebAuthn authenticator that has already been registered can not be newly registered. This is applied to the operation of registering WebAuthn authenticator. The default setting is "OFF".</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Acceptable AAGUIDs</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The white list of AAGUID of which a WebAuthn authenticator can be registered. This is applied to the operation of registering WebAuthn authenticator. If no entry is set on this list, any WebAuthn authenticator can be registered.</p></td></tr></table></section></section>
<section><section id="_sso_protocols"><h2>SSO Protocols</h2><div class="paragraph"><p>The chapter gives a brief overview of the authentication protocols and how the Red Hat Single Sign-On authentication server
and the applications it secures interact with these protocols.</p></div></section><section id="_oidc"><h2>OpenID Connect</h2><div class="paragraph"><p><a href="https://openid.net/connect/">OpenID Connect</a> (OIDC) is an authentication protocol that is an extension of <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0</a>.
While OAuth 2.0 is only a framework for building authorization protocols and is mainly incomplete, OIDC is a full-fledged authentication and authorization
protocol.  OIDC also makes heavy use of the <a href="https://jwt.io">Json Web Token</a> (JWT) set of standards.  These standards define an
identity token JSON format and ways to digitally sign and encrypt that data in a compact and web-friendly way.</p></div>
<div class="paragraph"><p>There are really two types of use cases when using OIDC.  The first is an application that asks the Red Hat Single Sign-On server to authenticate
a user for them.  After a successful login, the application will receive an <em>identity token</em> and an <em>access token</em>.  The <em>identity token</em>
contains information about the user such as username, email, and other profile information.  The <em>access token</em> is digitally signed by
the realm and contains access information (like user role mappings) that the application can use to determine what resources the user
is allowed to access on the application.</p></div>
<div class="paragraph"><p>The second type of use cases is that of a client that wants to gain access to remote services.  In this case, the client asks Red Hat Single Sign-On
to obtain an <em>access token</em> it can use to invoke on other remote services on behalf of the user.  Red Hat Single Sign-On authenticates the user
then asks the user for consent to grant access to the client requesting it.  The client then receives the <em>access token</em>.  This <em>access token</em>
is digitally signed by the realm.  The client can make REST invocations on remote services using this <em>access token</em>.  The REST service
extracts the <em>access token</em>, verifies the signature of the token, then decides based on access information within the token whether or not to process
the request.</p></div>
<h3>OIDC Auth Flows</h3><div class="paragraph"><p>OIDC has different ways for a client or application to authenticate a user and receive an <em>identity</em> and <em>access</em> token.  Which
path you use depends greatly on the type of application or client requesting access.  All of these flows are described in the
OIDC and OAuth 2.0 specifications so only a brief overview will be provided here.</p></div>
<h4>Authorization Code Flow</h4><div class="paragraph"><p>This is a browser-based protocol and it is what we recommend you use to authenticate and authorize browser-based applications.  It makes
heavy use of browser redirects to obtain an <em>identity</em> and <em>access</em> token.  Here&#8217;s a brief summary:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Browser visits application.  The application notices the user is not logged in, so it redirects the browser to Red Hat Single Sign-On
to be authenticated.  The application passes along a callback URL (a redirect URL) as a query parameter in this browser redirect
that Red Hat Single Sign-On will use when it finishes authentication.</p></li><li><p>Red Hat Single Sign-On authenticates the user and creates a one-time, very short lived, temporary code.  Red Hat Single Sign-On
redirects back to the application using the callback URL provided earlier and additionally adds the temporary code
as a query parameter in the callback URL.</p></li><li><p>The application extracts the temporary code and makes a background out of band REST invocation to Red Hat Single Sign-On
to exchange the code for an <em>identity</em>, <em>access</em> and <em>refresh</em> token.  Once this temporary code has been used once
to obtain the tokens, it can never be used again.  This prevents potential replay attacks.</p></li></ol></div>
<div class="paragraph"><p>It is important to note that <em>access</em> tokens are usually short lived and often expired after only minutes.  The additional <em>refresh</em>
token that was transmitted by the login protocol allows the application to obtain a new access token after it expires.  This
refresh protocol is important in the situation of a compromised system.  If access tokens are short lived, the whole system is only
vulnerable to a stolen token for the lifetime of the access token.  Future refresh token requests will fail if an admin
has revoked access.  This makes things more secure and more scalable.</p></div>
<div class="paragraph" id="_confidential-clients"><p>Another important aspect of this flow is the concept of a <em>public</em> vs. a <em>confidential</em> client.  <em>Confidential</em> clients are required
to provide a client secret when they exchange the temporary codes for tokens.  <em>Public</em> clients are not required to provide this client secret.
<em>Public</em> clients are perfectly fine so long as HTTPS is strictly enforced and you are very strict about what redirect URIs are registered for the
client.  HTML5/JavaScript clients always have to be <em>public</em> clients because there is no way to transmit the client secret to them in a secure
manner.  Again, this is ok so long as you use HTTPS and strictly enforce redirect URI registration.  This guide goes more detail
into this in the <a href="#_clients">Managing Clients</a> chapter.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On also supports the optional <a href="https://tools.ietf.org/html/rfc7636">Proof Key for Code Exchange</a> specification.</p></div>
<h4>Implicit Flow</h4><div class="paragraph"><p>This is a browser-based protocol that is similar to Authorization Code Flow except there are fewer requests and no refresh tokens involved.
We do not recommend this flow as there remains the possibility of <em>access</em> tokens being leaked in the browser history as tokens are transmitted
via redirect URIs (see below).  Also, since this flow doesn&#8217;t provide the client with a refresh token, access tokens would either have to
be long-lived or users would have to re-authenticate when they expired.  This flow is supported because it is in the OIDC and OAuth 2.0 specification.
Here&#8217;s a brief summary of the protocol:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Browser visits application.  The application notices the user is not logged in, so it redirects the browser to Red Hat Single Sign-On
to be authenticated.  The application passes along a callback URL (a redirect URL) as a query parameter in this browser redirect
that Red Hat Single Sign-On will use when it finishes authentication.</p></li><li><p>Red Hat Single Sign-On authenticates the user and creates an <em>identity</em> and <em>access</em> token.  Red Hat Single Sign-On
redirects back to the application using the callback URL provided earlier and additionally adding the <em>identity</em> and
<em>access</em> tokens as query parameters in the callback URL.</p></li><li><p>The application extracts the <em>identity</em> and <em>access</em> tokens from the callback URL.</p></li></ol></div>
<h4>Resource Owner Password Credentials Grant (Direct Access Grants)</h4><div class="paragraph"><p>This is referred to in the Admin Console as <em>Direct Access Grants</em>. This is used by REST clients that want to obtain a token on behalf of a user.  It is one HTTP POST request that contains
the credentials of the user as well as the id of the client and the client&#8217;s secret (if it is a confidential client).  The user&#8217;s credentials
are sent within form parameters.  The HTTP response contains
<em>identity</em>, <em>access</em>, and <em>refresh</em> tokens.</p></div>
<h4>Client Credentials Grant</h4><div class="paragraph"><p>This is also used by REST clients, but instead of obtaining a token that works on behalf
of an external user, a token is created based on the metadata and permissions of a service account that is associated with the client.
More info together with example is in <a href="#_service_accounts">Service Accounts</a> chapter.</p></div>
<h3>Red Hat Single Sign-On Server OIDC URI Endpoints</h3><div class="paragraph"><p>Here&#8217;s a list of OIDC endpoints that the Red Hat Single Sign-On publishes.  These URLs are useful if you are using a non-Red Hat Single Sign-On client adapter to
talk OIDC with the auth server.  These are all relative URLs and the root of the URL being the HTTP(S) protocol, hostname, and usually path prefixed with
<em>/auth</em>:  i.e. https://localhost:8080/auth</p></div>
<div class="dlist"><dl><dt class="hdlist1">/realms/{realm-name}/protocol/openid-connect/token</dt><dd><p>This is the URL endpoint for obtaining a temporary code in the Authorization Code Flow or for obtaining tokens via the
Implicit Flow, Direct Grants, or Client Grants.</p></dd><dt class="hdlist1">/realms/{realm-name}/protocol/openid-connect/auth</dt><dd><p>This is the URL endpoint for the Authorization Code Flow to turn a temporary code into a token.</p></dd><dt class="hdlist1">/realms/{realm-name}/protocol/openid-connect/logout</dt><dd><p>This is the URL endpoint for performing logouts.</p></dd><dt class="hdlist1">/realms/{realm-name}/protocol/openid-connect/userinfo</dt><dd><p>This is the URL endpoint for the User Info service described in the OIDC specification.</p></dd></dl></div>
<div class="paragraph"><p>In all of these replace <em>{realm-name}</em> with the name of the realm.</p></div></section><section id="_saml"><h2>SAML</h2><div class="paragraph"><p><a href="http://saml.xml.org/saml-specifications">SAML 2.0</a> is a similar specification to OIDC but a lot older and more mature.  It has its roots in SOAP and the plethora
of WS-* specifications so it tends to be a bit more verbose than OIDC.  SAML 2.0 is primarily an authentication protocol
that works by exchanging XML documents between the authentication server and the application.  XML signatures and encryption
is used to verify requests and responses.</p></div>
<div class="paragraph"><p>There are really two types of use cases when using SAML.  The first is an application that asks the Red Hat Single Sign-On server to authenticate
a user for them.  After a successful login, the application will receive an XML document that contains
something called a SAML assertion that specify various attributes about the user.  This XML document is digitally signed by
the realm and contains access information (like user role mappings) that the application can use to determine what resources the user
is allowed to access on the application.</p></div>
<div class="paragraph"><p>The second type of use cases is that of a client that wants to gain access to remote services.  In this case, the client asks Red Hat Single Sign-On
to obtain an SAML assertion it can use to invoke on other remote services on behalf of the user.</p></div>
<h3>SAML Bindings</h3><div class="paragraph"><p>SAML defines a few different ways to exchange XML documents when executing the authentication protocol.  The <em>Redirect</em> and <em>Post</em> bindings
cover browser based applications.  The <em>ECP</em> binding covers REST invocations.  There are other binding types but Red Hat Single Sign-On only
supports those three.</p></div>
<h4>Redirect Binding</h4><div class="paragraph"><p>The <em>Redirect</em> Binding uses a series of browser redirect URIs to exchange information.  This is a rough overview of
how it works.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>The user visits the application and the application finds the user is not authenticated.  It generates an XML authentication
request document and encodes it as a query param in a URI that is used to redirect to the Red Hat Single Sign-On server.
Depending on your settings, the application may also digitally sign this XML document and also stuff this signature as a query
param in the redirect URI to Red Hat Single Sign-On.  This signature is used to validate the client that sent this
request.</p></li><li><p>The browser is redirected to Red Hat Single Sign-On.  The server extracts the XML auth request document and verifies
the digital signature if required.  The user then has to enter in their credentials to be authenticated.</p></li><li><p>After authentication, the server generates an XML authentication response document.  This document contains
a SAML assertion that holds metadata about the user like name, address, email, and any role mappings the user
might have.  This document is almost always digitally signed using XML signatures, and may also be encrypted.</p></li><li><p>The XML auth response document is then encoded as a query param in a redirect URI that brings the browser back
to the application.  The digital signature is also included as a query param.</p></li><li><p>The application receives the redirect URI and extracts the XML document and verifies the realm&#8217;s signature to make
sure it is receiving a valid auth response.  The information inside the SAML assertion is then used to make
access decisions or display user data.</p></li></ol></div>
<h4>POST Binding</h4><div class="paragraph"><p>The SAML <em>POST</em> binding works almost the exact same way as the <em>Redirect</em> binding, but instead of GET requests, XML
documents are exchanged by POST requests.  The <em>POST</em> Binding uses JavaScript to trick the browser into making a POST request to
the Red Hat Single Sign-On server or application when exchanging documents.  Basically HTTP responses contain an HTML document
that contains an HTML form with embedded JavaScript.  When the page is loaded, the JavaScript automatically invokes the form.
You really don&#8217;t need to know about this stuff, but it is a pretty clever trick.</p></div>
<div class="paragraph"><p><em>POST</em> binding is usually recommended because of security and size restrictions. When using <em>REDIRECT</em> the SAML response
is part of the URL (it is a query parameter as it was explained before), so it can be captured in logs and it is considered
less secure. Regarding size, if the assertion contains a lot or large attributes sending the document inside the HTTP payload
is always better than in the more limited URL.</p></div>
<h4>ECP</h4><div class="paragraph"><p>ECP stands for "Enhanced Client or Proxy", a SAML v.2.0 profile which allows for the exchange of SAML attributes outside the context of a web browser.
This is used most often for REST or SOAP-based clients.</p></div>
<h3>Red Hat Single Sign-On Server SAML URI Endpoints</h3><div class="paragraph"><p>Red Hat Single Sign-On really only has one endpoint for all SAML requests.</p></div>
<div class="paragraph"><p><code>http(s)://authserver.host/auth/realms/{realm-name}/protocol/saml</code></p></div>
<div class="paragraph"><p>All bindings use this endpoint.</p></div></section><section id="_openid_connect_vs_saml"><h2>OpenID Connect vs. SAML</h2><div class="paragraph"><p>Choosing between OpenID Connect and SAML is not just a matter of using a newer protocol (OIDC) instead of the older more mature protocol (SAML).</p></div>
<div class="paragraph"><p>In most cases Red Hat Single Sign-On recommends using OIDC.</p></div>
<div class="paragraph"><p>SAML tends to be a bit more verbose than OIDC.</p></div>
<div class="paragraph"><p>Beyond verbosity of exchanged data, if you compare the specifications you&#8217;ll find that OIDC was designed to work with the web while SAML was retrofitted to work on top of the web.  For example, OIDC is also more suited for HTML5/JavaScript applications because it is
easier to implement on the client side than SAML. As tokens are in the JSON format,
they are easier to consume by JavaScript. You will also find several nice features that
make implementing security in your web applications easier. For example, check out the <a href="https://openid.net/specs/openid-connect-session-1_0.html#ChangeNotification">iframe trick</a> that the specification uses to easily determine if a user is still logged in or not.</p></div>
<div class="paragraph"><p>SAML has its uses though. As you see the OIDC specifications evolve you see they implement more and more features that SAML has had for years. What we often see is that people pick SAML over OIDC because of the perception that it is more mature and also because they already have existing applications that are secured with it.</p></div></section><section id="_docker"><h2>Docker Registry v2 Authentication</h2><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Docker authentication is disabled by default. To enable see <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.</td></tr></table></div>
<div class="paragraph"><p><a href="https://docs.docker.com/registry/spec/auth/">Docker Registry V2 Authentication</a> is an OIDC-Like protocol used to authenticate users against a Docker registry.  Red Hat Single Sign-On&#8217;s implementation of this protocol allows for a Red Hat Single Sign-On authentication server to be used by a Docker client to authenticate against a registry.  While this protocol uses fairly standard token and signature mechanisms, it has a few wrinkles that prevent it from being treated as a true OIDC implementation.  The largest deviations include a very specific JSON format for requests and responses as well as the ability to understand how to map repository names and permissions to the OAuth scope mechanism.</p></div>
<h3>Docker Auth Flow</h3><div class="paragraph"><p>The <a href="https://docs.docker.com/registry/spec/auth/token/">Docker API documentation</a> best describes and illustrates this process, however a brief summary will be given below from the perspective of the Red Hat Single Sign-On authentication server.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">This flow assumes that a <code>docker login</code> command has already been performed</td></tr></table></div>
<div class="ulist"><ul><li><p>The flow begins when the Docker client requests a resource from the Docker registry.  If the resource is protected and no auth token is present in the request, the Docker registry server will respond to the client with a 401 + some information on required permissions and where to find the authorization server.</p></li><li><p>The Docker client will construct an authentication request based on the 401 response from the Docker registry.  The client will then use the locally cached credentials (from a previously run <code>docker login</code> command) as part of a <a href="https://tools.ietf.org/html/rfc2617">HTTP Basic Authentication</a> request to the Red Hat Single Sign-On authentication server.</p></li><li><p>The Red Hat Single Sign-On authentication server will attempt to authenticate the user and return a JSON body containing an OAuth-style Bearer token.</p></li><li><p>The Docker client will get the bearer token from the JSON response and use it in the Authorization header to request the protected resource.</p></li><li><p>When the Docker registry receives the new request for the protected resource with the token from the Red Hat Single Sign-On server, the registry validates the token and grants access to the requested resource (if appropriate).</p></li></ul></div>
<h3>Red Hat Single Sign-On Docker Registry v2 Authentication Server URI Endpoints</h3><div class="paragraph"><p>Red Hat Single Sign-On really only has one endpoint for all Docker auth v2 requests.</p></div>
<div class="paragraph"><p><code>http(s)://authserver.host/auth/realms/{realm-name}/protocol/docker-v2</code></p></div></section></section>
<section><section id="_clients"><h2>Managing Clients</h2><div class="paragraph"><p>Clients are entities that can request authentication of a user.  Clients come in two forms.
The first type of client is an application that wants
to participate in single-sign-on.  These clients just want Red Hat Single Sign-On to provide security for them.  The other type
of client is one that is requesting an access token so that it can invoke other services on behalf of the authenticated user.
This section discusses various aspects around configuring clients and various ways to do it.</p></div></section><section id="_oidc_clients"><h2>OIDC Clients</h2><div class="paragraph"><p><a href="#_oidc">OpenID Connect</a> is the preferred protocol to secure applications.  It was designed from the ground up to be web friendly
and work best with HTML5/JavaScript applications.</p></div>
<div class="paragraph"><p>To create an OIDC client go to the <code>Clients</code> left menu item.  On this page you&#8217;ll see a <code>Create</code> button on the right.</p></div>
<div class="paragraph"><div class="title">Clients</div><p><span class="image"><img src="rhsso-images/clients.png" alt="clients"></span></p></div>
<div class="paragraph"><p>This will bring you to the <code>Add Client</code> page.</p></div>
<div class="paragraph"><div class="title">Add Client</div><p><span class="image"><img src="rhsso-images/add-client-oidc.png" alt="add client oidc"></span></p></div>
<div class="paragraph"><p>Enter in the <code>Client ID</code> of the client.  This should be a simple
alpha-numeric string that will be used in requests and in the Red Hat Single Sign-On database to identify the client.
Next select <code>openid-connect</code> in the <code>Client Protocol</code> drop down box.
Finally enter in the base URL of your
application in the <code>Root URL</code> field and click <code>Save</code>.  This will create the client and bring you to the client <code>Settings</code>
tab.</p></div>
<div class="paragraph"><div class="title">Client Settings</div><p><span class="image"><img src="rhsso-images/client-settings-oidc.png" alt="client settings oidc"></span></p></div>
<div class="paragraph"><p>Let&#8217;s walk through each configuration item on this page.</p></div>
<div class="paragraph"><p><strong>Client ID</strong></p></div>
<div class="paragraph"><p>This specifies an alpha-numeric string that will be used as the client identifier for OIDC requests.</p></div>
<div class="paragraph"><p><strong>Name</strong></p></div>
<div class="paragraph"><p>This is the display name for the client whenever it is displayed in a Red Hat Single Sign-On UI screen.  You can localize
the value of this field by setting up a replacement string value i.e. ${myapp}.  See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a>
for more information.</p></div>
<div class="paragraph"><p><strong>Description</strong></p></div>
<div class="paragraph"><p>This specifies the description of the client.  This can also be localized.</p></div>
<div class="paragraph"><p><strong>Enabled</strong></p></div>
<div class="paragraph"><p>If this is turned off, the client will not be allowed to request authentication.</p></div>
<div class="paragraph"><p><strong>Consent Required</strong></p></div>
<div class="paragraph"><p>If this is on, then users will get a consent page which asks the user if they grant access to that application.  It will also
display the metadata that the client is interested in so that the user knows exactly what information the client is getting access to.
If you&#8217;ve ever done a social login to Google, you&#8217;ll often see a similar page.  Red Hat Single Sign-On provides the same functionality.</p></div>
<div class="paragraph" id="_access-type"><p><strong>Access Type</strong></p></div>
<div class="paragraph"><p>This defines the type of the OIDC client.</p></div>
<div class="dlist"><dl><dt class="hdlist1"><em>confidential</em></dt><dd><p>Confidential access type is for server-side clients that need to perform a browser login and require a client secret when they turn an access code into an access token,
(see <a href="https://tools.ietf.org/html/rfc6749#section-4.1.3">Access Token Request</a> in the OAuth 2.0 spec for more details). This type should be used for server-side applications.</p></dd><dt class="hdlist1"><em>public</em></dt><dd><p>Public access type is for client-side clients that need to perform a browser login. With a client-side application there is no way to keep a secret safe. Instead it is very important to restrict  access by configuring correct redirect URIs for the client.</p></dd><dt class="hdlist1"><em>bearer-only</em></dt><dd><p>Bearer-only access type means that the application only allows bearer token requests.
If this is turned on, this application cannot participate in browser logins.</p></dd></dl></div>
<div class="paragraph"><p><strong>Root URL</strong></p></div>
<div class="paragraph"><p>If Red Hat Single Sign-On uses any configured relative URLs, this value is prepended to them.</p></div>
<div class="paragraph"><p><strong>Valid Redirect URIs</strong></p></div>
<div class="paragraph"><p>This is a required field.  Enter in a URL pattern and click the + sign to add.  Click the - sign next to URLs you want to remove.
Remember that you still have to click the <code>Save</code> button!
Wildcards (*) are only allowed at the end of a URI, i.e. http://host.com/*</p></div>
<div class="paragraph"><p>You should take extra precautions when registering valid redirect URI patterns. If you make
them too general you are vulnerable to attacks.  See <a href="#_unspecific-redirect-uris">Threat Model Mitigation</a> chapter
for more information.</p></div>
<div class="paragraph"><p><strong>Base URL</strong></p></div>
<div class="paragraph"><p>If Red Hat Single Sign-On needs to link to the client, this URL is used.</p></div>
<div class="paragraph"><p><strong>Standard Flow Enabled</strong></p></div>
<div class="paragraph"><p>If this is on, clients are allowed to use the OIDC <a href="#_oidc-auth-flows">Authorization Code Flow</a>.</p></div>
<div class="paragraph"><p><strong>Implicit Flow Enabled</strong></p></div>
<div class="paragraph"><p>If this is on, clients are allowed to use the OIDC <a href="#_oidc-auth-flows">Implicit Flow</a>.</p></div>
<div class="paragraph"><p><strong>Direct Access Grants Enabled</strong></p></div>
<div class="paragraph"><p>If this is on, clients are allowed to use the OIDC <a href="#_oidc-auth-flows">Direct Access Grants</a>.</p></div>
<div class="paragraph"><p><strong>Admin URL</strong></p></div>
<div class="paragraph"><p>For Red Hat Single Sign-On specific client adapters, this is the callback endpoint for the client.  The Red Hat Single Sign-On
server will use this URI to make callbacks like pushing revocation policies, performing backchannel logout, and other
administrative operations.  For Red Hat Single Sign-On servlet adapters, this can be the root URL of the servlet application.
For more information see <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a>.</p></div>
<div class="paragraph"><p><strong>Web Origins</strong></p></div>
<div class="paragraph"><p>This option centers around <a href="http://www.w3.org/TR/cors/">CORS</a> which stands for Cross-Origin Resource Sharing.
If browser JavaScript tries to make an AJAX HTTP request to a server whose domain is different from the one the
JavaScript code came from, then the request must use CORS.
The server must handle CORS requests in a special way, otherwise the browser will not display or allow the request to be processed.
This protocol exists to protect against XSS, CSRF and other JavaScript-based attacks.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On has support for validated CORS requests.  The way it works is that the domains listed in the
<code>Web Origins</code> setting for the client are embedded within the access token sent to the client application.  The client
application can then use this information to decide whether or not to allow a CORS request to be invoked on it.  This is
an extension to the OIDC protocol so only Red Hat Single Sign-On client adapters support this feature.
See <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/">Securing Applications and Services Guide</a> for more information.</p></div>
<div class="paragraph"><p>To fill in the <code>Web Origins</code> data, enter in a base URL and click the + sign to add.  Click the - sign next to URLs you want to remove.
Remember that you still have to click the <code>Save</code> button!</p></div>
<h3>Advanced Settings</h3><div class="paragraph" id="_mtls-client-certificate-bound-tokens"><p><strong>OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled</strong></p></div>
<div class="paragraph"><p>Mutual TLS binds an access token and a refresh token with a client certificate exchanged during TLS handshake. This prevents an attacker who finds a way to steal these tokens from exercising the tokens. This type of token is called a holder-of-key token. Unlike bearer tokens, the recipient of a holder-of-key token can verify whether the sender of the token is legitimate.</p></div>
<div class="paragraph"><p>If the following conditions are satisfied on a token request, Red Hat Single Sign-On will bind an access token and a refresh token with a client certificate and issue them as holder-of-key tokens. If all conditions are not met, Red Hat Single Sign-On rejects the token request.</p></div>
<div class="ulist"><ul><li><p>The feature is turned on</p></li><li><p>A token request is sent to the token endpoint in an authorization code flow or a hybrid flow</p></li><li><p>On TLS handshake, Red Hat Single Sign-On requests a client certificate and a client send its client certificate</p></li><li><p>On TLS handshake, Red Hat Single Sign-On successfully verifies the client certificate</p></li></ul></div>
<div class="paragraph"><p>To enable mutual TLS in Red Hat Single Sign-On, see <a href="#_enable-mtls-wildfly">Enable mutual SSL in WildFly</a>.</p></div>
<div class="paragraph"><p>In the following cases, Red Hat Single Sign-On will verify the client sending the access token or the refresh token; if verification fails, Red Hat Single Sign-On rejects the token.</p></div>
<div class="ulist"><ul><li><p>A token refresh request is sent to the token endpoint with a holder-of-key refresh token</p></li><li><p>A UserInfo request is sent to UserInfo endpoint with a holder-of-key access token</p></li><li><p>A logout request is sent to Logout endpoint with a holder-of-key refresh token</p></li></ul></div>
<div class="paragraph"><p>Please see <a href="https://tools.ietf.org/html/draft-ietf-oauth-mtls-08#section-3">Mutual TLS Client Certificate Bound Access Tokens</a> in the OAuth 2.0 Mutual TLS Client Authentication and Certificate Bound Access Tokens for more details.</p></div>
<div class="paragraph"><p>WARNING:
None of the keycloak client adapters currently support holder-of-key token verification.
Instead, keycloak adapters currently treat access and refresh tokens as bearer tokens.</p></div>
<div class="paragraph" id="_proof-key-for-code-exchange"><p><strong>Proof Key for Code Exchange (PKCE)</strong></p></div>
<div class="paragraph"><p>When an attacker steals an authorization code that was issued to a legitimate client, PKCE prevents the attacker from receiving the tokens that apply to that code.</p></div>
<div class="paragraph"><p>The administrator can select the following three options:</p></div>
<div class="paragraph"><p><strong>Proof Key for Code Exchange Code Challenge Method</strong></p></div>
<div class="ulist"><ul><li><p>(blank) : Red Hat Single Sign-On does not apply PKCE unless the client sends PKCE&#8217;s parameters appropriately to keycloak&#8217;s authorization endpoint. It is the default setting.</p></li><li><p>S256 : Red Hat Single Sign-On applies to the client PKCE whose code challenge method is S256.</p></li><li><p>plain : Red Hat Single Sign-On applies to the client PKCE whose code challenge method is plain.</p></li></ul></div>
<div class="paragraph"><p>Please see <a href="https://tools.ietf.org/html/rfc7636">RFC 7636 Proof Key for Code Exchange by OAuth Public Clients</a> for more details.</p></div>
<div class="paragraph" id="_jwe-id-token-encryption"><p><strong>Signed and Encrypted ID Token Support</strong></p></div>
<div class="paragraph"><p>Red Hat Single Sign-On can encrypt ID token according to <a href="https://tools.ietf.org/html/rfc7516">Json Web Encryption (JWE)</a> specification. The administrator can determine whether encrypting ID token or not per client. This feature is disabled as default.</p></div>
<div class="paragraph"><p>The key for encrypting ID token is called Content Encryption Key (CEK). Red Hat Single Sign-On and a client need to negotiate which CEK is used and how to deliver it. The way to do so is called Key Management Mode.</p></div>
<div class="paragraph"><p>JWE specification determines 5 types of Key Management Mode. Red Hat Single Sign-On supports Key Encryption among them.</p></div>
<div class="paragraph"><p>In Key Encryption, the client generates a key pair of asymmetric cryptography. The public key is used to encrypt CEK. Red Hat Single Sign-On generates CEK per ID token, encrypts the ID token by this generated CEK and encrypts this CEK by this client&#8217;s public key. The client decrypts this encrypted CEK by their private key, and decrypt the ID token by decrypted CEK. Therefore, any party other than the client is not able to decrypt ID token.</p></div>
<div class="paragraph"><p>The client needs to pass their public key for encrypting CEK onto Red Hat Single Sign-On. Red Hat Single Sign-On supports downloading public keys from the URL the client provides. The client needs to provide their public keys according to <a href="https://tools.ietf.org/html/rfc7517">Json Web Keys (JWK)</a> specification. The way to do so is defined in <code>Signed JWT</code> of <a href="#_client-credentials">Confidential Client Credentials</a>. The detailed procedure is as follows:</p></div>
<div class="ulist"><ul><li><p>open the client&#8217;s <code>Credentials</code> tab</p></li><li><p>select <code>Signed Jwt</code> from <code>Client Authenticator</code> pulldown menu</p></li><li><p>set ON to <code>JWKS URL</code> switch</p></li><li><p>input the client&#8217;s public key providing URL on <code>JWKS URL</code> textbox</p></li></ul></div>
<div class="paragraph"><p>Key Encryption&#8217;s algorithms are defined in <a href="https://tools.ietf.org/html/rfc7518#section-4.1">Json Web Algorithm (JWA)</a> specification. Red Hat Single Sign-On supports RSAES-PKCS1-v1_5(RSA1_5) and RSAES OAEP using default parameters (RSA-OAEP). The detailed procedure to select this algorithm is as follows:</p></div>
<div class="ulist"><ul><li><p>open the client&#8217;s <code>Settings</code> tab</p></li><li><p>open <code>Advanced Settings</code></p></li><li><p>select <code>RSA1_5</code> or <code>RSA-OAEP</code> from <code>ID Token Encryption Key Management Algorithm</code> pulldown menu</p></li></ul></div>
<div class="paragraph"><p>ID token encryption algorithms by CEK are also defined in <a href="https://tools.ietf.org/html/rfc7518#section-5.1">JWA</a> specification. Red Hat Single Sign-On supports AES_128_CBC_HMAC_SHA_256 authenticated encryption (A128CBC-HS256) and AES GCM using 128-bit key (A128GCM). The detailed procedure to select this algorithm is as follows:</p></div>
<div class="ulist"><ul><li><p>open the client&#8217;s <code>Settings</code> tab</p></li><li><p>open <code>Advanced Settings</code></p></li><li><p>select <code>A128CBC-HS256</code> or <code>A128GCM</code> from <code>ID Token Encryption Content Encryption Algorithm</code> pulldown menu</p></li></ul></div>
<h3>Confidential Client Credentials</h3><div class="paragraph"><p>If you&#8217;ve set the client&#8217;s <a href="#_access-type">access type</a> to <code>confidential</code> in the client&#8217;s
<code>Settings</code> tab, a new <code>Credentials</code> tab will show up. As part of dealing with this
type of client you have to configure the client&#8217;s credentials.</p></div>
<div class="paragraph"><div class="title">Credentials Tab</div><p><span class="image"><img src="rhsso-images/client-credentials.png" alt="client credentials"></span></p></div>
<div class="paragraph"><p>The <code>Client Authenticator</code> list box specifies the type of credential you are going to use for your confidential client.
It defaults to client ID and secret.  The secret is automatically generated for you and the <code>Regenerate Secret</code>
button allows you to recreate this secret if you want or need to.</p></div>
<div class="paragraph"><p>Alternatively, you can opt to use a signed Json Web Token (JWT) or x509 certificate validation (also called Mutual TLS) instead of a secret.</p></div>
<div class="paragraph"><div class="title">Signed JWT</div><p><span class="image"><img src="rhsso-images/client-credentials-jwt.png" alt="client credentials jwt"></span></p></div>
<div class="paragraph"><p>When choosing this credential type you will have to also generate a private key and certificate for the client.  The private key
will be used to sign the JWT, while the certificate is used by the server to verify the signature.  Click on the
<code>Generate new keys and certificate</code> button to start this process.</p></div>
<div class="paragraph"><div class="title">Generate Keys</div><p><span class="image"><img src="rhsso-images/generate-client-keys.png" alt="generate client keys"></span></p></div>
<div class="paragraph"><p>When you generate these keys, Red Hat Single Sign-On will store the certificate, and you&#8217;ll need to download the private key
and certificate for your client to use.  Pick the archive format you want and specify the password for the private key
and store.</p></div>
<div class="paragraph"><p>You can also opt to
generate these via an external tool and just import the client&#8217;s certificate.</p></div>
<div class="paragraph"><div class="title">Import Certificate</div><p><span class="image"><img src="rhsso-images/import-client-cert.png" alt="import client cert"></span></p></div>
<div class="paragraph"><p>There are multiple formats you can import from, just choose the archive format you have the certificate stored in,
select the file, and click the <code>Import</code> button.</p></div>
<div class="paragraph"><p>Finally note that you don&#8217;t even need to import certificate if you choose to <code>Use JWKS URL</code> . In that case, you can provide the URL where
client publishes its public key in <a href="https://self-issued.info/docs/draft-ietf-jose-json-web-key.html">JWK</a> format. This is flexible because when
client changes its keys, Red Hat Single Sign-On will automatically download them without need to re-import anything on Red Hat Single Sign-On side.</p></div>
<div class="paragraph"><p>If you use client secured by Red Hat Single Sign-On adapter, you can configure the JWKS URL like <a href="https://myhost.com/myapp/k_jwks" class="bare">https://myhost.com/myapp/k_jwks</a> assuming that <a href="https://myhost.com/myapp" class="bare">https://myhost.com/myapp</a> is the
root URL of your client application. See <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for additional details.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">For the performance purposes, Red Hat Single Sign-On caches the public keys of the OIDC clients. If you think that private key of your client
was compromised, it is obviously good to update your keys, but it&#8217;s also good to clear the keys cache. See <a href="#_clear-cache">Clearing the cache</a>
section for more details.</td></tr></table></div>
<div class="paragraph"><div class="title">Signed JWT with Client Secret</div><p>If you select this option in the <code>Client Authenticator</code> list box, you can use a JWT signed by client secret instead of the private key.</p></div>
<div class="paragraph"><p>This client secret will be used to sign the JWT by the client.</p></div>
<div class="paragraph"><div class="title">X509 Certificate</div><p>By enabling this option Red Hat Single Sign-On will validate if the client uses proper X509 certificate during the TLS Handshake.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">This option requires mutual TLS in Red Hat Single Sign-On, see <a href="#_enable-mtls-wildfly">Enable mutual SSL in WildFly</a>.</td></tr></table></div>
<div class="paragraph"><div class="title">X509 Certificate</div><p><span class="image"><img src="rhsso-images/x509-client-auth.png" alt="x509 client auth"></span></p></div>
<div class="paragraph"><p>The validator checks also the certificate&#8217;s Subject DN field with configured regexp validation expression. For some
use cases, it is sufficient to accept all certificates. In that case, you can use <code>(.*?)(?:$)</code> expression.</p></div>
<div class="paragraph"><p>There are two ways for Red Hat Single Sign-On to obtain the Client ID from the request. The first option is the <code>client_id</code>
parameter in the query (described in Section 2.2 of the <a href="https://tools.ietf.org/html/rfc6749">OAuth 2.0 Specification</a>).
The second option is to supply <code>client_id</code> as a query parameter.</p></div>
<h3>Service Accounts</h3><div class="paragraph"><p>Each OIDC client has a built-in <em>service account</em> which allows it to obtain an access token.
This is covered in the OAuth 2.0 specifiation under <a href="#_client_credentials_grant">Client Credentials Grant</a>.
To use this feature you must set the <a href="#_access-type">Access Type</a> of your client to <code>confidential</code>.  When you do this,
the <code>Service Accounts Enabled</code> switch will appear.  You need to turn on this switch.  Also make sure that you have
configured your <a href="#_client-credentials">client credentials</a>.</p></div>
<div class="paragraph"><p>To use it you must have registered a valid <code>confidential</code> Client and you need to check the switch <code>Service Accounts Enabled</code> in Red Hat Single Sign-On admin console for this client.
In tab <code>Service Account Roles</code> you can configure the roles available to the service account retrieved on behalf of this client.
Remember that you must have the roles available in Role Scope Mappings (tab <code>Scope</code>) of this client as well, unless you
have <code>Full Scope Allowed</code> on. As in a normal login, roles from access token are the intersection of:</p></div>
<div class="ulist"><ul><li><p>Role scope mappings of particular client combined with the role scope mappings inherited from linked client scopes</p></li><li><p>Service account roles</p></li></ul></div>
<div class="paragraph"><p>The REST URL to invoke on is <code>/auth/realms/{realm-name}/protocol/openid-connect/token</code>.
Invoking on this URL is a POST request and requires you to post the client credentials.
By default, client credentials are represented by clientId and clientSecret of the client in <code>Authorization: Basic</code> header, but you can also authenticate the client with a signed JWT assertion or any other custom mechanism for client authentication.
You also need to use the parameter <code>grant_type=client_credentials</code> as per the OAuth2 specification.</p></div>
<div class="paragraph"><p>For example the POST invocation to retrieve a service account can look like this:</p></div>
<pre class="highlight listingblock"><code>    POST /auth/realms/demo/protocol/openid-connect/token
    Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=
    Content-Type: application/x-www-form-urlencoded

    grant_type=client_credentials</code></pre>
<div class="paragraph"><p>The response would be this <a href="https://tools.ietf.org/html/rfc6749#section-4.4.3">standard JSON document</a> from the OAuth 2.0 specification.</p></div>
<pre class="highlight listingblock"><code>HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token":"2YotnFZFEjr1zCsicMWpAA",
    "token_type":"bearer",
    "expires_in":60,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "refresh_expires_in":600,
    "id_token":"tGzv3JOkF0XG5Qx2TlKWIA",
    "not-before-policy":0,
    "session_state":"234234-234234-234234"
}</code></pre>
<div class="paragraph"><p>The retrieved access token can be refreshed or logged out by an out-of-bound request.</p></div>
<h3>Audience Support</h3><div class="paragraph"><p>The typical environment where the Red Hat Single Sign-On is deployed generally consists of a set of <em>confidential</em> or <em>public</em> client
applications (frontend client applications) which use Red Hat Single Sign-On for authentication.</p></div>
<div class="paragraph"><p>There are also <em>services</em> (called <em>Resource Servers</em> in the OAuth 2 specification), which serve requests from frontend client
applications and provide resources. These services typically require an <em>Access token</em> (Bearer token) to be sent to them to
authenticate for a particular request. This token was previously obtained by the frontend application when it tries to log in
against Red Hat Single Sign-On.</p></div>
<div class="paragraph"><p>In the environment where the trust among services is low, you may encounter this scenario:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>A frontend client called <code>my-app</code> is required to be authenticated against Red Hat Single Sign-On.</p></li><li><p>A user is authenticated in Red Hat Single Sign-On. Red Hat Single Sign-On then issued tokens to the <code>my-app</code> application.</p></li><li><p>The application <code>my-app</code> used the token to invoke the service <code>evil-service</code>. The application needs to invoke <code>evil-service</code> as
the service is able to serve some very useful data.</p></li><li><p>The <code>evil-service</code> application returned the response to <code>my-app</code>. However, at the same time, it kept the token previously sent to it.</p></li><li><p>The <code>evil-service</code> application then invoked another service called <code>good-service</code> with the previously kept token. The invocation
was successful and <code>good-service</code> returned the data. This results in broken security as the <code>evil-service</code> misused the token to
access other services on behalf of the client <code>my-app</code>.</p></li></ol></div>
<div class="paragraph"><p>This flow may not be an issue in many environments with the high level of trust among services. However in other environments, where
the trust among services is lower, this can be problematic.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">In some environments, this example work flow may be even requested behavior as the <code>evil-service</code> may need to retrieve
      additional data from <code>good-service</code> to be able to properly return the requested data to the original caller (my-app client).
      You may notice similarities with the Kerberos Credential Delegation. As with the Kerberos Credential Delegation, an unlimited
      audience is a mixed blessing as it is only useful when a high level of trust exists among services. Otherwise, it is
      recommended to limit audience as described next. You can limit audience and at the same time allow the <code>evil-service</code> to
      retrieve required data from the <code>good-service</code>. In this case, you need to ensure that both the <code>evil-service</code> and <code>good-service</code>
      are added as audiences to the token.</td></tr></table></div>
<div class="paragraph"><p>To prevent any misuse of the access token as in the example above, it is recommended to limit <em>Audience</em> on the token and configure
your services to verify the audience on the token. If this is done, the flow above will change, like this:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>A frontend client called <code>my-app</code> is required to be authenticated against Red Hat Single Sign-On.</p></li><li><p>A user is authenticated in Red Hat Single Sign-On. Red Hat Single Sign-On then issued tokens to the <code>my-app</code> application. The client application
already knows that it will need to invoke service <code>evil-service</code>, so it used <code>scope=evil-service</code> in the authentication request
sent to the Red Hat Single Sign-On server. See <a href="#_client_scopes">Client Scopes section</a> for more details about the <em>scope</em> parameter.
The token issued to the <code>my-app</code> client contains the audience, as in <code>"audience": [ "evil-service" ]</code>, which declares that the
client wants to use this access token to invoke just the service <code>evil-service</code>.</p></li><li><p>The <code>evil-service</code> application served the request to the <code>my-app</code>. At the same time, it kept the token previously sent to it.</p></li><li><p>The <code>evil-service</code> application then invoked the <code>good-service</code> with the previously kept token. Invocation was not successful
because <code>good-service</code> checks the audience on the token and it sees that audience is only <code>evil-service</code>. This is expected behavior
and security is not broken.</p></li></ol></div>
<div class="paragraph"><p>If the client wants to invoke the <code>good-service</code> later, it will need to obtain another token by issuing the SSO login with the
<code>scope=good-service</code>. The returned token will then contain <code>good-service</code> as an audience:</p></div>
<pre class="highlight listingblock"><code class="json language-json">"audience": [ "good-service" ]</code></pre>
<div class="paragraph"><p>and can be used to invoke <code>good-service</code>.</p></div>
<h4>Setup</h4><div class="paragraph"><p>To properly set up audience checking:</p></div>
<div class="ulist"><ul><li><p>Ensure that services are configured to check audience on the access token sent to them by adding the flag <em>verify-token-audience</em>
in the adapter configuration. See <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/#_java_adapter_config">Adapter configuration</a> for details.</p></li><li><p>Ensure that when an access token is issued by Red Hat Single Sign-On, it contains all requested audiences and does not contain any
audiences that are not needed. The audience can be either automatically added due the client roles as described
in the <a href="#_audience_resolve">next section</a> or it can be hardcoded as described <a href="#_audience_hardcoded">below</a>.</p></li></ul></div>
<h4>Automatically add audience</h4><div class="paragraph"><p>In the default client scope <em>roles</em>, there is an <em>Audience Resolve</em>
protocol mapper defined. This protocol mapper will check all the clients for which current token has at least one client role
available. Then the client ID of each of those clients will be added as an audience automatically. This is especially useful if
your service (usually bearer-only) clients rely on client roles.</p></div>
<div class="paragraph"><p>As an example, let us assume that you have a bearer-only client <code>good-service</code> and the confidential client <code>my-app</code>, which you want
to authenticate and then use the access token issued for the <code>my-app</code> to invoke the <code>good-service</code> REST service. If the following
are true:</p></div>
<div class="ulist"><ul><li><p>The <code>good-service</code> client has any client roles defined on itself</p></li><li><p>Target user has at least one of those client roles assigned</p></li><li><p>Client <code>my-app</code> has the role scope mappings for the assigned role</p></li></ul></div>
<div class="paragraph"><p>then the <code>good-service</code> will be automatically added as an audience to the access token issued for the <code>my-app</code>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">If you want to ensure that audience is not added automatically, do not configure role scope mappings directly
on the <code>my-app</code> client, but instead create a dedicated client scope, for example called <code>good-service</code>, which will contain the role scope mappings
for the client roles of the <code>good-service</code> client. Assuming that this client scope will be added as an optional client scope to
the <code>my-app</code> client, the client roles and audience will be added to the token just if explicitly requested by the <code>scope=good-service</code> parameter.</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">The frontend client itself is not automatically added to the access token audience. This allows for easy differentiation between
the access token and the ID token, because the access token will not contain the client for which the token was issued as an audience. So in
the example above, the <code>my-app</code> won&#8217;t be added as an audience. If you need the client itself as an audience, see the
<a href="#_audience_hardcoded">hardcoded audience</a> option. However, using the same client as both frontend and REST service is not recommended.</td></tr></table></div>
<h4>Hardcoded audience</h4><div class="paragraph"><p>For the case when your service relies on realm roles or does not rely on the roles in the token at all, it can be useful to use hardcoded
audience. This is a protocol mapper, which will add client ID of the specified service client as an audience to the token.
You can even use any custom value, for example some URL, if you want different audience than client ID.</p></div>
<div class="paragraph"><p>You can add protocol mapper directly to the frontend client, however than the audience will be always added. If you want more fine-grain
control, you can create protocol mapper on the dedicated client scope, which will be called for example <code>good-service</code>.</p></div>
<div class="paragraph"><div class="title">Audience Protocol Mapper</div><p><span class="image"><img src="rhsso-images/audience_mapper.png" alt="audience mapper"></span></p></div>
<div class="ulist"><ul><li><p>From the <a href="#_client_installation">Installation tab</a> of the <code>good-service</code> client, you can generate the adapter
configuration and you can confirm that <em>verify-token-audience</em> option will be set to true. This indicates that the adapter will
require verifying the audience if you use this generated configuration.</p></li><li><p>Finally, you need to ensure that the <code>my-app</code> frontend client is able to request <code>good-service</code> as an audience in its tokens.
On the <code>my-app</code> client, click the <em>Client Scopes</em> tab. Then assign <code>good-service</code> as an optional (or default) client scope. See
<a href="#_client_scopes_linking">Client Scopes Linking section</a> for more details.</p></li><li><p>You can optionally <a href="#_client_scopes_evaluate">Evaluate Client Scopes</a> and generate an example access token. If you do, notice
that <code>good-service</code> will be added to the audience of the generated access token only if <code>good-service</code> is included in the <em>scope</em>
parameter in the case you assigned it as an optional client scope.</p></li><li><p>In your <code>my-app</code> application, you must ensure that <em>scope</em> parameter is used with the value <code>good-service</code> always included when
you want to issue the token for accessing the <code>good-service</code>.
See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/#_params_forwarding">parameters forwarding section</a>, if your application uses the servlet
adapter, or the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/#_javascript_adapter">javascript adapter section</a>, if your application uses the
javascript adapter.</p></li></ul></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">If you are unsure what the correct audience and roles in the token will be, it is always a good idea to
<a href="#_client_scopes_evaluate">Evaluate Client Scopes</a> in the admin console and do some testing around it.</td></tr></table></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Both the <em>Audience</em> and <em>Audience Resolve</em> protocol mappers add the audiences just to the access token by default. The ID Token
typically contains only single audience, which is the client ID of the client for which the token was issued. This is a requirement
of the OpenID Connect specification. On the other hand, the access token does not necessarily have the client ID of the client,
which was the token issued for, unless any of the audience mappers added it.</td></tr></table></div></section><section id="_saml_clients"><h2>SAML Clients</h2><div class="paragraph"><p>Red Hat Single Sign-On supports <a href="#_saml">SAML 2.0</a> for registered applications.
Both POST and Redirect bindings are supported.
You can choose to require client signature validation and can have the server sign and/or encrypt responses as well.</p></div>
<div class="paragraph"><p>To create a SAML client go to the <code>Clients</code> left menu item.  On this page you&#8217;ll see a <code>Create</code> button on the right.</p></div>
<div class="paragraph"><div class="title">Clients</div><p><span class="image"><img src="rhsso-images/clients.png" alt="clients"></span></p></div>
<div class="paragraph"><p>This will bring you to the <code>Add Client</code> page.</p></div>
<div class="paragraph"><div class="title">Add Client</div><p><span class="image"><img src="rhsso-images/add-client-saml.png" alt="add client saml"></span></p></div>
<div class="paragraph"><p>Enter in the <code>Client ID</code> of the client.  This is often a URL and will be the expected <code>issuer</code> value in SAML requests sent
by the application.  Next select <code>saml</code> in the <code>Client Protocol</code> drop down box.
Finally enter in the <code>Client SAML Endpoint</code> URL.  Enter the
URL you want the Red Hat Single Sign-On server to send SAML requests and responses to.  Usually applications have only one URL for processing SAML requests.
If your application has different URLs for its bindings, don&#8217;t worry, you can fix this in the <code>Settings</code> tab of the client.
Click <code>Save</code>.  This will create the client and bring you to the client <code>Settings</code>
tab.</p></div>
<div class="paragraph"><div class="title">Client Settings</div><p><span class="image"><img src="rhsso-images/client-settings-saml.png" alt="client settings saml"></span></p></div>
<div class="dlist"><dl><dt class="hdlist1">Client ID</dt><dd><p>This value must match the issuer value sent with AuthNRequests.
Red Hat Single Sign-On will pull the issuer from the Authn SAML request and match it to a client by this value.</p></dd><dt class="hdlist1">Name</dt><dd><p>This is the display name for the client whenever it is displayed in a Red Hat Single Sign-On UI screen.  You can localize
the value of this field by setting up a replacement string value i.e. ${myapp}.  See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a>
for more information.</p></dd><dt class="hdlist1">Description</dt><dd><p>This specifies the description of the client.  This can also be localized.</p></dd><dt class="hdlist1">Enabled</dt><dd><p>If this is turned off, the client will not be allowed to request authentication.</p></dd><dt class="hdlist1">Consent Required</dt><dd><p>If this is on, then users will get a consent page which asks the user if they grant access to that application.  It will also
display the metadata that the client is interested in so that the user knows exactly what information the client is getting access to.
If you&#8217;ve ever done a social login to Google, you&#8217;ll often see a similar page.  Red Hat Single Sign-On provides the same functionality.</p></dd><dt class="hdlist1">Include AuthnStatement</dt><dd><p>SAML login responses may specify the authentication method used (password, etc.) as well as timestamps of the login and the session expiration.
This is enabled by default, which means that <code>AuthStatement</code> element will be included in login responses. Note that setting this to off
would prevent the client from determining the maximum session length which could result into never expiring client session.</p></dd><dt class="hdlist1">Sign Documents</dt><dd><p>When turned on, Red Hat Single Sign-On will sign the document using the realm&#8217;s private key.</p></dd><dt class="hdlist1">Optimize REDIRECT signing key lookup</dt><dd><p>When turned on, the SAML protocol messages will include Red Hat Single Sign-On
native extension that contains a hint with signing key ID. When the SP
understands this extension, it can use it for signature validation instead of
attempting to validate signature with all known keys. This option only applies to
REDIRECT bindings where the signature is transferred in query parameters where
there is no place with this information in the signature information
(contrary to POST binding messages where key ID is always included in
document signature). Currently this is relevant to situations where both
IDP and SP are provided by Red Hat Single Sign-On server and adapter. This
option is only relevant when <code>Sign Documents</code> is switched on.</p></dd><dt class="hdlist1">Sign Assertions</dt><dd><p>The <code>Sign Documents</code> switch signs the whole document.
With this setting the assertion is also signed and embedded within the SAML XML Auth response.</p></dd><dt class="hdlist1">Signature Algorithm</dt><dd><p>Choose between a variety of algorithms for signing SAML documents.</p></dd><dt class="hdlist1">SAML Signature Key Name</dt><dd><p>Signed SAML documents sent via POST binding contain identification of signing key in <code>KeyName</code>
element. This by default contains Red Hat Single Sign-On key ID. However various vendors might
expect a different key name or no key name at all. This switch controls whether <code>KeyName</code>
contains key ID (option <code>KEY_ID</code>), subject from certificate corresponding to the realm key
(option <code>CERT_SUBJECT</code> - expected for instance by Microsoft Active Directory Federation
Services), or that the key name hint is completely omitted from the SAML message (option <code>NONE</code>).</p></dd><dt class="hdlist1">Canonicalization Method</dt><dd><p>Canonicalization method for XML signatures.</p></dd><dt class="hdlist1">Encrypt Assertions</dt><dd><p>Encrypt assertions in SAML documents with the realm&#8217;s private key.
The AES algorithm is used with a key size of 128 bits.</p></dd><dt class="hdlist1">Client Signature Required</dt><dd><p>Expect that documents coming from a client are signed.
Red Hat Single Sign-On will validate this signature using the client public key or cert set up in the <code>SAML Keys</code> tab.</p></dd><dt class="hdlist1">Force POST Binding</dt><dd><p>By default, Red Hat Single Sign-On will respond using the initial SAML binding of the original request.
By turning on this switch, you will force Red Hat Single Sign-On to always respond using the SAML POST Binding even if the original request was the Redirect binding.</p></dd><dt class="hdlist1">Front Channel Logout</dt><dd><p>If true, this application requires a browser redirect to be able to perform a logout.
For example, the application may require a cookie to be reset which could only be done via a redirect.
If this switch is false, then Red Hat Single Sign-On will invoke a background SAML request to logout the application.</p></dd><dt class="hdlist1">Force Name ID Format</dt><dd><p>If the request has a name ID policy, ignore it and used the value configured in the admin console under Name ID Format</p></dd><dt class="hdlist1">Name ID Format</dt><dd><p>Name ID Format for the subject.
If no name ID policy is specified in the request or if the Force Name ID Format attribute is true, this value is used.
Properties used for each of the respective formats are defined below.</p></dd><dt class="hdlist1">Root URL</dt><dd><p>If Red Hat Single Sign-On uses any configured relative URLs, this value is prepended to them.</p></dd><dt class="hdlist1">Valid Redirect URIs</dt><dd><p>This is an optional field.  Enter in a URL pattern and click the + sign to add.  Click the - sign next to URLs you want to remove.
Remember that you still have to click the <code>Save</code> button!
Wildcards (*) are only allowed at the end of a URI, i.e. http://host.com/*.  This field is used when the exact SAML
endpoints are not registered and Red Hat Single Sign-On is pulling the Assertion Consumer URL from the request.</p></dd><dt class="hdlist1">Base URL</dt><dd><p>If Red Hat Single Sign-On needs to link to the client, this URL would be used.</p></dd><dt class="hdlist1">Master SAML Processing URL</dt><dd><p>This URL will be used for all SAML requests and the response will be directed to the SP.
It will be used as the Assertion Consumer Service URL and the Single Logout Service URL.
If a login request contains the Assertion Consumer Service URL, that will take precedence, but this URL must be validated by a registered Valid Redirect URI pattern</p></dd><dt class="hdlist1">Assertion Consumer Service POST Binding URL</dt><dd><p>POST Binding URL for the Assertion Consumer Service.</p></dd><dt class="hdlist1">Assertion Consumer Service Redirect Binding URL</dt><dd><p>Redirect Binding URL for the Assertion Consumer Service.</p></dd><dt class="hdlist1">Logout Service POST Binding URL</dt><dd><p>POST Binding URL for the Logout Service.</p></dd><dt class="hdlist1">Logout Service Redirect Binding URL</dt><dd><p>Redirect Binding URL for the Logout Service.</p></dd></dl></div>
<h3>IDP Initiated Login</h3><div class="paragraph"><p>IDP Initiated Login is a feature that allows you to set up an endpoint on the Red Hat Single Sign-On server that will log you into a specific application/client.
In the <code>Settings</code> tab for your client, you need to specify the <code>IDP Initiated SSO URL Name</code>.
This is a simple string with no whitespace in it.
After this you can reference your client at the following URL: <code>root/auth/realms/{realm}/protocol/saml/clients/{url-name}</code></p></div>
<div class="paragraph"><p>The IDP initiated login implementation prefers <em>POST</em> over <em>REDIRECT</em> binding (check <a href="#_saml">saml bindings</a> for more information).
Therefore the final binding and SP URL are selected in the following way:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>If the specific <code>Assertion Consumer Service POST Binding URL</code> is defined (inside <code>Fine Grain SAML Endpoint Configuration</code> section
of the client settings) <em>POST</em> binding is used through that URL.</p></li><li><p>If the general <code>Master SAML Processing URL</code> is specified then <em>POST</em> binding is used again throught this general URL.</p></li><li><p>As the last resort, if the <code>Assertion Consumer Service Redirect Binding URL</code> is configured (inside
<code>Fine Grain SAML Endpoint Configuration</code>) <em>REDIRECT</em> binding is used with this URL.</p></li></ol></div>
<div class="paragraph"><p>If your client requires a special relay state, you can also configure this on the <code>Settings</code> tab in the <code>IDP Initiated SSO Relay State</code> field.
Alternatively, browsers can specify the relay state in a <code>RelayState</code> query parameter, i.e.
<code>root/auth/realms/{realm}/protocol/saml/clients/{url-name}?RelayState=thestate</code>.</p></div>
<div class="paragraph"><p>When using <a href="#_identity_broker">identity brokering</a>, it is possible to set up an IDP Initiated Login for a client from an
external IDP. The actual client is set up for IDP Initiated Login at broker IDP as described above. The external IDP has
to set up the client for application IDP Initiated Login that will point to a special URL pointing to the broker and
representing IDP Initiated Login endpoint for a selected client at the brokering IDP. This means that in client settings
at the external IDP:</p></div>
<div class="ulist"><ul><li><p><code>IDP Initiated SSO URL Name</code> is set to a name that will be published as IDP Initiated Login initial point,</p></li><li><p><code>Assertion Consumer Service POST Binding URL</code> in the <code>Fine Grain SAML Endpoint Configuration</code> section has
to be set to the following URL:
<code>broker-root/auth/realms/{broker-realm}/broker/{idp-name}/endpoint/clients/{client-id}</code>, where:</p><div class="ulist"><ul><li><p><em>broker-root</em> is base broker URL</p></li><li><p><em>broker-realm</em> is name of the realm at broker where external IDP is declared</p></li><li><p><em>idp-name</em> is name of the external IDP at broker</p></li><li><p><em>client-id</em> is the value of <code>IDP Initiated SSO URL Name</code> attribute of the SAML client defined at broker. It is
this client, which will be made available for IDP Initiated Login from the external IDP.</p></li></ul></div></li></ul></div>
<div class="paragraph"><p>Please note that you can import basic client settings from the brokering IDP into client settings of the external IDP -
just use <a href="#_identity_broker_saml_sp_descriptor">SP Descriptor</a> available from the settings of the identity provider in
the brokering IDP, and add <code>clients/<em>client-id</em></code> to the endpoint URL.</p></div>
<h3>SAML Entity Descriptors</h3><div class="paragraph"><p>Instead of manually registering a SAML 2.0 client, you can import it via a standard SAML Entity Descriptor XML file.
There is an <code>Import</code> option on the Add Client page.</p></div>
<div class="paragraph"><div class="title">Add Client</div><p><span class="image"><img src="rhsso-images/add-client-saml.png" alt="add client saml"></span></p></div>
<div class="paragraph"><p>Click the <code>Select File</code> button and load your entity descriptor file.  You should review all the information there to make sure everything is set up correctly.</p></div>
<div class="paragraph"><p>Some SAML client adapters like <em>mod-auth-mellon</em> need the XML Entity Descriptor for the IDP.  You can obtain this by
going to this public URL:  <code>root/auth/realms/{realm}/protocol/saml/descriptor</code></p></div></section><section id="_client_links"><h2>Client Links</h2><div class="paragraph"><p>For scenarios where one wants to link from one client to another, Red Hat Single Sign-On provides a special redirect endpoint: <code>/realms/realm_name/clients/{client-id}/redirect</code>.</p></div>
<div class="paragraph"><p>If a client accesses this endpoint via an <code>HTTP GET</code> request, Red Hat Single Sign-On returns the configured base URL for the provided Client and Realm in the form of an <code>HTTP 307</code> (Temporary Redirect) via the response&#8217;s <code>Location</code> header.</p></div>
<div class="paragraph"><p>Thus, a client only needs to know the Realm name and the Client ID in order to link to them.
This indirection helps avoid hard-coding client base URLs.</p></div>
<div class="paragraph"><p>As an example, given the realm <code>master</code> and the client-id <code>account</code>:</p></div>
<pre class="highlight listingblock"><code>http://host:port/auth/realms/master/clients/account/redirect</code></pre>
<div class="paragraph"><p>Would temporarily redirect to: <a href="http://host:port/auth/realms/master/account" class="bare">http://host:port/auth/realms/master/account</a></p></div></section><section id="_protocol-mappers"><h2>OIDC Token and SAML Assertion Mappings</h2><div class="paragraph"><p>Applications that receive ID Tokens, Access Tokens, or SAML assertions may need or want different user metadata and roles.
Red Hat Single Sign-On allows you to define what exactly is transferred.
You can hardcode roles, claims and custom attributes.
You can pull user metadata into a token or assertion.
You can rename roles.
Basically you have a lot of control of what exactly goes back to the client.</p></div>
<div class="paragraph"><p>Within the Admin Console, if you go to an application you&#8217;ve registered, you&#8217;ll see a <code>Mappers</code> tab.  Here&#8217;s one for
an OIDC based client.</p></div>
<div class="paragraph"><div class="title">Mappers Tab</div><p><span class="image"><img src="rhsso-images/mappers-oidc.png" alt="mappers oidc"></span></p></div>
<div class="paragraph"><p>The new client does not have any built-in mappers, however it usually inherits some mappers from the client scopes as described
in the <a href="#_client_scopes">client scopes section</a>. Protocol mappers map things like, for example, email address to
a specific claim in the identity and access token.  Their function should each be self explanatory from their name.  There
are additional pre-configured mappers that are not attached to the client that you can add
by clicking the <code>Add Builtin</code> button.</p></div>
<div class="paragraph"><p>Each mapper has common settings as well as additional ones depending on which type of mapper you are adding.  Click the <code>Edit</code> button
next to one of the mappers in the list to get to the config screen.</p></div>
<div class="paragraph"><div class="title">Mapper Config</div><p><span class="image"><img src="rhsso-images/mapper-config.png" alt="mapper config"></span></p></div>
<div class="paragraph"><p>The best way to learn about a config option is to hover over its tooltip.</p></div>
<div class="paragraph"><p>Most OIDC mappers also allow you to control where the claim gets put.  You can opt to include or exclude the claim from both the
<em>id</em> and <em>access</em> tokens by fiddling with the <code>Add to ID token</code> and <code>Add to access token</code> switches.</p></div>
<div class="paragraph"><p>Finally, you can also add other mapper types.  If you go back to the <code>Mappers</code> tab, click the <code>Create</code> button.</p></div>
<div class="paragraph"><div class="title">Add Mapper</div><p><span class="image"><img src="rhsso-images/add-mapper.png" alt="add mapper"></span></p></div>
<div class="paragraph"><p>Pick a <code>Mapper Type</code> from the list box.  If you hover over the tooltip, you&#8217;ll see a description of what that mapper type does.
Different config parameters will appear for different mapper types.</p></div>
<h3>Priority order</h3><div class="paragraph"><p>Mapper implementations have <em>priority order</em>. This priority order is not the configuration property of the mapper; rather, it is
the property of the concrete implementation of the mapper.</p></div>
<div class="paragraph"><p>Mappers are sorted in the admin console by the order in the list of mappers and the changes in the token or assertion will be
applied using that order with the lowest being applied first. This means that implementations which are dependent on other
implementations are processed in the needed order.</p></div>
<div class="paragraph"><p>For example, when we first want to compute the roles which will be included with a token, we first resolve audiences based on
those roles. Then, we process a JavaScript script that uses the roles and audiences already available in the token.</p></div>
<h3>OIDC User Session Note Mappers</h3><div class="paragraph"><p>User session details are via mappers and depend on various criteria. User session details are automatically included when you use or enable a feature on a client. You can also click the <code>Add builtin</code> button to include session details.</p></div>
<div class="paragraph"><p>Impersonated user sessions provide the following details:</p></div>
<div class="ulist"><ul><li><p><code>IMPERSONATOR_ID</code>: The ID of an impersonating user</p></li><li><p><code>IMPERSONATOR_USERNAME</code>: The username of an impersonating user</p></li></ul></div>
<div class="paragraph"><p>Service account sessions provide the following details:</p></div>
<div class="ulist"><ul><li><p><code>clientId</code>: The client ID of the service account</p></li><li><p><code>clientAddress</code>: The remote host IP of the service account authenticated device</p></li><li><p><code>clientHost</code>: The remote host name of the service account authenticated device</p></li></ul></div></section><section id="_client_installation"><h2>Generating Client Adapter Config</h2><div class="paragraph"><p>The Red Hat Single Sign-On can pre-generate configuration files that you can use to install a client adapter for in your application&#8217;s
deployment environment.  A number of adapter types are supported for both OIDC and SAML.  Go to the <code>Installation</code> tab of the
client you want to generate configuration for.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/client-installation.png" alt="client installation"></span></p></div>
<div class="paragraph"><p>Select the <code>Format Option</code> you want configuration generated for.  All Red Hat Single Sign-On client adapters for OIDC and SAML
are supported.  The mod-auth-mellon Apache HTTPD adapter for SAML is supported as well as standard SAML entity descriptor files.</p></div></section><section id="_client_scopes"><h2>Client Scopes</h2><div class="paragraph"><p>If you have many applications you need to secure and register within your organization, it can become tedious to configure the
<a href="#_protocol-mappers">protocol mappers</a> and <a href="#_role_scope_mappings">role scope mappings</a> for each of these clients. Red Hat Single Sign-On allows
you to define a shared client configuration in an entity called a <em>client scope</em>.</p></div>
<div class="paragraph"><p>Client scopes also provide support for the OAuth 2 <code>scope</code> parameter, which allows a client application to request more or fewer
claims or roles in the access token, according to the application needs.</p></div>
<div class="paragraph"><p>To create a client scope, follow these steps:</p></div>
<div class="ulist"><ul><li><p>Go to the <code>Client Scopes</code> left menu item. This initial screen shows you a list of currently defined client scopes.</p></li></ul></div>
<div class="paragraph"><div class="title">Client Scopes List</div><p><span class="image"><img src="rhsso-images/client-scopes-list.png" alt="client scopes list"></span></p></div>
<div class="ulist"><ul><li><p>Click the <code>Create</code> button. Name the client scope and save. A <em>client scope</em> will have similar tabs to a regular clients. You can
define <a href="#_protocol-mappers">protocol mappers</a> and <a href="#_role_scope_mappings">role scope mappings</a>, which can be inherited by other clients,
and which are configured to inherit from this client scope.</p></li></ul></div>
<h3>Protocol</h3><div class="paragraph"><p>When you are creating the client scope, you must choose the <code>Protocol</code>. Only the clients which use same protocol can then be linked
with this client scope.</p></div>
<div class="paragraph"><p>Once you have created new realm, you can see that there is a list of pre-defined (builtin) client scopes in the menu.</p></div>
<div class="ulist"><ul><li><p>For the SAML protocol, there is one builtin client scope, <code>roles_list</code>, which contains one protocol mapper for showing the roles
list in the SAML assertion.</p></li><li><p>For the OpenID Connect protocol, there are client scopes <code>profile</code>, <code>email</code>, <code>address</code>, <code>phone</code>, <code>offline_access</code>, <code>roles</code>,
<code>web-origins</code> and <code>microprofile-jwt</code>.</p></li></ul></div>
<div class="paragraph"><p>The client scope, <code>offline_access</code>, is useful when client wants to obtain offline tokens. Learn about offline tokens in the
<a href="#_offline-access">Offline Access section</a> or in the <a href="https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess">OpenID Connect specification</a>,
where scope parameter is defined with the value <code>offline_access</code>.</p></div>
<div class="paragraph"><p>The client scopes <code>profile</code>, <code>email</code>, <code>address</code> and <code>phone</code> are also defined in the <a href="https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">OpenID Connect specification</a>.
These client scopes do not have any role scope mappings defined, but they have some protocol mappers defined, and these mappers correspond
to the claims defined in the OpenID Connect specification.</p></div>
<div class="paragraph"><p>For example, when you click to open the <code>phone</code> client scope and open the <code>Mappers</code> tab, you will see the protocol mappers, which
correspond to the claims defined in the specification for the scope <code>phone</code>.</p></div>
<div class="paragraph"><div class="title">Client Scope Mappers</div><p><span class="image"><img src="rhsso-images/client-scopes-phone.png" alt="client scopes phone"></span></p></div>
<div class="paragraph"><p>When the <code>phone</code> client scope is linked to a client, that client automatically inherits all the protocol mappers defined in the
<code>phone</code> client scope. Access tokens issued for this client will contain the phone number information about the user, assuming that
the user has a defined phone number.</p></div>
<div class="paragraph"><p>Builtin client scopes contain exactly the protocol mappers as defined per the specification,
however you are free to edit client scopes and create/update/remove any protocol mappers (or role scope mappings).</p></div>
<div class="paragraph"><p>The client scope <code>roles</code> is not defined in the OpenID Connect specification and it is also not added automatically to the <code>scope</code>
claim in the access token. This client scope has some mappers, which are used to add roles of the user to the access token and
possibly add some audiences for the clients with at least one client role as described in the <a href="#_audience_resolve">Audience section</a>.</p></div>
<div class="paragraph"><p>The client scope <code>web-origins</code> is also not defined in the OpenID Connect specification and not added to the <code>scope</code> claim. This is used
to add allowed web origins to the access token <code>allowed-origins</code> claim.</p></div>
<div class="paragraph"><p>The client scope <code>microprofile-jwt</code> was created to handle the claims defined in the <a href="https://wiki.eclipse.org/MicroProfile/JWT_Auth">MicroProfile/JWT Auth Specification</a>.
This client scope defines a user property mapper for the <code>upn</code> claim and also a realm role mapper for the <code>groups</code> claim. These mappers
can be changed as needed so that different properties can be used to create the MicroProfile/JWT specific claims.</p></div>
<h3>Consent related settings</h3><div class="paragraph"><p>Client scope contains options related to the consent screen. Those options are useful only if the linked client is configured to
require consent (if the <code>Consent Required</code> switch is enabled on the client).</p></div>
<div class="dlist"><dl><dt class="hdlist1">Display On Consent Screen</dt><dd><p>If on, and if this client scope is added to a client with consent required, then the text specified by <code>Consent Screen Text</code> will
be displayed on the consent screen, which is shown once the user is authenticated and right before he is redirected from Red Hat Single Sign-On
to the client. If the switch is off, then this client scope will not be displayed on the consent screen.</p></dd><dt class="hdlist1">Consent Screen Text</dt><dd><p>The text shown on the consent screen when this client scope is added to some client with consent required defaults to
the name of client scope. The value for this text is localizable by specifying a substitution variable
with <code>${var-name}</code> strings. The localized value is then configured within property files in your theme. See the
<a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more information on localization.</p></dd></dl></div>
<h3>Link Client Scope with the Client</h3><div class="paragraph"><p>Linking between client scope and client is configured in the <code>Client Scopes</code> tab of the particular client. There are 2 ways of
linking between client scope and client.</p></div>
<div class="dlist"><dl><dt class="hdlist1">Default Client Scopes</dt><dd><p>This is applicable for both OpenID Connect and SAML clients. Default client scopes are always applied when issuing OpenID Connect tokens
or SAML assertions for this client. The client will inherit Protocol mappers and Role Scope Mappings defined on the client
scope. For the OpenID Connect Protocol, the Mappers and Role Scope Mappings are always applied, regardless of the value used for the scope
parameter in the OpenID Connect authorization request.</p></dd><dt class="hdlist1">Optional Client Scopes</dt><dd><p>This is applicable only for OpenID Connect clients. Optional client scopes are applied when issuing tokens for this client,
but only when they are requested by the <code>scope</code> parameter in the OpenID Connect authorization request.</p></dd></dl></div>
<h4>Example</h4><div class="paragraph"><p>For this example, we assume that the client has <code>profile</code> and <code>email</code> linked as default client scopes, and <code>phone</code> and <code>address</code>
are linked as optional client scopes. The client will use the value of the scope parameter when sending a request to the OpenID Connect authorization
endpoint:</p></div>
<pre class="highlight listingblock"><code>scope=openid phone</code></pre>
<div class="paragraph"><p>The scope parameter contains the string, with the scope values divided by space (which is also the reason why a client scope name
cannot contain a space character in it). The value <code>openid</code> is the meta-value used for all OpenID Connect requests, so we will ignore
it for this example. The token will contain mappers and role scope mappings from the client scopes <code>profile</code>, <code>email</code> (which are
default scopes) and <code>phone</code> (an optional client scope requested by the scope parameter).</p></div>
<h3>Evaluating Client Scopes</h3><div class="paragraph"><p>The tabs <code>Mappers</code> and <code>Scope</code> of the client contain the protocol mappers and role scope mappings declared solely for this client.
They do not contain the mappers and scope mappings inherited from client scopes. However, it may be useful to see what the
effective protocol mappers will be (protocol mappers defined on the client itself as well as inherited from the linked client scopes)
and the effective role scope mappings used when you generate the token for the particular client.</p></div>
<div class="paragraph"><p>You can see all of these when you click the <code>Client Scopes</code> tab for the client and then open the sub-tab <code>Evaluate</code>. From here you
can select the optional client scopes that you want to apply. This will also show you the value of the <code>scope</code> parameter, which needs to
be sent from the application to the Red Hat Single Sign-On OpenID Connect authorization endpoint.</p></div>
<div class="paragraph"><div class="title">Evaluating Client Scopes</div><p><span class="image"><img src="rhsso-images/client-scopes-evaluate.png" alt="client scopes evaluate"></span></p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">If you want to see how you can send a custom value for a <code>scope</code> parameter from your application, see the
<a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/#_params_forwarding">parameters forwarding section</a>, if your application uses the servlet adapter, or the
<a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/#_javascript_adapter">javascript adapter section</a>, if your application uses the javascript adapter.</td></tr></table></div>
<h4>Generating Example Tokens</h4><div class="paragraph"><p>To see an example of a real access token, generated for the particular user and issued for the particular client, with the specified
value of <code>scope</code> parameter, select the user from the <code>Evaluate</code> screen. This will generate an example token that includes all of the
claims and role mappings used.</p></div>
<h3>Client Scopes Permissions</h3><div class="paragraph"><p>When issuing tokens for a particular user, the client scope is applied only if the user is permitted to use it. In the case that
a client scope does not have any role scope mappings defined on itself, then each user is automatically permitted to use this
client scope. However, when a client scope has any role scope mappings defined on itself, then the user must be a member of at least
one of the roles. In other words, there must be an intersection between the user roles and the roles of the client scope. Composite
roles are taken into account when evaluating this intersection.</p></div>
<div class="paragraph"><p>If a user is not permitted to use the client scope, then no protocol mappers or role scope mappings will be used when generating tokens
and the client scope will not appear in the <em>scope</em> value in the token.</p></div>
<h3>Realm Default Client Scopes</h3><div class="paragraph"><p>The <code>Realm Default Client Scopes</code> allow you to define set of client scopes, which will be automatically linked to newly created clients.</p></div>
<div class="paragraph"><p>Open the left menu item <code>Client Scopes</code> and then select <code>Default Client Scopes</code>.</p></div>
<div class="paragraph"><p>From here, select the client scopes that you want to add as <code>Default Client Scopes</code> to newly created clients and <code>Optional Client Scopes</code>
to newly created clients.</p></div>
<div class="paragraph"><div class="title">Default Client Scopes</div><p><span class="image"><img src="rhsso-images/client-scopes-default.png" alt="client scopes default"></span></p></div>
<div class="paragraph"><p>Once the client is created, you can unlink the default client scopes, if needed. This is similar to how you
remove <a href="#_default_roles">Default Roles</a>.</p></div>
<h3>Scopes explained</h3><div class="paragraph"><p>The term <code>scope</code> is used in Red Hat Single Sign-On on few places. Various occurrences of scopes are related to each other, but may have
a different context and meaning. To clarify, here we explain the various <code>scopes</code> used in Red Hat Single Sign-On.</p></div>
<div class="dlist"><dl><dt class="hdlist1">Client scope</dt><dd><p>Referenced in this chapter. Client scopes are entities in Red Hat Single Sign-On, which are configured at the realm level and they can be
linked to clients. The client scopes are referenced by their name when a request is sent to the Red Hat Single Sign-On authorization endpoint
with a corresponding value of the <code>scope</code> parameter. The details are described in the <a href="#_client_scopes_linking">section about client scopes linking</a>.</p></dd><dt class="hdlist1">Role scope mapping</dt><dd><p>This can be seen when you open tab <code>Scope</code> of a client or client scope. Role scope mapping allows you to limit the roles which can
be used in the access tokens. The details are described in the <a href="#_role_scope_mappings">Role Scope Mappings section</a>.</p></dd></dl></div></section></section>
<section><section id="_roles"><h2>Roles</h2><div class="paragraph"><p>Roles identify a type or category of user.  <code>Admin</code>, <code>user</code>, <code>manager</code>, and <code>employee</code> are all typical roles that may exist
in an organization.
Applications often assign access and permissions to specific roles rather than individual users as dealing
with users can be too fine grained and hard to manage.  For example, the Admin Console has specific roles which give permission to users
to access parts of the Admin Console UI and perform certain actions.  There is a global namespace for roles and each client also has its own
dedicated namespace where roles can be defined.</p></div></section><section id="_realm_roles"><h2>Realm Roles</h2><div class="paragraph"><p>Realm-level roles are a global namespace to define your roles. You can see the list of built-in and created roles by clicking the <code>Roles</code> left menu item.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/roles.png" alt="roles"></span></p></div>
<div class="paragraph"><p>To create a role, click <strong>Add Role</strong> on this page, enter in the name and description of the role, and click <strong>Save</strong>.</p></div>
<div class="paragraph"><div class="title">Add Role</div><p><span class="image"><img src="rhsso-images/role.png" alt="role"></span></p></div>
<div class="paragraph"><p>The value for the <code>description</code> field is localizable by specifying a substitution variable with <code>${var-name}</code> strings. The localized
value is then configured within property files in your theme. See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more information
on localization.</p></div></section><section id="_client_roles"><h2>Client Roles</h2><div class="paragraph"><p>Client roles are basically a namespace dedicated to a client. Each client gets its own namespace. Client roles are managed under the <code>Roles</code> tab under each individual client. You interact with this UI the same way you do for realm-level roles.</p></div></section><section id="_composite-roles"><h2>Composite Roles</h2><div class="paragraph"><p>Any realm or client level role can be turned into a <em>composite role</em>.
A <em>composite role</em> is a role that has one or more additional roles associated with it.
When a composite role is mapped to the user, the user also gains the roles associated with that composite.  This inheritance
is recursive so any composite of composites also gets inherited.</p></div>
<div class="paragraph"><p>To turn a regular role into a composite role, go to the role detail page and flip the <code>Composite Role</code> switch on.</p></div>
<div class="paragraph"><div class="title">Composite Role</div><p><span class="image"><img src="rhsso-images/composite-role.png" alt="composite role"></span></p></div>
<div class="paragraph"><p>Once you flip this switch the role selection UI will be displayed lower on the page and you&#8217;ll be able to associate
realm level and client level roles to the composite you are creating.  In this example, the <code>employee</code> realm-level
role was associated with the <code>developer</code> composite role.  Any user with the <code>developer</code> role will now also inherit
the <code>employee</code> role too.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">When tokens and SAML assertions are created, any composite will also have its associated roles added to the claims and
      assertions of the authentication response sent back to the client.</td></tr></table></div></section><section id="_user_role_mappings"><h2>User Role Mappings</h2><div class="paragraph"><p>User role mappings can be assigned individually to each user through the <code>Role Mappings</code> tab for that single user.</p></div>
<div class="paragraph"><div class="title">Role Mappings</div><p><span class="image"><img src="rhsso-images/user-role-mappings.png" alt="user role mappings"></span></p></div>
<div class="paragraph"><p>In the above example, we are about to assign the composite role <code>developer</code> that was created in the <a href="#_composite-roles">Composite Roles</a>
chapter.</p></div>
<div class="paragraph"><div class="title">Effective Role Mappings</div><p><span class="image"><img src="rhsso-images/effective-role-mappings.png" alt="effective role mappings"></span></p></div>
<div class="paragraph"><p>Once the <code>developer</code> role is assigned, you see that the <code>employee</code> role that is associated with the <code>developer</code> composite shows up in the <code>Effective Roles</code>.
<code>Effective Roles</code> are all roles that are explicitly assigned to the user as well as any roles that are inherited from composites.</p></div>
<h3>Default Roles</h3><div class="paragraph"><p>Default roles allow you to automatically assign user role mappings when any user is newly created or imported through
<a href="#_identity_broker">Identity Brokering</a>.
To specify default roles go to the <code>Roles</code> left menu item, and click the <code>Default Roles</code> tab.</p></div>
<div class="paragraph"><div class="title">Default Roles</div><p><span class="image"><img src="rhsso-images/default-roles.png" alt="default roles"></span></p></div>
<div class="paragraph"><p>As you can see from the screenshot, there are already a number of <em>default roles</em> set up by default.</p></div></section><section id="_role_scope_mappings"><h2>Role Scope Mappings</h2><div class="paragraph"><p>When an OIDC access token or SAML assertion is created, all the user role mappings of the user are, by default, added as claims
within the token or assertion.  Applications use this information to make access decisions on the resources controlled by that
application.  In Red Hat Single Sign-On, access tokens are digitally signed and can actually be re-used by the application
to invoke on other remotely secured REST services.  This means that if an application gets compromised or there is a rogue
client registered with the realm, attackers can get access tokens that have a broad range of permissions and your whole
network is compromised.  This is where <em>role scope mappings</em> becomes important.</p></div>
<div class="paragraph"><p><em>Role Scope Mappings</em> is a way to limit the roles that get declared inside an access token.  When a client requests that a user
be authenticated, the access token they receive back will only contain the role mappings you&#8217;ve explicitly specified
for the client&#8217;s scope.  This allows you to limit the permissions each individual access token has rather than giving the
client access to all of the user&#8217;s permissions.  By default, each client gets all the role mappings of the user.
You can view this in the <code>Scope</code> tab of each client.</p></div>
<div class="paragraph"><div class="title">Full Scope</div><p><span class="image"><img src="rhsso-images/full-client-scope.png" alt="full client scope"></span></p></div>
<div class="paragraph"><p>You can see from the picture that the effective roles of the scope are every declared role in the realm.
To change this default behavior, you must explicitly turn off the <code>Full Scope Allowed</code> switch and declare the specific roles you want in each individual
client.  Alternatively, you can also use <a href="#_client_scopes">client scopes</a>
to define the same role scope mappings for a whole set of clients.</p></div>
<div class="paragraph"><div class="title">Partial Scope</div><p><span class="image"><img src="rhsso-images/client-scope.png" alt="client scope"></span></p></div></section></section>
<section><section id="_groups"><h2>Groups</h2><div class="paragraph"><p>Groups in Red Hat Single Sign-On allow you to manage a common set of attributes and role mappings for a set of users.
Users can be members of zero or more groups.
Users inherit the attributes and role mappings assigned to each group.  To manage groups go to the <code>Groups</code> left menu
item.</p></div><div class="paragraph"><div class="title">Groups</div><p><span class="image"><img src="rhsso-images/groups.png" alt="groups"></span></p></div><div class="paragraph"><p>Groups are hierarchical.
A group can have many subgroups, but a group can only have one parent.
Subgroups inherit the attributes and role mappings from the parent.
This applies to the user as well.
So, if you have a parent group and a child group and a user that only belongs to the child group, the user inherits the attributes and role mappings of both the parent and child.
In this example, we have a top level <code>Sales</code> group and a child <code>North America</code> subgroup.  To add a group, click on the
parent you want to add a new child to and click <code>New</code> button.  Select the <code>Groups</code> icon in the tree to make a top-level group.
Entering in a group name in the <code>Create Group</code> screen and hitting <code>Save</code> will bring you to the individual group management page.</p></div><div class="paragraph"><div class="title">Group</div><p><span class="image"><img src="rhsso-images/group.png" alt="group"></span></p></div><div class="paragraph"><p>The <code>Attributes</code> and <code>Role Mappings</code> tab work exactly as the tabs with similar names under a user.  Any attributes and role mappings
you define will be inherited by the groups and users that are members of this group.</p></div><div class="paragraph"><p>To add a user to a group you need to go all the way back to the user detail page and click on the <code>Groups</code> tab there.</p></div><div class="paragraph"><div class="title">User Groups</div><p><span class="image"><img src="rhsso-images/user-groups.png" alt="user groups"></span></p></div><div class="paragraph"><p>Select a group from the <code>Available Groups</code> tree and hit the <code>join</code> button to add the user to a group.  Vice versa to remove a group.
Here we&#8217;ve added the user <em>Jim</em> to the <em>North America</em> sales group.  If you go back to the detail page for that group and
select the <code>Membership</code> tab, <em>Jim</em> is now displayed there.</p></div><div class="paragraph"><div class="title">Group Membership</div><p><span class="image"><img src="rhsso-images/group-membership.png" alt="group membership"></span></p></div></section><section id="_groups_vs_roles"><h2>Groups vs. Roles</h2><div class="paragraph"><p>In the IT world the concepts of Group and Role are often blurred and interchangeable.
In Red Hat Single Sign-On, Groups are just a collection of users that you can apply roles and attributes to in one place.
Roles define a type of user and applications assign permission and access control to roles</p></div>
<div class="paragraph"><p>Aren&#8217;t <a href="#_composite-roles">Composite Roles</a> also similar to Groups?
Logically they provide the same exact functionality, but the difference is conceptual.
Composite roles should be used to apply the permission model to your set of services and applications.
Groups should focus on collections of users and their roles in your organization.
Use groups to manage users.  Use composite roles to manage applications and services.</p></div></section><section id="_default_groups"><h2>Default Groups</h2><div class="paragraph"><p>Default groups allow you to automatically assign group membership whenever any new user is created or imported through
<a href="#_identity_broker">Identity Brokering</a>.
To specify default groups go to the <code>Groups</code> left menu item, and click the <code>Default Groups</code> tab.</p></div>
<div class="paragraph"><div class="title">Default Groups</div><p><span class="image"><img src="rhsso-images/default-groups.png" alt="default groups"></span></p></div></section></section>
<section><section id="_admin_permissions"><h2>Admin Console Access Control and Permissions</h2><div class="paragraph"><p>Each realm created on the Red Hat Single Sign-On has a dedicated Admin Console from which that realm can be managed.
The <code>master</code> realm is a special realm that allows admins to manage more than one realm on the system.  You can also
define fine-grained access to users in different realms to manage the server.  This chapter goes over all the scenarios for this.</p></div></section><section id="_master_realm_access_control"><h2>Master Realm Access Control</h2><div class="paragraph"><p>The <code>master</code> realm in Red Hat Single Sign-On is a special realm and treated differently than other realms.
Users in the Red Hat Single Sign-On <code>master</code> realm can be granted permission to manage zero or more realms that are deployed on the Red Hat Single Sign-On server.
When a realm is created, Red Hat Single Sign-On automatically creates various roles that grant fine-grain permissions to access that new realm.
Access to The Admin Console and Admin REST endpoints can be controlled by mapping these roles to users in the <code>master</code> realm.
It&#8217;s possible to create multiple super users,  as well as users that can only manage specific realms.</p></div>
<h3>Global Roles</h3><div class="paragraph"><p>There are two realm-level roles in the <code>master</code> realm.
These are:</p></div>
<div class="ulist"><ul><li><p>admin</p></li><li><p>create-realm</p></li></ul></div>
<div class="paragraph"><p>Users with the <code>admin</code> role are super users and have full access to manage any realm on the server.  Users with the <code>create-realm</code> role
are allowed to create new realms.  They will be granted full access to any new realm they create.</p></div>
<h3>Realm Specific Roles</h3><div class="paragraph"><p>Admin users within the <code>master</code> realm can be granted management privileges to one or more other realms in the system.
Each realm in Red Hat Single Sign-On is represented by a client in the <code>master</code> realm.
The name of the client is <code>&lt;realm name&gt;-realm</code>.  These clients each have client-level roles defined which define varying
level of access to manage an individual realm.</p></div>
<div class="paragraph"><p>The roles available are:</p></div>
<div class="ulist"><ul><li><p>view-realm</p></li><li><p>view-users</p></li><li><p>view-clients</p></li><li><p>view-events</p></li><li><p>manage-realm</p></li><li><p>manage-users</p></li><li><p>create-client</p></li><li><p>manage-clients</p></li><li><p>manage-events</p></li><li><p>view-identity-providers</p></li><li><p>manage-identity-providers</p></li><li><p>impersonation</p></li></ul></div>
<div class="paragraph"><p>Assign the roles you want to your users and they will only be able to use that specific part of the administration console.</p></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">Admins with the <code>manage-users</code> role will only be able to assign admin roles to users that they themselves have.  So, if an admin has the <code>manage-users</code> role but doesn&#8217;t have the <code>manage-realm</code> role, they will not be able to assign this role.</td></tr></table></div></section><section id="_per_realm_admin_permissions"><h2>Dedicated Realm Admin Consoles</h2><div class="paragraph"><p>Each realm has a dedicated Admin Console that can be accessed by going to the url <code>/auth/admin/{realm-name}/console</code>.
Users within that realm can be granted realm management permissions by assigning specific user role mappings.</p></div>
<div class="paragraph"><p>Each realm has a built-in client called <code>realm-management</code>.  You can view this client by going to the
<code>Clients</code> left menu item of your realm.  This client defines client-level roles that specify permissions that can be granted to manage the realm.</p></div>
<div class="ulist"><ul><li><p>view-realm</p></li><li><p>view-users</p></li><li><p>view-clients</p></li><li><p>view-events</p></li><li><p>manage-realm</p></li><li><p>manage-users</p></li><li><p>create-client</p></li><li><p>manage-clients</p></li><li><p>manage-events</p></li><li><p>view-identity-providers</p></li><li><p>manage-identity-providers</p></li><li><p>impersonation</p></li></ul></div>
<div class="paragraph"><p>Assign the roles you want to your users and they will only be able to use that specific part of the administration console.</p></div></section><section id="_fine_grain_permissions"><h2>Fine Grain Admin Permissions</h2><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>Fine Grain Admin Permissions is <strong>Technology Preview</strong> and is not fully supported. This feature is disabled by default.</p></div>
<div class="paragraph"><p>To enable start the server with <code>-Dkeycloak.profile=preview</code>
or <code>-Dkeycloak.profile.feature.admin_fine_grained_authz=enabled</code>
. For more details see <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/#profiles">Profiles</a>.</p></div></td></tr></table></div>
<div class="paragraph"><p>Sometimes roles like <code>manage-realm</code> or <code>manage-users</code> are too coarse grain and you want to create
restricted admin accounts that have more fine grain permissions.  Red Hat Single Sign-On allows you to define
and assign restricted access policies for managing a realm.  Things like:</p></div>
<div class="ulist"><ul><li><p>Managing one specific client</p></li><li><p>Managing users that belong to a specific group</p></li><li><p>Managing membership of a group</p></li><li><p>Limited user management.</p></li><li><p>Fine grain impersonization control</p></li><li><p>Being able to assign a specific restricted set of roles to users.</p></li><li><p>Being able to assign a specific restricted set of roles to a composite role.</p></li><li><p>Being able to assign a specific restricted set of roles to a client&#8217;s scope.</p></li><li><p>New general policies for viewing and managing users, groups, roles, and clients.</p></li></ul></div>
<div class="paragraph"><p>There&#8217;s some important things to note about fine grain admin permissions:</p></div>
<div class="ulist"><ul><li><p>Fine grain admin permissions were implemented on top of <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/authorization_services_guide/">Authorization Services</a>.  It is highly recommended that you read up on those features before diving into fine grain permissions.</p></li><li><p>Fine grain permissions are only available within <a href="#_per_realm_admin_permissions">dedicated admin consoles</a> and admins defined within those realms.  You cannot define cross-realm fine grain permissions.</p></li><li><p>Fine grain permissions are used to grant additional permissions.  You cannot override the
default behavior of the built in admin roles.</p></li></ul></div>
<h3>Managing One Specific Client</h3><div class="paragraph"><p>Let&#8217;s look first at allowing
an admin to manage one client and one client only.  In our example we have a realm
called <code>test</code> and a client called <code>sales-application</code>.  In realm <code>test</code> we will give a
user in that realm permission to only manage that application.</p></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">You cannot do cross realm fine grain permissions.  Admins in the <code>master</code> realm are limited to the predefined admin roles defined in previous chapters.</td></tr></table></div>
<h4>Permission Setup</h4><div class="paragraph"><p>The first thing we must do is login to the Admin Console so we can set up permissions for that client.  We navigate to the management section
of the client we want to define fine-grain permissions for.</p></div>
<div class="paragraph"><div class="title">Client Management</div><p><span class="image"><img src="rhsso-images/fine-grain-client.png" alt="fine grain client"></span></p></div>
<div class="paragraph"><p>You should see a tab menu item called <code>Permissions</code>.  Click on that tab.</p></div>
<div class="paragraph"><div class="title">Client Permissions Tab</div><p><span class="image"><img src="rhsso-images/fine-grain-client-permissions-tab-off.png" alt="fine grain client permissions tab off"></span></p></div>
<div class="paragraph"><p>By default, each client is not enabled to do fine grain permissions.  So turn the <code>Permissions Enabled</code> switch to on
to initialize permissions.</p></div>
<div class="admonitionblock important"><table><tr><td class="icon"><div class="title">Important</div></td><td class="content">If you turn the <code>Permissions Enabled</code> switch to off, it will delete any and all permissions you have defined for this client.</td></tr></table></div>
<div class="paragraph"><div class="title">Client Permissions Tab</div><p><span class="image"><img src="rhsso-images/fine-grain-client-permissions-tab-on.png" alt="fine grain client permissions tab on"></span></p></div>
<div class="paragraph"><p>When you switch <code>Permissions Enabled</code> to on, it initializes various permission objects behind the scenes
using <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/authorization_services_guide/">Authorization Services</a>.  For this example, we&#8217;re
interested in the <code>manage</code> permission for the client.  Clicking on that will redirect you
to the permission that handles the <code>manage</code> permission for the client.  All authorization
objects are contained in the <code>realm-management</code> client&#8217;s <code>Authorization</code> tab.</p></div>
<div class="paragraph"><div class="title">Client Manage Permission</div><p><span class="image"><img src="rhsso-images/fine-grain-client-manage-permissions.png" alt="fine grain client manage permissions"></span></p></div>
<div class="paragraph"><p>When first initialized the <code>manage</code> permission does not have any policies associated with it.
You will need to create one by going to the policy tab.  To get there fast, click on
the <code>Authorization</code> link shown in the above image. Then click on the policies tab.</p></div>
<div class="paragraph"><p>There&#8217;s a pull down menu on this page called <code>Create policy</code>.  There&#8217;s a multitude of policies
you can define.  You can define a policy that is associated with a role or a group or even define
rules in JavaScript.  For this simple example, we&#8217;re going to create a <code>User Policy</code>.</p></div>
<div class="paragraph"><div class="title">User Policy</div><p><span class="image"><img src="rhsso-images/fine-grain-client-user-policy.png" alt="fine grain client user policy"></span></p></div>
<div class="paragraph"><p>This policy will match a hard-coded user in the user database.  In this case it is the <code>sales-admin</code> user.  We must then go back to the
<code>sales-application</code> client&#8217;s <code>manage</code> permission page and assign the policy to the permission object.</p></div>
<div class="paragraph"><div class="title">Assign User Policy</div><p><span class="image"><img src="rhsso-images/fine-grain-client-assign-user-policy.png" alt="fine grain client assign user policy"></span></p></div>
<div class="paragraph"><p>The <code>sales-admin</code> user can now has permission to manage the <code>sales-application</code> client.</p></div>
<div class="paragraph"><p>There&#8217;s one more thing we have to do.  Go to the <code>Role Mappings</code> tab and assign the <code>query-clients</code>
role to the <code>sales-admin</code>.</p></div>
<div class="paragraph"><div class="title">Assign query-clients</div><p><span class="image"><img src="rhsso-images/fine-grain-assign-query-clients.png" alt="fine grain assign query clients"></span></p></div>
<div class="paragraph"><p>Why do you have to do this?  This role tells the Admin Console
what menu items to render when the <code>sales-admin</code> visits the Admin Console.  The <code>query-clients</code>
role tells the Admin Console that it should render client menus for the <code>sales-admin</code> user.</p></div>
<div class="paragraph"><p>IMPORTANT If you do not set the <code>query-clients</code> role, restricted admins like <code>sales-admin</code> will not see any menu options when they log into the Admin Console</p></div>
<h4>Testing It Out.</h4><div class="paragraph"><p>Next we log out of the master realm and re-login to the <a href="#_per_realm_admin_permissions">dedicated admin console</a> for the <code>test</code> realm
using the <code>sales-admin</code> as a username.  This is located under <code>/auth/admin/test/console</code>.</p></div>
<div class="paragraph"><div class="title">Sales Admin Login</div><p><span class="image"><img src="rhsso-images/fine-grain-sales-admin-login.png" alt="fine grain sales admin login"></span></p></div>
<div class="paragraph"><p>This admin is now able to manage this one client.</p></div>
<h3>Restrict User Role Mapping</h3><div class="paragraph"><p>Another thing you might want to do is to restrict the set a roles an admin is allowed
to assign to a user.  Continuing our last example, let&#8217;s expand the permission set of the 'sales-admin'
user so that he can also control which users are allowed to access this application.  Through fine grain permissions we can
enable it so that the <code>sales-admin</code> can only assign roles that grant specific access to
the <code>sales-application</code>.  We can also restrict it so that the admin can only map roles
and not perform any other types of user administration.</p></div>
<div class="paragraph"><p>The <code>sales-application</code> has defined three different client roles.</p></div>
<div class="paragraph"><div class="title">Sales Application Roles</div><p><span class="image"><img src="rhsso-images/fine-grain-sales-application-roles.png" alt="fine grain sales application roles"></span></p></div>
<div class="paragraph"><p>We want the <code>sales-admin</code> user to be able to map these roles to any user in the system.  The
first step to do this is to allow the role to be mapped by the admin.  If we click on the
<code>viewLeads</code> role, you&#8217;ll see that there is a <code>Permissions</code> tab for this role.</p></div>
<div class="paragraph"><div class="title">View Leads Role Permission Tab</div><p><span class="image"><img src="rhsso-images/fine-grain-view-leads-role-tab.png" alt="fine grain view leads role tab"></span></p></div>
<div class="paragraph"><p>If we click on that tab and turn the <code>Permissions Enabled</code> on, you&#8217;ll see that there
are a number of actions we can apply policies to.</p></div>
<div class="paragraph"><div class="title">View Leads Permissions</div><p><span class="image"><img src="rhsso-images/fine-grain-view-leads-permissions.png" alt="fine grain view leads permissions"></span></p></div>
<div class="paragraph"><p>The one we are interested in is <code>map-role</code>.  Click on this permission and add the same
User Policy that was created in the earlier example.</p></div>
<div class="paragraph"><div class="title">Map-roles Permission</div><p><span class="image"><img src="rhsso-images/fine-grain-map-roles-permission.png" alt="fine grain map roles permission"></span></p></div>
<div class="paragraph"><p>What we&#8217;ve done is say that the <code>sales-admin</code> can map the <code>viewLeads</code> role.  What we have
not done is specify which users the admin is allowed to map this role too.  To do that
we must go to the <code>Users</code> section of the admin console for this realm.  Clicking on the
<code>Users</code> left menu item brings us to the users interface of the realm.  You should see a
<code>Permissions</code> tab.  Click on that and enable it.</p></div>
<div class="paragraph"><div class="title">Users Permissions</div><p><span class="image"><img src="rhsso-images/fine-grain-users-permissions.png" alt="fine grain users permissions"></span></p></div>
<div class="paragraph"><p>The permission we are interested in is <code>map-roles</code>.  This is a restrictive policy
in that it only allows admins the ability to map roles to a user.  If we click on the
<code>map-roles</code> permission and again add the User Policy we created for this, our <code>sales-admin</code>
will be able to map roles to any user.</p></div>
<div class="paragraph"><p>The last thing we have to do is add the <code>view-users</code> role to the <code>sales-admin</code>.  This will
allow the admin to view users in the realm he wants to add the <code>sales-application</code> roles to.</p></div>
<div class="paragraph"><div class="title">Add view-users</div><p><span class="image"><img src="rhsso-images/fine-grain-add-view-users.png" alt="fine grain add view users"></span></p></div>
<h4>Testing It Out.</h4><div class="paragraph"><p>Next we log out of the master realm and re-login to the <a href="#_per_realm_admin_permissions">dedicated admin console</a> for the <code>test</code> realm
using the <code>sales-admin</code> as a username.  This is located under <code>/auth/admin/test/console</code>.</p></div>
<div class="paragraph"><p>You will see that now the <code>sales-admin</code> can view users in the system.  If you select one of the
users you&#8217;ll see that each user detail page is read only, except for the <code>Role Mappings</code> tab.
Going to these tab you&#8217;ll find that there are no <code>Available</code> roles for the admin to
map to the user except when we browse the <code>sales-application</code> roles.</p></div>
<div class="paragraph"><div class="title">Add viewLeads</div><p><span class="image"><img src="rhsso-images/fine-grain-add-view-leads.png" alt="fine grain add view leads"></span></p></div>
<div class="paragraph"><p>We&#8217;ve only specified that the <code>sales-admin</code> can map the <code>viewLeads</code> role.</p></div>
<h4>Per Client map-roles Shortcut</h4><div class="paragraph"><p>It would be tedious if we had to do this for every client role that the <code>sales-application</code> published.
to make things easier, there&#8217;s a way to specify that an admin can map any role defined
by a client.  If we log back into the admin console to our master realm admin and go back
  to the <code>sales-application</code> permissions page, you&#8217;ll see the <code>map-roles</code> permission.</p></div>
<div class="paragraph"><div class="title">Client map-roles Permission</div><p><span class="image"><img src="rhsso-images/fine-grain-client-permissions-tab-on.png" alt="fine grain client permissions tab on"></span></p></div>
<div class="paragraph"><p>If you grant access to this particular parmission to an admin, that admin will be able
map any role defined by the client.</p></div>
<h3>Full List of Permissions</h3><div class="paragraph"><p>You can do a lot more with fine grain permissions beyond managing a specific client or the specific roles of a client.
This chapter defines the whole list of permission types that can be described for
a realm.</p></div>
<h4>Role</h4><div class="paragraph"><p>When going to the <code>Permissions</code> tab for a specific role, you will see these
permission types listed.</p></div>
<div class="dlist"><dl><dt class="hdlist1">map-role</dt><dd><p>Policies that decide if an admin can map this role to a user.  These policies
only specify that the role can be mapped to a user, not that the admin is allowed
to perform user role mapping tasks.  The admin will also have to have manage or
role mapping permissions.  See <a href="#_users-permissions">Users Permissions</a> for more information.</p></dd><dt class="hdlist1">map-role-composite</dt><dd><p>Policies that decide if an admin can map this role as a composite to another role.
An admin can define roles for a client if he has manage permissions for that client
but he will not be able to add composites to those roles unless he has the
<code>map-role-composite</code> privileges for the role he wants to add as a composite.</p></dd><dt class="hdlist1">map-role-client-scope</dt><dd><p>Policies that decide if an admin can apply this role to the scope of a client.
Even if the admin can manage the client, he will not have permission to
create tokens for that client that contain this role unless this privilege
is granted.</p></dd></dl></div>
<h4>Client</h4><div class="paragraph"><p>When going to the <code>Permissions</code> tab for a specific client, you will see these
permission types listed.</p></div>
<div class="dlist"><dl><dt class="hdlist1">view</dt><dd><p>Policies that decide if an admin can view the client&#8217;s configuration.</p></dd><dt class="hdlist1">manage</dt><dd><p>Policies that decide if an admin can view and manage the client&#8217;s configuration.
There is some issues with this in that privileges could be leaked unintentionally.
For example, the admin could define a protocol mapper that hardcoded a role
even if the admin does not have privileges to map the role to the client&#8217;s scope.
This is currently the limitation of protocol mappers as they don&#8217;t have a way
to assign individual permissions to them like roles do.</p></dd><dt class="hdlist1">configure</dt><dd><p>Reduced set of prileges to manage the client.  Its like the <code>manage</code> scope except
the admin is not allowed to define protocol mappers, change the client template,
or the client&#8217;s scope.</p></dd><dt class="hdlist1">map-roles</dt><dd><p>Policies that decide if an admin can map any role defined by the client to a user.
This is a shortcut, easy-of-use feature to avoid having to defin policies
for each and every role defined by the client.</p></dd><dt class="hdlist1">map-roles-composite</dt><dd><p>Policies that decide if an admin can map any role defined by the client
as a composite to another role.
This is a shortcut, easy-of-use feature to avoid having to define policies
for each and every role defined by the client.</p></dd><dt class="hdlist1">map-roles-client-scope</dt><dd><p>Policies that decide if an admin can map any role defined by the client
to the scope of another client.
This is a shortcut, easy-of-use feature to avoid having to define policies
for each and every role defined by the client.</p></dd></dl></div>
<h4>Users</h4><div class="paragraph"><p>When going to the <code>Permissions</code> tab for all users, you will see these
permission types listed.</p></div>
<div class="dlist"><dl><dt class="hdlist1">view</dt><dd><p>Policies that decide if an admin can view all users in the realm.</p></dd><dt class="hdlist1">manage</dt><dd><p>Policies that decide if an admin can manage all users in the realm.  This
permission grants the admin the privilege to perfor user role mappings, but
it does not specify which roles the admin is allowed to map.  You&#8217;ll need to
define the privilege for each role you want the admin to be able to map.</p></dd><dt class="hdlist1">map-roles</dt><dd><p>This is a subset of the privileges granted by the <code>manage</code> scope.  In this
case the admin is only allowed to map roles.  The admin is not allowed to perform
any other user management operation.  Also, like <code>manage</code>, the roles that the
admin is allowed to apply must be specified per role or per set of roles if dealing
with client roles.</p></dd><dt class="hdlist1">manage-group-membership</dt><dd><p>Similar to <code>map-roles</code> except that it pertains to group membership: which
groups a user can be added or removed from.  These
policies just grant the admin permission to manage group membership, not which
groups the admin is allowed to manage membership for.  You&#8217;ll have to
specify policies for each group&#8217;s <code>manage-members</code> permission.</p></dd><dt class="hdlist1">impersonate</dt><dd><p>Policies that decide if the admin is allowed to impersonate other users.  These
policies are applied to the admin&#8217;s attributes and role mappings.</p></dd><dt class="hdlist1">user-impersonated</dt><dd><p>Policies that decide which users can be impersonated.  These policies will be
applied to the user being impersonated.  For example, you might want to define
a policy that will forbid anybody from impersonating a user that has admin
privileges.</p></dd></dl></div>
<h4>Group</h4><div class="paragraph"><p>When going to the <code>Permissions</code> tab for a specific group, you will see these
permission types listed.</p></div>
<div class="dlist"><dl><dt class="hdlist1">view</dt><dd><p>Policies that decide if the admin can view information about the group.</p></dd><dt class="hdlist1">manage</dt><dd><p>Policies that decide if the admin can manage the configuration of the group.</p></dd><dt class="hdlist1">view-members</dt><dd><p>Policies that decide if the admin can view the user details of members of the group.</p></dd><dt class="hdlist1">manage-members</dt><dd><p>Policies that decide if the admin can manage the users that belong to this group.</p></dd><dt class="hdlist1">manage-membership</dt><dd><p>Policies that decide if an admin can change the membership of the group.  Add or
remove members from the group.</p></dd></dl></div></section><section id="realm_keys"><h2>Realm Keys</h2><div class="paragraph"><p>The authentication protocols that are used by Red Hat Single Sign-On require cryptographic signatures and sometimes
encryption.  Red Hat Single Sign-On uses asymmetric key pairs, a private and public key, to accomplish this.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On has a single active keypair at a time, but can have several passive keys as well. The active keypair
is used to create new signatures, while the passive keypairs can be used to verify previous signatures. This makes it
possible to regularly rotate the keys without any downtime or interruption to users.</p></div>
<div class="paragraph"><p>When a realm is created a key pair and a self-signed certificate is automatically generated.</p></div>
<div class="paragraph"><p>To view the active keys for a realm select the realm in the admin console click on <code>Realm settings</code> then <code>Keys</code>. This
will show the currently active keys for the realm. Red Hat Single Sign-On currently only supports RSA signatures so there
is only one active keypair. In the future as more signature algorithms are added there will be more active keypairs.</p></div>
<div class="paragraph"><p>To view all available keys select <code>All</code>. This will show all active, passive and disabled keys. A keypair can have the
status <code>Active</code>, but still not be selected as the currently active keypair for the realm. The selected active pair which
is used for signatures is selected based on the first key provider sorted by priority that is able to provide an
 active keypair.</p></div>
<h3>Rotating keys</h3><div class="paragraph"><p>It&#8217;s recommended to regularly rotate keys. To do so you should start by creating new keys with a higher priority than
the existing active keys. Or create new keys with the same priority and making the previous keys passive.</p></div>
<div class="paragraph"><p>Once new keys are available all new tokens and cookies will be signed with the new keys. When a user authenticates to an
application the SSO cookie is updated with the new signature. When OpenID Connect tokens are refreshed new tokens are
signed with the new keys. This means that over time all cookies and tokens will use the new keys and after a while the
old keys can be removed.</p></div>
<div class="paragraph"><p>How long you wait to delete old keys is a tradeoff between security and making sure all cookies and tokens are updated.
In general it should be acceptable to drop old keys after a few weeks. Users that have not been active in the period
between the new keys where added and the old keys removed will have to re-authenticate.</p></div>
<div class="paragraph"><p>This also applies to offline tokens. To make sure they are updated the applications need to refresh the tokens before
the old keys are removed.</p></div>
<div class="paragraph"><p>As a guideline, it may be a good idea to create new keys every 3-6 months and delete old keys 1-2 months after the new
keys were created.</p></div>
<h3>Adding a generated keypair</h3><div class="paragraph"><p>To add a new generated keypair select <code>Providers</code> and choose <code>rsa-generated</code> from the dropdown. You can change the priority
to make sure the new keypair becomes the active keypair. You can also change the <code>keysize</code> if you want smaller or larger keys (default is 2048,
supported values are 1024, 2048 and 4096).</p></div>
<div class="paragraph"><p>Click <code>Save</code> to add the new keys. This will generated a new keypair including a self-signed certificate.</p></div>
<div class="paragraph"><p>Changing the priority for a provider will not cause the keys to be re-generated, but if you want to change the keysize
you can edit the provider and new keys will be generated.</p></div>
<h3>Adding an existing keypair and certificate</h3><div class="paragraph"><p>To add a keypair and certificate obtained elsewhere select <code>Providers</code> and choose <code>rsa</code> from the dropdown. You can change
the priority to make sure the new keypair becomes the active keypair.</p></div>
<div class="paragraph"><p>Click on <code>Select file</code> for <code>Private RSA Key</code> to upload your private key. The file should be encoded in PEM format. You
don&#8217;t need to upload the public key as it is automatically extracted from the private key.</p></div>
<div class="paragraph"><p>If you have a signed certificate for the keys click on <code>Select file</code> next to <code>X509 Certificate</code>. If you don&#8217;t have one
 you can skip this and a self-signed certificate will be generated.</p></div>
<h3>Loading keys from a Java Keystore</h3><div class="paragraph"><p>To add a keypair and certificate stored in a Java Keystore file on the host select <code>Providers</code> and choose <code>java-keystore</code>
from the dropdown. You can change the priority to make sure the new keypair becomes the active keypair.</p></div>
<div class="paragraph"><p>Fill in the values for <code>Keystore</code>, <code>Keystore Password</code>, <code>Key Alias</code> and <code>Key Password</code> and click on <code>Save</code>.</p></div>
<h3>Making keys passive</h3><div class="paragraph"><p>Locate the keypair in <code>Active</code> or <code>All</code> then click on the provider in the <code>Provider</code> column. This will take you to the
configuration screen for the key provider for the keys. Click on <code>Active</code> to turn it <code>OFF</code>, then click on <code>Save</code>. The
keys will no longer be active and can only be used for verifying signatures.</p></div>
<h3>Disabling keys</h3><div class="paragraph"><p>Locate the keypair in <code>Active</code> or <code>All</code> then click on the provider in the <code>Provider</code> column. This will take you to the
configuration screen for the key provider for the keys. Click on <code>Enabled</code> to turn it <code>OFF</code>, then click on <code>Save</code>. The
keys will no longer be enabled.</p></div>
<div class="paragraph"><p>Alternatively, you can delete the provider from the <code>Providers</code> table.</p></div>
<h3>Compromised keys</h3><div class="paragraph"><p>Red Hat Single Sign-On has the signing keys stored just locally and they are never shared with the client applications, users or other
entities. However if you think that your realm signing key was compromised, you should first generate new keypair as described above and
then immediatelly remove the compromised keypair.</p></div>
<div class="paragraph"><p>Then to ensure that client applications won&#8217;t accept the tokens signed by the compromised key, you should update and push not-before policy for
the realm, which is doable from the admin console. Pushing new policy will ensure that client applications won&#8217;t accept the existing
tokens signed by the compromised key, but also the client application will be forced to download new keypair from the Red Hat Single Sign-On, hence
the tokens signed by the compromised key won&#8217;t be valid anymore. Note that your REST and confidential clients must have set <code>Admin URL</code>, so that
Red Hat Single Sign-On is able to send them the request about pushed not-before policy.</p></div></section></section>
<section><section id="_identity_broker"><h2>Identity Brokering</h2><div class="paragraph"><p>An Identity Broker is an intermediary service that connects multiple service providers with different identity providers.
As an intermediary service, the identity broker is responsible for creating
a trust relationship with an external identity provider in order to use its identities to access internal services exposed by service providers.</p></div><div class="paragraph"><p>From a user perspective, an identity broker provides a user-centric and centralized way to manage identities across different security
domains or realms. An existing account can be linked with one or more identities from different identity providers or even created
based on the identity information obtained from them.</p></div><div class="paragraph"><p>An identity provider is usually based on a specific protocol that is used to authenticate and communicate authentication and authorization information to their users.
It can be a social provider such as Facebook, Google or Twitter.  It can be a business partner whose users need to access your services. Or it can be a cloud-based identity
service that you want to integrate with.</p></div><div class="paragraph"><p>Usually, identity providers are based on the following protocols:</p></div><div class="ulist"><ul><li><p><code>SAML v2.0</code></p></li><li><p><code>OpenID Connect v1.0</code></p></li><li><p><code>OAuth v2.0</code></p></li></ul></div><div class="paragraph"><p>In the next sections we&#8217;ll see how to configure and use Red Hat Single Sign-On as an identity broker, covering some important aspects such as:</p></div><div class="ulist"><ul><li><p><code>Social Authentication</code></p></li><li><p><code>OpenID Connect v1.0 Brokering</code></p></li><li><p><code>SAML v2.0 Brokering</code></p></li><li><p><code>Identity Federation</code></p></li></ul></div></section><section id="_identity_broker_overview"><h2>Brokering Overview</h2><div class="paragraph"><p>When using Red Hat Single Sign-On as an identity broker, users are not forced to provide their credentials in order to authenticate in a specific realm.
Instead, they are presented with a list of identity providers from which they can authenticate.</p></div>
<div class="paragraph"><p>You can also configure a default identity provider. In this case the user will not be given a choice, but will instead be redirected directly to the default provider.</p></div>
<div class="paragraph"><p>The following diagram demonstrates the steps involved when using Red Hat Single Sign-On to broker an external identity provider:</p></div>
<div class="paragraph"><div class="title">Identity Broker Flow</div><p><span class="image"><img src="images/identity_broker_flow.png" alt="identity broker flow"></span></p></div>
<div class="olist arabic"><ol class="arabic"><li><p>User is not authenticated and requests a protected resource in a client application.</p></li><li><p>The client applications redirects the user to Red Hat Single Sign-On to authenticate.</p></li><li><p>At this point the user is presented with the login page where there is a list of identity providers configured in a realm.</p></li><li><p>User selects one of the identity providers by clicking on its respective button or link.</p></li><li><p>Red Hat Single Sign-On issues an authentication request to the target identity provider asking for authentication and the user
is redirected to the login page of the identity provider.
The connection properties and other configuration options for the identity provider were previously set by the administrator in the Admin Console.</p></li><li><p>User provides his credentials or consent in order to authenticate with the identity provider.</p></li><li><p>Upon a successful authentication by the identity provider, the user is redirected back to Red Hat Single Sign-On with an authentication response.
Usually this response contains a security token that will be used by Red Hat Single Sign-On to trust the authentication performed by the identity provider
and retrieve information about the user.</p></li><li><p>Now Red Hat Single Sign-On is going to check if the response from the identity provider is valid.
If valid, it will import and create a new user or just skip that if the user already exists.
If it is a new user, Red Hat Single Sign-On may ask the identity provider for information about the user if that info doesn&#8217;t already exist in the token.
This is what we call <em>identity federation</em>.
If the user already exists Red Hat Single Sign-On may ask him to link the identity returned from the identity provider with the existing account.
We call this process <em>account linking</em>.
What exactly is done is configurable and can be specified by setup of <a href="#_identity_broker_first_login">First Login Flow</a>. At the end of this step, Red Hat Single Sign-On authenticates the user and issues its own token in order to access the requested resource in the service provider.</p></li><li><p>Once the user is locally authenticated, Red Hat Single Sign-On redirects the user to the service provider by sending the token previously issued during the local authentication.</p></li><li><p>The service provider receives the token from Red Hat Single Sign-On and allows access to the protected resource.</p></li></ol></div>
<div class="paragraph"><p>There are some variations of this flow that we will talk about later.
For instance, instead of presenting a list of identity providers, the client application can request a specific one.
Or you can tell Red Hat Single Sign-On to force the user to provide additional information before federating his identity.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Different protocols may require different authentication flows.
      At this moment, all the identity providers supported by Red Hat Single Sign-On use a flow just like described above.
      However, regardless of the protocol in use, user experience should be pretty much the same.</td></tr></table></div>
<div class="paragraph"><p>As you may notice, at the end of the authentication process Red Hat Single Sign-On will always issue its own token to client applications.
What this means is that client applications are completely decoupled from external identity providers.
They don&#8217;t need to know which protocol (eg.: SAML, OpenID Connect, OAuth, etc) was used or how the user&#8217;s identity was validated.
They only need to know about Red Hat Single Sign-On.</p></div></section><section id="default_identity_provider"><h2>Default Identity Provider</h2><div class="paragraph"><p>It is possible to automatically redirect to a identity provider instead of displaying the login form. To enable this go to the <code>Authentication</code> page in the administration console and select the <code>Browser</code> flow. Then click on config for the <code>Identity Provider Redirector</code> authenticator. Set <code>Default Identity Provider</code> to the alias of the identity provider you want to automatically redirect users to.</p></div>
<div class="paragraph"><p>If the configured default identity provider is not found the login form will be displayed instead.</p></div>
<div class="paragraph"><p>This authenticator is also responsible for dealing with the <code>kc_idp_hint</code> query parameter. See <a href="#_client_suggested_idp">client suggested identity provider</a> section for more details.</p></div></section><section id="_general-idp-config"><h2>General Configuration</h2><div class="paragraph"><p>The identity broker configuration is all based on identity providers.
Identity providers are created for each realm and by default they are enabled for every single application.
That means that users from a realm can use any of the registered identity providers when signing in to an application.</p></div>
<div class="paragraph"><p>In order to create an identity provider click the <code>Identity Providers</code> left menu item.</p></div>
<div class="paragraph"><div class="title">Identity Providers</div><p><span class="image"><img src="rhsso-images/identity-providers.png" alt="identity providers"></span></p></div>
<div class="paragraph"><p>In the drop down list box, choose the identity provider you want to add.  This will bring you to the
configuration page for that identity provider type.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/add-identity-provider.png" alt="add identity provider"></span></p></div>
<div class="paragraph"><p>Above is an example of configuring a Google social login provider.  Once you configure an IDP, it will appear on the Red Hat Single Sign-On
login page as an option.</p></div>
<div class="paragraph"><div class="title">IDP login page</div><p><span class="image"><img src="rhsso-images/identity-provider-login-page.png" alt="identity provider login page"></span></p></div>
<div class="dlist"><dl><dt class="hdlist1">Social</dt><dd><p>Social providers allow you to enable social authentication in your realm.
Red Hat Single Sign-On makes it easy to let users log in to your application using an existing account with a social network.
Currently supported providers include: Twitter, Facebook, Google, LinkedIn, Instagram, Microsoft, PayPal, Openshift v3, GitHub, GitLab, Bitbucket, and Stack Overflow.</p></dd><dt class="hdlist1">Protocol-based</dt><dd><p>Protocol-based providers are those that rely on a specific protocol in order to authenticate and authorize users.
They allow you to connect to any identity provider compliant with a specific protocol.
Red Hat Single Sign-On provides support for SAML v2.0 and OpenID Connect v1.0 protocols.
It makes it easy to configure and broker any identity provider based on these open standards.</p></dd></dl></div>
<div class="paragraph"><p>Although each type of identity provider has its own configuration options, all of them share some very common configuration.
Regardless of which identity provider you are creating, you&#8217;ll see the following configuration options available:</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 1. Common Configuration</caption><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Configuration</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Alias</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The alias is a unique identifier for an identity provider. It is used to reference an identity provider internally.
 Some protocols such as OpenID Connect require a redirect URI or callback url in order to communicate with an identity provider.
 In this case, the alias is used to build the redirect URI.
 Every single identity provider must have an alias. Examples are <code>facebook</code>, <code>google</code>, <code>idp.acme.com</code>, etc.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Enabled</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Turn the provider on/off.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Hide on Login Page</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">When this switch is on, this provider will not be shown as a login option on the login page.  Clients can still request to use this provider by using the 'kc_idp_hint' parameter in the URL they use to request a login.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Account Linking Only</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">When this switch is on, this provider cannot be used to login users and will not be shown as an option on the login page.  Existing accounts can still be linked with this provider though.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Store Tokens</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not to store the token received from the identity provider.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Stored Tokens Readable</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not users are allowed to retrieve the stored identity provider token.  This also applies to the <em>broker</em> client-level
 role <em>read token</em>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Trust Email</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If the identity provider supplies an email address this email address will be trusted.  If the realm required email validation,
 users that log in from this IDP will not have to go through the email verification process.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">GUI Order</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The order number that sorts how the available IDPs are listed on the login page.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">First Login Flow</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This is the authentication flow that will be triggered for users that log into Red Hat Single Sign-On through this IDP
 for the first time ever.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Post Login Flow</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Authentication flow that is triggered after the user finishes logging in with the external identity provider.</p></td></tr></table></section><section id="_social_identity_providers"><h2>Social Identity Providers</h2><div class="paragraph"><p>For Internet facing applications, it is quite burdensome for users to have to register at your site to obtain access.
It requires them to remember yet another username and password combination.  Social identity providers allow you to delegate
authentication to a semi-trusted and respected entity where the user probably already has an account.
Red Hat Single Sign-On provides built-in support for the most common social networks out there, such as Google, Facebook, Twitter, GitHub, LinkedIn, Microsoft and Stack Overflow.</p></div>
<h3>Bitbucket</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with Bitbucket.</p></div>
<div class="paragraph"><p>First, open the <code>Identity Providers</code> left menu item and select <code>Bitbucket</code> from the <code>Add provider</code> drop down list. This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/bitbucket-add-identity-provider.png" alt="bitbucket add identity provider"></span></p></div>
<div class="paragraph"><p>Before you can click <code>Save</code>, you must obtain a <code>Client ID</code> and <code>Client Secret</code> from Bitbucket.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">You will use the <code>Redirect URI</code> from this page in a later step, which you will provide to Bitbucket when you register Red Hat Single Sign-On as a client there.</td></tr></table></div>
<div class="paragraph"><div class="title">Add a New App</div><p>To enable login with Bitbucket you must first register an application project in
<a href="https://confluence.atlassian.com/bitbucket/oauth-on-bitbucket-cloud-238027431.html">OAuth on Bitbucket Cloud</a>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Bitbucket often changes the look and feel of application registration, so what you see on the Bitbucket site may differ. If in doubt, see the Bitbucket documentation.</td></tr></table></div>
<div class="paragraph"><p><span class="image"><img src="images/bitbucket-developer-applications.png" alt="bitbucket developer applications"></span></p></div>
<div class="paragraph"><p>Click the <code>Add consumer</code> button.</p></div>
<div class="paragraph"><div class="title">Register App</div><p><span class="image"><img src="images/bitbucket-register-app.png" alt="bitbucket register app"></span></p></div>
<div class="paragraph"><p>Copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page and enter it into the Callback URL field on the Bitbucket Add OAuth Consumer page.</p></div>
<div class="paragraph"><p>On the same page, mark the <code>Email</code> and <code>Read</code> boxes under <code>Account</code> to allow your application to read user email.</p></div>
<div class="paragraph"><div class="title">Bitbucket App Page</div><p><span class="image"><img src="images/bitbucket-app-page.png" alt="bitbucket app page"></span></p></div>
<div class="paragraph"><p>When you are done registering, click <code>Save</code>. This will open the application management page in Bitbucket. Find the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code>Add identity provider</code> page. Click <code>Save</code>.</p></div>
<h3>Facebook</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with Facebook.  First, go to the <code>Identity Providers</code> left menu item
and select <code>Facebook</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/facebook-add-identity-provider.png" alt="facebook add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from Facebook.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to Facebook when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with Facebook you first have to create a project and a client in the <a href="https://developers.facebook.com/">Facebook Developer Console</a>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Facebook often changes the look and feel of the Facebook Developer Console, so these directions might not always be up to date and the
      configuration steps might be slightly different.</td></tr></table></div>
<div class="paragraph"><p>Once you&#8217;ve logged into the console there is a pull down menu in the top right corner of the screen that says <code>My Apps</code>.  Select the <code>Add a New App</code>
menu item.</p></div>
<div class="paragraph"><div class="title">Add a New App</div><p><span class="image"><img src="images/facebook-add-new-app.png" alt="facebook add new app"></span></p></div>
<div class="paragraph"><p>Select the <code>Website</code> icon.  Click the <code>Skip and Create App ID</code> button.</p></div>
<div class="paragraph"><div class="title">Create a New App ID</div><p><span class="image"><img src="images/facebook-create-app-id.png" alt="facebook create app id"></span></p></div>
<div class="paragraph"><p>The email address and app category are required fields.  Once you&#8217;re done with that, you will be brought to the dashboard
for the application.  Click the <code>Settings</code> left menu item.</p></div>
<div class="paragraph"><div class="title">Create a New App ID</div><p><span class="image"><img src="images/facebook-app-settings.png" alt="facebook app settings"></span></p></div>
<div class="paragraph"><p>Click on the <code>+ Add Platform</code> button at the end of this page and select the <code>Website</code> icon.  Copy and paste the <code>Redirect URI</code> from the
Red Hat Single Sign-On <code>Add identity provider</code> page into the <code>Site URL</code> of the Facebook <code>Website</code> settings block.</p></div>
<div class="paragraph"><div class="title">Specify Website</div><p><span class="image"><img src="images/facebook-app-settings-website.png" alt="facebook app settings website"></span></p></div>
<div class="paragraph"><p>After this it is necessary to make the Facebook app public. Click <code>App Review</code> left menu item and switch button to "Yes".</p></div>
<div class="paragraph"><p>You will need also to obtain the App ID and App Secret from this page so you can enter them into the Red Hat Single Sign-On <code>Add identity provider</code> page. To obtain this click on the <code>Dashboard</code> left menu item and click on <code>Show</code> under <code>App Secret</code>. Go back to Red Hat Single Sign-On and specify those items and finally save your Facebook Identity Provider.</p></div>
<div class="paragraph"><p>One config option to note on the <code>Add identity provider</code> page for Facebook is the <code>Default Scopes</code> field.
This field allows you to manually specify the scopes that users must authorize when authenticating with this provider.
For a complete list of scopes, please take a look at <a href="https://developers.facebook.com/docs/graph-api" class="bare">https://developers.facebook.com/docs/graph-api</a>. By default, Red Hat Single Sign-On
uses the following scopes: <code>email</code>.</p></div>
<h3>GitHub</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with GitHub.  First, go to the <code>Identity Providers</code> left menu item
and select <code>GitHub</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/github-add-identity-provider.png" alt="github add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from GitHub.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to GitHub when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with GitHub you first have to register an application project in
<a href="https://github.com/settings/developers">GitHub Developer applications</a>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">GitHub often changes the look and feel of application registration, so these directions might not always be up to date and the
      configuration steps might be slightly different.</td></tr></table></div>
<div class="paragraph"><div class="title">Add a New App</div><p><span class="image"><img src="images/github-developer-applications.png" alt="github developer applications"></span></p></div>
<div class="paragraph"><p>Click the <code>Register a new application</code> button.</p></div>
<div class="paragraph"><div class="title">Register App</div><p><span class="image"><img src="images/github-register-app.png" alt="github register app"></span></p></div>
<div class="paragraph"><p>You&#8217;ll have to copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page and enter it into the
<code>Authorization callback URL</code> field on the GitHub <code>Register a new OAuth application</code> page.  Once you&#8217;ve completed this
page you will be brought to the application&#8217;s management page.</p></div>
<div class="paragraph"><div class="title">GitHub App Page</div><p><span class="image"><img src="images/github-app-page.png" alt="github app page"></span></p></div>
<div class="paragraph"><p>You will need to obtain the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<h3>GitLab</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with GitLab.</p></div>
<div class="paragraph"><p>First, go to the <code>Identity Providers</code> left menu item and select <code>GitLab</code> from the <code>Add provider</code> drop down list. This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/gitlab-add-identity-provider.png" alt="gitlab add identity provider"></span></p></div>
<div class="paragraph"><p>Before you can click <code>Save</code>, you must obtain a <code>Client ID</code> and <code>Client Secret</code> from GitLab.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">You will use the <code>Redirect URI</code> from this page in a later step, which you will provide to GitLab when you register Red Hat Single Sign-On as a client there.</td></tr></table></div>
<div class="paragraph"><p>To enable login with GitLab you first have to register an application in
<a href="https://docs.gitlab.com/ee/integration/oauth_provider.html">GitLab as OAuth2 authentication service provider</a>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">GitLab often changes the look and feel of application registration, so what you see on the GitLab site may differ. If in doubt, see the GitLab documentation.</td></tr></table></div>
<div class="paragraph"><div class="title">Add a New App</div><p><span class="image"><img src="images/gitlab-developer-applications.png" alt="gitlab developer applications"></span></p></div>
<div class="paragraph"><p>Copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page and enter it into the Redirect URI field on the GitLab Add new application page.</p></div>
<div class="paragraph"><div class="title">GitLab App Page</div><p><span class="image"><img src="images/gitlab-app-page.png" alt="gitlab app page"></span></p></div>
<div class="paragraph"><p>When you are done registering, click <code>Save application</code>. This will open the application management page in GitLab. Find the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><p>To finish, return to Red Hat Single Sign-On and enter them. Click <code>Save</code>.</p></div>
<h3>Google</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with Google.  First, go to the <code>Identity Providers</code> left menu item
and select <code>Google</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/google-add-identity-provider.png" alt="google add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from Google.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to Google when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with Google you first have to create a project and a client in the <a href="https://console.cloud.google.com/project">Google Developer Console</a>.
Then you need to copy the client ID and secret into the Red Hat Single Sign-On Admin Console.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Google often changes the look and feel of the Google Developer Console, so these directions might not always be up to date and the
      configuration steps might be slightly different.</td></tr></table></div>
<div class="paragraph"><p>Let&#8217;s see first how to create a project with Google.</p></div>
<div class="paragraph"><p>Log in to the <a href="https://console.cloud.google.com/project">Google Developer Console</a>.</p></div>
<div class="paragraph"><div class="title">Google Developer Console</div><p><span class="image"><img src="images/google-developer-console.png" alt="google developer console"></span></p></div>
<div class="paragraph"><p>Click the <code>Create Project</code> button.
Use any value for <code>Project name</code> and <code>Project ID</code> you want, then click the <code>Create</code> button.
Wait for the project to be created (this may take a while).  Once created you will be brought to the project&#8217;s dashboard.</p></div>
<div class="paragraph"><div class="title">Dashboard</div><p><span class="image"><img src="images/google-dashboard.png" alt="google dashboard"></span></p></div>
<div class="paragraph"><p>Then navigate to the <code>APIs &amp; Services</code> section in the Google Developer Console. On that screen, navigate to <code>Credentials</code> administration.</p></div>
<div class="paragraph"><p>When users log into Google from Red Hat Single Sign-On they will see a consent screen from Google which will ask the user
if Red Hat Single Sign-On is allowed to view information about their user profile. Thus Google requires some basic information about the product before creating any secrets for it. For a new project, you have first to configure <code>OAuth consent screen</code>.</p></div>
<div class="paragraph"><p>For the very basic setup, filling in the Application name is sufficient. You can also set additional details like scopes for Google APIs in this page.</p></div>
<div class="paragraph"><div class="title">Fill in OAuth consent screen details</div><p><span class="image"><img src="images/google-oauth-consent-screen.png" alt="google oauth consent screen"></span></p></div>
<div class="paragraph"><p>The next step is to create OAuth client ID and client secret. Back in <code>Credentials</code> administration, navigate to <code>Credentials</code> tab and select <code>OAuth client ID</code> under the <code>Create credentials</code> button.</p></div>
<div class="paragraph"><div class="title">Create credentials</div><p><span class="image"><img src="images/google-create-credentials.png" alt="google create credentials"></span></p></div>
<div class="paragraph"><p>You will then be brought to the <code>Create OAuth client ID</code> page. Select <code>Web application</code> as the application type. Specify the name you want for your client.  You&#8217;ll also need to
copy and paste the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page into the
<code>Authorized redirect URIs</code> field.  After you do this, click the <code>Create</code> button.</p></div>
<div class="paragraph"><div class="title">Create OAuth client ID</div><p><span class="image"><img src="images/google-create-oauth-id.png" alt="google create oauth id"></span></p></div>
<div class="paragraph"><p>After you click <code>Create</code> you will be brought to the <code>Credentials</code> page. Click on your new OAuth 2.0 Client ID to view
the settings of your new Google Client.</p></div>
<div class="paragraph"><div class="title">Google Client Credentials</div><p><span class="image"><img src="images/google-client-credentials.png" alt="google client credentials"></span></p></div>
<div class="paragraph"><p>You will need to obtain the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<div class="paragraph"><p>One config option to note on the <code>Add identity provider</code> page for Google is the <code>Default Scopes</code> field.
This field allows you to manually specify the scopes that users must authorize when authenticating with this provider.
For a complete list of scopes, please take a look at <a href="https://developers.google.com/oauthplayground/" class="bare">https://developers.google.com/oauthplayground/</a> . By default, Red Hat Single Sign-On
uses the following scopes: <code>openid</code> <code>profile</code> <code>email</code>.</p></div>
<div class="paragraph"><p>If your organization uses the G Suite and you want to restrict access to only members of your organization,
you must enter the domain that is used for the G Suite into the <code>Hosted Domain</code> field to enable it.</p></div>
<h3>LinkedIn</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with LinkedIn.  First, go to the <code>Identity Providers</code> left menu item
and select <code>LinkedIn</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/linked-in-add-identity-provider.png" alt="linked in add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from LinkedIn.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to LinkedIn when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with LinkedIn you first have to create an application in <a href="https://www.linkedin.com/developer/apps">LinkedIn Developer Network</a>.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">LinkedIn may change the look and feel of application registration, so these directions may not always be up to date.</td></tr></table></div>
<div class="paragraph"><div class="title">Developer Network</div><p><span class="image"><img src="images/linked-in-developer-network.png" alt="linked in developer network"></span></p></div>
<div class="paragraph"><p>Click on the <code>Create Application</code> button.  This will bring you to the <code>Create a New Application</code> Page.</p></div>
<div class="paragraph"><div class="title">Create App</div><p><span class="image"><img src="images/linked-in-create-app.png" alt="linked in create app"></span></p></div>
<div class="paragraph"><p>Fill in the form with the appropriate values, then click the <code>Submit</code> button.  This will bring you to the new application&#8217;s settings page.</p></div>
<div class="paragraph"><div class="title">App Settings</div><p><span class="image"><img src="images/linked-in-app-settings.png" alt="linked in app settings"></span></p></div>
<div class="paragraph"><p>Select <code>r_basicprofile</code> and <code>r_emailaddress</code> in the <code>Default Application Permissions</code> section.
You&#8217;ll have to copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page and enter it into the
<code>OAuth 2.0</code> <code>Authorized Redirect URLs</code> field on the LinkedIn app settings page.  Don&#8217;t forget to click the <code>Update</code> button after
you do this!</p></div>
<div class="paragraph"><p>You will then need to obtain the client ID and secret from this page so you can enter them into the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<h3>Microsoft</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with Microsoft.  First, go to the <code>Identity Providers</code> left menu item
and select <code>Microsoft</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/microsoft-add-identity-provider.png" alt="microsoft add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from Microsoft.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to Microsoft when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with Microsoft account you first have to register an OAuth application at Microsoft.
Go to the <a href="https://account.live.com/developers/applications/create">Microsoft Application Registration</a> url.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Microsoft often changes the look and feel of application registration, so these directions might not always be up to date and the
      configuration steps might be slightly different.</td></tr></table></div>
<div class="paragraph"><div class="title">Register Application</div><p><span class="image"><img src="images/microsoft-app-register.png" alt="microsoft app register"></span></p></div>
<div class="paragraph"><p>Enter in the application name and click <code>Create application</code>.  This will bring you to the application settings page of your
new application.</p></div>
<div class="paragraph"><div class="title">Settings</div><p><span class="image"><img src="images/microsoft-app-settings.png" alt="microsoft app settings"></span></p></div>
<div class="paragraph"><p>You&#8217;ll have to copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page and add it to the
<code>Redirect URIs</code> field on the Microsoft application page.  Be sure to click the <code>Add Url</code> button and <code>Save</code> your changes.</p></div>
<div class="paragraph"><p>Finally, you will need to obtain the Application ID and secret from this page so you can enter them back on the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">From November 2018 onwards, Microsoft is removing support for the Live SDK API in favor of the new Microsoft Graph API.
         The Red Hat Single Sign-On Microsoft identity provider has been updated to use the new endpoints so make sure to upgrade to
         Red Hat Single Sign-On version 7.2.5 or later in order to use this provider.
         Furthermore, client applications registered with Microsoft under "Live SDK applications" will need to be re-registered
         in the <a href="https://account.live.com/developers/applications/create">Microsoft Application Registration</a> portal to obtain an application id that
         is compatible with the Microsoft Graph API.</td></tr></table></div>
<h3>OpenShift 3</h3><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">OpenShift Online is currently in the developer preview mode. This documentation has been based on on-premise installations and local <code>minishift</code> development environment.</td></tr></table></div>
<div class="paragraph"><p>There are a just a few steps you have to complete to be able to enable login with OpenShift.  First, go to the <code>Identity Providers</code> left menu item
and select <code>OpenShift</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="images/openshift-add-identity-provider.png" alt="openshift add identity provider"></span></p></div>
<div class="paragraph"><div class="title">Registering OAuth client</div><p>You can register your client using <code>oc</code> command line tool.</p></div>
<div class="exampleblock"><div class="content"><pre class="highlight listingblock"><code class="bash language-bash">$ oc create -f &lt;(echo '
kind: OAuthClient
apiVersion: v1
metadata:
 name: kc-client <b>(1)</b>
secret: "..." <b>(2)</b>
redirectURIs:
 - "http://www.example.com/" <b>(3)</b>
grantMethod: prompt <b>(4)</b>
')</code></pre>
<div class="colist arabic"><ol><li><p>The <code>name</code> of your OAuth client. Passed as <code>client_id</code> request parameter when making requests to <code><em>&lt;openshift_master&gt;</em>/oauth/authorize</code> and <code><em>&lt;openshift_master&gt;</em>/oauth/token</code>.</p></li><li><p><code>secret</code> is used as the <code>client_secret</code> request parameter.</p></li><li><p>The <code>redirect_uri</code> parameter specified in requests to <code><em>&lt;openshift_master&gt;</em>/oauth/authorize</code> and <code><em>&lt;openshift_master&gt;</em>/oauth/token</code> must be equal to (or prefixed by) one of the URIs in <code>redirectURIs</code>.</p></li><li><p>The <code>grantMethod</code> is used to determine what action to take when this client requests tokens and has not yet been granted access by the user.</p></li></ol></div></div></div>
<div class="paragraph"><p>Use client ID and secret defined by <code>oc create</code> command to enter them back on the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<div class="paragraph"><p>Please refer to <a href="https://docs.okd.io/latest/architecture/additional_concepts/authentication.html#oauth">official OpenShift documentation</a> for more detailed guides.</p></div>
<h3>OpenShift 4</h3><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Prior to configuring OpenShift 4 Identity Provider, please locate the correct OpenShift 4 API URL up.
In some scenarios, that URL might be hidden from users. The easiest way to obtain it is to invoke the following command (this might require installing <code>jq</code> command separately) <code>curl -s -k -H "Authorization: Bearer $(oc whoami -t)" https://&lt;openshift-user-facing-api-url&gt;/apis/config.openshift.io/v1/infrastructures/cluster | jq ".status.apiServerURL"</code>. In most cases, the address will be protected by HTTPS. Therefore, it is essential to configure <code>X509_CA_BUNDLE</code> in the container and set it to <code>/var/run/secrets/kubernetes.io/serviceaccount/ca.crt</code>. Otherwise, Red Hat Single Sign-On won&#8217;t be able to communicate
 with the API Server.</td></tr></table></div>
<div class="paragraph"><p>There are a just a few steps you have to complete to be able to enable login with OpenShift 4.  First, go to the <code>Identity Providers</code> left menu item and select <code>OpenShift v4</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="images/openshift-4-add-identity-provider.png" alt="openshift 4 add identity provider"></span></p></div>
<div class="paragraph"><div class="title">Registering OAuth client</div><p>You can register your client using <code>oc</code> command line tool.</p></div>
<div class="exampleblock"><div class="content"><pre class="highlight listingblock"><code class="bash language-bash">$ oc create -f &lt;(echo '
kind: OAuthClient
apiVersion: v1
metadata:
 name: keycloak-broker <b>(1)</b>
secret: "..." <b>(2)</b>
redirectURIs:
 - "&lt;copy pasted Redirect URI from OpenShift 4 Identity Providers page&gt;" <b>(3)</b>
grantMethod: prompt <b>(4)</b>
')</code></pre>
<div class="colist arabic"><ol><li><p>The <code>name</code> of your OAuth client. Passed as <code>client_id</code> request parameter when making requests to <code><em>&lt;openshift_master&gt;</em>/oauth/authorize</code> and <code><em>&lt;openshift_master&gt;</em>/oauth/token</code>. The <code>name</code> parameter needs to be the same
in <code>OAuthClient</code> object as well as in Red Hat Single Sign-On configuration.</p></li><li><p><code>secret</code> is used as the <code>client_secret</code> request parameter.</p></li><li><p>The <code>redirect_uri</code> parameter specified in requests to <code><em>&lt;openshift_master&gt;</em>/oauth/authorize</code> and <code><em>&lt;openshift_master&gt;</em>/oauth/token</code> must be equal to (or prefixed by) one of the URIs in <code>redirectURIs</code>. The easiest way to configure it correctly is to copy-paste
it from Red Hat Single Sign-On OpenShift 4 Identity Provider configuration page (<code>Redirect URI</code> field).</p></li><li><p>The <code>grantMethod</code> is used to determine what action to take when this client requests tokens and has not yet been granted access by the user.</p></li></ol></div></div></div>
<div class="paragraph"><p>Use the client ID and secret defined by <code>oc create</code> command to enter them back on the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<div class="admonitionblock tip"><table><tr><td class="icon"><div class="title">Tip</div></td><td class="content">The OpenShift API server returns <code>The client is not authorized to request a token using this method</code> whenever <code>OAuthClient</code>
 <code>name</code>, <code>secret</code> or <code>redirectURIs</code> is incorrect. Make sure you copy-pasted them into Red Hat Single Sign-On OpenShift 4 Identity Provider page correctly.</td></tr></table></div>
<div class="paragraph"><p>Please refer to <a href="https://docs.okd.io/latest/architecture/additional_concepts/authentication.html#oauth">official OpenShift documentation</a> for more detailed guides.</p></div>
<h3>PayPal</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with PayPal.  First, go to the <code>Identity Providers</code> left menu item
and select <code>PayPal</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/paypal-add-identity-provider.png" alt="paypal add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from PayPal.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to PayPal when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with PayPal you first have to register an application project in
<a href="https://developer.paypal.com/developer/applications">PayPal Developer applications</a>.</p></div>
<div class="paragraph"><div class="title">Add a New App</div><p><span class="image"><img src="images/paypal-developer-applications.png" alt="paypal developer applications"></span></p></div>
<div class="paragraph"><p>Click the <code>Create App</code> button.</p></div>
<div class="paragraph"><div class="title">Register App</div><p><span class="image"><img src="images/paypal-register-app.png" alt="paypal register app"></span></p></div>
<div class="paragraph"><p>You will now be brought to the app settings page.</p></div>
<div class="ulist"><div class="title">Do the following changes</div><ul><li><p>Choose to configure either Sandbox or Live (choose Live if you haven&#8217;t enabled the <code>Target Sandbox</code> switch on the <code>Add identity provider</code> page)</p></li><li><p>Copy Client ID and Secret so you can paste them into the Red Hat Single Sign-On <code>Add identity provider</code> page.</p></li><li><p>Scroll down to <code>App Settings</code></p></li><li><p>Copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page and enter it into the <code>Return URL</code> field.</p></li><li><p>Check the <code>Log In with PayPal</code> checkbox.</p></li><li><p>Check the <code>Full name</code> checkbox under the personal information section.</p></li><li><p>Check the <code>Email address</code> checkbox under the address information section.</p></li><li><p>Add both a privacy and a user agreement URL pointing to the respective pages on your domain.</p></li></ul></div>
<h3>Stack Overflow</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with Stack Overflow.  First, go to the <code>Identity Providers</code> left menu item
and select <code>Stack Overflow</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/stack-overflow-add-identity-provider.png" alt="stack overflow add identity provider"></span></p></div>
<div class="paragraph"><p>To enable login with Stack Overflow you first have to register an OAuth application on <a href="https://stackapps.com/">StackApps</a>.
Go to <a href="https://stackapps.com/apps/oauth/register">registering your application on Stack Apps</a> URL and login.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Stack Overflow often changes the look and feel of application registration, so these directions might not always be up to date and the
      configuration steps might be slightly different.</td></tr></table></div>
<div class="paragraph"><div class="title">Register Application</div><p><span class="image"><img src="images/stack-overflow-app-register.png" alt="stack overflow app register"></span></p></div>
<div class="paragraph"><p>Enter in the application name and the OAuth Domain Name of your application and click <code>Register your Application</code>.  Type in anything you want
for the other items.</p></div>
<div class="paragraph"><div class="title">Settings</div><p><span class="image"><img src="images/stack-overflow-app-settings.png" alt="stack overflow app settings"></span></p></div>
<div class="paragraph"><p>Finally, you will need to obtain the client ID, secret, and key from this page so you can enter them back on the Red Hat Single Sign-On <code>Add identity provider</code> page.
Go back to Red Hat Single Sign-On and specify those items.</p></div>
<h3>Twitter</h3><div class="paragraph"><p>There are a number of steps you have to complete to be able to enable login with Twitter.  First, go to the <code>Identity Providers</code> left menu item
and select <code>Twitter</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/twitter-add-identity-provider.png" alt="twitter add identity provider"></span></p></div>
<div class="paragraph"><p>You can&#8217;t click save yet, as you&#8217;ll need to obtain a <code>Client ID</code> and <code>Client Secret</code> from Twitter.  One piece of data you&#8217;ll need from this
page is the <code>Redirect URI</code>.  You&#8217;ll have to provide that to Twitter when you register Red Hat Single Sign-On as a client there, so
copy this URI to your clipboard.</p></div>
<div class="paragraph"><p>To enable login with Twtter you first have to create an application in the <a href="https://developer.twitter.com/apps/">Twitter Application Management</a>.</p></div>
<div class="paragraph"><div class="title">Register Application</div><p><span class="image"><img src="images/twitter-app-register.png" alt="twitter app register"></span></p></div>
<div class="paragraph"><p>Click on the <code>Create New App</code> button.  This will bring you to the <code>Create an Application</code> page.</p></div>
<div class="paragraph"><div class="title">Register Application</div><p><span class="image"><img src="images/twitter-app-create.png" alt="twitter app create"></span></p></div>
<div class="paragraph"><p>Enter in a Name and Description.  The Website can be anything, but cannot have a <code>localhost</code> address.  For the
<code>Callback URL</code> you must copy the <code>Redirect URI</code> from the Red Hat Single Sign-On <code>Add Identity Provider</code> page.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">You cannot use <code>localhost</code> in the <code>Callback URL</code>.  Instead replace it with <code>127.0.0.1</code> if you are trying to test drive Twitter login on your laptop.</td></tr></table></div>
<div class="paragraph"><p>After clicking save you will be brought to the <code>Details</code> page.</p></div>
<div class="paragraph"><div class="title">App Details</div><p><span class="image"><img src="images/twitter-details.png" alt="twitter details"></span></p></div>
<div class="paragraph"><p>Next go to the <code>Keys and Access Tokens</code> tab.</p></div>
<div class="paragraph"><div class="title">Keys and Access Tokens</div><p><span class="image"><img src="images/twitter-keys.png" alt="twitter keys"></span></p></div>
<div class="paragraph"><p>Finally, you will need to obtain the API Key and secret from this page and copy them back into the <code>Client ID</code> and <code>Client Secret</code> fields on the Red Hat Single Sign-On <code>Add identity provider</code> page.</p></div></section><section id="_identity_broker_oidc"><h2>OpenID Connect v1.0 Identity Providers</h2><div class="paragraph"><p>Red Hat Single Sign-On can broker identity providers based on the OpenID Connect protocol.  These IDPs must support the <a href="#_oidc">Authorization Code Flow</a>
as defined by the specification in order to authenticate the user and authorize access.</p></div>
<div class="paragraph"><p>To begin configuring an OIDC provider, go to the <code>Identity Providers</code> left menu item
and select <code>OpenID Connect v1.0</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/oidc-add-identity-provider.png" alt="oidc add identity provider"></span></p></div>
<div class="paragraph"><p>The initial configuration options on this page are described in <a href="#_general-idp-config">General IDP Configuration</a>.
You must define the OpenID Connect configuration options as well.  They basically describe the OIDC IDP you are communicating with.</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 2. OpenID Connect Config</caption><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Configuration</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Authorization URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Authorization URL endpoint required by the OIDC protocol.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Token URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Token URL endpoint required by the OIDC protocol.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Logout URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Logout URL endpoint defined in the OIDC protocol.  This value is optional.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Backchannel Logout</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Backchannel logout is a background, out-of-band, REST invocation to the IDP to logout the user.  Some IDPs can only perform logout through browser redirects as they may
 only be able to identity sessions via a browser cookie.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">User Info URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">User Info URL endpoint defined by the OIDC protocol.  This is an endpoint from which user profile information can be downloaded.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Client Authentication</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Switch to define the Client Authentication method to be used with the Authorization Code Flow.  In the case of JWT signed with private key, the realm private key
 is used.  In the other cases, a client secret has to be defined.
 For more details, see the <a href="https://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">Client Authentication specifications</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Client ID</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This realm will act as an OIDC client to the external IDP.  Your realm will need an OIDC client ID when using the Authorization Code Flow
 to interact with the external IDP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Client Secret</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This realm will need a client secret to use when using the Authorization Code Flow. The value of this field can refer a value from an external <a href="#_vault-administration">vault</a>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Issuer</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Responses from the IDP may contain an issuer claim.  This config value is optional.  If specified, this claim will be validated against the value you provide.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Default Scopes</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Space-separated list of OIDC scopes to send with the authentication request.  The default is <code>openid</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Prompt</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Another optional switch.  This is the prompt parameter defined by the OIDC specification. Through it you can force re-authentication and other options.  See the specification for
 more details.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Accepts prompt=none forward from client</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Specifies whether the IDP accepts forwarded authentication requests that contain the prompt=none query parameter or not. When a realm receives an auth request with <code>prompt=none</code> it checks
 if the user is currently authenticated and normally returns a <code>login_required</code> error if the user is not logged in. However, when a default IDP can be determined
 for the auth request (either via <code>kc_idp_hint</code> query param or by setting up a default IDP for the realm) we should be able to forward the auth request with
 <code>prompt=none</code> to the default IDP so that it checks if the user is currently authenticated there. Because not all IDPs support requests with <code>prompt=none</code> this switch
 is used to indicate if the default IDP supports the param before redirecting the auth request.</p><p class="tableblock"> It is important to note that if the user is not authenticated in the IDP, the client will still get a <code>login_required</code> error. Even if the user is currently authenticated in the IDP,
 the client might still get an <code>interaction_required</code> error if authentication or consent pages requiring user interaction would be otherwise displayed. This includes required actions
 (e.g. change password), consent screens and any screens set to be displayed by the <code>first broker login</code> flow or <code>post broker login</code> flow.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Validate Signatures</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Another optional switch. This is to specify if Red Hat Single Sign-On will verify the signatures on the external ID Token signed by this identity provider. If this is on,
the Red Hat Single Sign-On will need to know the public key of the external OIDC identity provider. See below for how to set it up.
WARNING: For the performance purposes, Red Hat Single Sign-On caches the public key of the external OIDC identity provider. If you think that private key of your identity provider
was compromised, it is obviously good to update your keys, but it&#8217;s also good to clear the keys cache. See
<a href="#_clear-cache">Clearing the cache</a> section for more details.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Use JWKS URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Applicable if <code>Validate Signatures</code> is on. If the switch is on, then identity provider public keys will be downloaded from given JWKS URL.
 This allows great flexibility because new keys will be always re-downloaded when the identity provider generates new keypair. If the switch is off,
 then public key (or certificate) from the Red Hat Single Sign-On DB is used, so whenever the identity provider keypair changes, you will always need to import the new key to the Red Hat Single Sign-On DB as well.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">JWKS URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">URL where the identity provider JWK keys are stored. See the <a href="https://self-issued.info/docs/draft-ietf-jose-json-web-key.html">JWK specification</a> for more details.
 If you use an external Red Hat Single Sign-On as an identity provider, then you can use URL like <a href="http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs" class="bare">http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs</a> assuming your brokered
 Red Hat Single Sign-On is running on <a href="http://broker-keycloak:8180" class="bare">http://broker-keycloak:8180</a> and it&#8217;s realm is <code>test</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Validating Public Key</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Applicable if <code>Use JWKS URL</code> is off. Here is the public key in PEM format that must be used to verify external IDP signatures.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Validating Public Key Id</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Applicable if <code>Use JWKS URL</code> is off. This field specifies ID of the public key in PEM format. This config value is optional. As there is no standard way
 for computing key ID from key, various external identity providers might use different algorithm from Red Hat Single Sign-On. If the value of this field
 is not specified, the validating public key specified above is used for all requests regardless of key ID sent by external IDP. When set, value of this
 field serves as key ID used by Red Hat Single Sign-On for validating signatures from such providers and must match the key ID specified by the IDP.</p></td></tr></table>
<div class="paragraph"><p>You can also import all this configuration data by providing a URL or file that points to OpenID Provider Metadata (see OIDC Discovery specification).
If you are connecting to a Red Hat Single Sign-On external IDP, you can import the IDP settings from the url <code>&lt;root&gt;/auth/realms/{realm-name}/.well-known/openid-configuration</code>.
This link is a JSON document describing metadata about the IDP.</p></div></section><section id="_saml_v2_0_identity_providers"><h2>SAML v2.0 Identity Providers</h2><div class="paragraph"><p>Red Hat Single Sign-On can broker identity providers based on the SAML v2.0 protocol.</p></div>
<div class="paragraph"><p>To begin configuring an SAML v2.0 provider, go to the <code>Identity Providers</code> left menu item
and select <code>SAML v2.0</code> from the <code>Add provider</code> drop down list.  This will bring you to the <code>Add identity provider</code> page.</p></div>
<div class="paragraph"><div class="title">Add Identity Provider</div><p><span class="image"><img src="rhsso-images/saml-add-identity-provider.png" alt="saml add identity provider"></span></p></div>
<div class="paragraph"><p>The initial configuration options on this page are described in <a href="#_general-idp-config">General IDP Configuration</a>.
You must define the SAML configuration options as well.  They basically describe the SAML IDP you are communicating with.</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><caption class="title">Table 3. SAML Config</caption><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Configuration</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Single Sign-On Service URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This is a required field and specifies the SAML endpoint to start the authentication process.  If your SAML IDP publishes an IDP entity descriptor, the value of
 this field will be specified there.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Single Logout Service URL</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This is an optional field that specifies the SAML logout endpoint. If your SAML IDP publishes an IDP entity descriptor, the value of
 this field will be specified there.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Backchannel Logout</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Enable if your SAML IDP supports backchannel logout.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">NameID Policy Format</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the URI reference corresponding to a name identifier format. Defaults to <code>urn:oasis:names:tc:SAML:2.0:nameid-format:persistent</code>.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">HTTP-POST Binding Response</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">When this realm responds to any SAML requests sent by the external IDP, which SAML binding should be used?  If set to <code>off</code>, then the Redirect Binding will be used.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">HTTP-POST Binding for AuthnRequest</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">When this realm requests authentication from the external SAML IDP, which SAML binding should be used?  If set to <code>off</code>, then the Redirect Binding will be used.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Want AuthnRequests Signed</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If true, it will use the realm&#8217;s keypair to sign requests sent to the external SAML IDP.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Signature Algorithm</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">If <code>Want AuthnRequests Signed</code> is on, then you can also pick the signature algorithm to use.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SAML Signature Key Name</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Signed SAML documents sent via POST binding contain identification of signing key in <code>KeyName</code>
 element. This by default contains Red Hat Single Sign-On key ID. However various external SAML IDPs might
 expect a different key name or no key name at all. This switch controls whether <code>KeyName</code>
 contains key ID (option <code>KEY_ID</code>), subject from certificate corresponding to the realm key
 (option <code>CERT_SUBJECT</code> - expected for instance by Microsoft Active Directory Federation
 Services), or that the key name hint is completely omitted from the SAML message (option <code>NONE</code>).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Force Authentication</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Indicates that the user will be forced to enter their credentials at the external IDP even if they are already logged in.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Validate Signature</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Whether or not the realm should expect that SAML requests and responses from the external IDP to be digitally signed.  It is highly recommended you turn this on!</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Validating X509 Certificate</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">The public certificate that will be used to validate the signatures of SAML requests and responses from the external IDP.</p></td></tr></table>
<div class="paragraph"><p>You can also import all this configuration data by providing a URL or file that points to the SAML IDP entity descriptor of the external IDP.
If you are connecting to a Red Hat Single Sign-On external IDP, you can import the IDP settings from the URL <code>&lt;root&gt;/auth/realms/{realm-name}/protocol/saml/descriptor</code>.
This link is an XML document describing metadata about the IDP.</p></div>
<div class="paragraph"><p>You can also import all this configuration data by providing a URL or XML file that points to the entity descriptor of the external SAML IDP you want to connect to.</p></div>
<h3>SP Descriptor</h3><div class="paragraph"><p>Once you create a SAML provider, there is an <code>EXPORT</code> button that appears when viewing that provider.
Clicking this button will export a SAML SP entity descriptor which you can use to import into the external SP.</p></div>
<div class="paragraph"><p>This metadata is also available publicly by going to the URL.</p></div>
<pre class="highlight listingblock"><code>http[s]://{host:port}/auth/realms/{realm-name}/broker/{broker-alias}/endpoint/descriptor</code></pre></section><section id="_client_suggested_idp"><h2>Client-suggested Identity Provider</h2><div class="paragraph"><p>OIDC applications can bypass the Red Hat Single Sign-On login page by specifying a hint on which
identity provider they want to use.</p></div>
<div class="paragraph"><p>This is done by setting the <code>kc_idp_hint</code> query parameter in the Authorization Code Flow authorization endpoint.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On OIDC client adapters also allow you to specify this query parameter when you access a secured resource
at the application.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight listingblock"><code>GET /myapplication.com?kc_idp_hint=facebook HTTP/1.1
Host: localhost:8080</code></pre>
<div class="paragraph"><p>In this case, it is expected that your realm has an identity provider with an alias <code>facebook</code>. If this provider doesn&#8217;t exist the login form will be displayed.</p></div>
<div class="paragraph"><p>If you are using <code>keycloak.js</code> adapter, you can also achieve the same behavior:</p></div>
<pre class="highlight listingblock"><code class="javascript language-javascript">var keycloak = new Keycloak('keycloak.json');

keycloak.createLoginUrl({
	idpHint: 'facebook'
});</code></pre>
<div class="paragraph"><p>The <code>kc_idp_hint</code> query parameter also allows the client to override the default identity provider if one is configured for the <code>Identity Provider Redirector</code> authenticator. The client can also disable the automatic redirecting by setting the <code>kc_idp_hint</code> query parameter to an empty value.</p></div></section><section id="_mappers"><h2>Mapping Claims and Assertions</h2><div class="paragraph"><p>You can import the SAML and OpenID Connect metadata provided by the external IDP you are authenticating with into the environment
of the realm.  This allows you to extract user profile metadata and other information so that you can make it available to your
applications.</p></div>
<div class="paragraph"><p>Each new user that logs into your realm via an external identity provider will have an entry for them created in the local
Red Hat Single Sign-On database, based on the metadata from the SAML or OIDC assertions and claims.</p></div>
<div class="paragraph"><p>If you click on an identity provider listed in the <code>Identity Providers</code> page for your realm, you will be brought to the IDPs
<code>Settings</code> tab.  On this page there is also a <code>Mappers</code> tab.  Click on that tab to start mapping your incoming IDP metadata.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/identity-provider-mappers.png" alt="identity provider mappers"></span></p></div>
<div class="paragraph"><p>There is a <code>Create</code> button on this page.
Clicking on this create button allows you to create a broker mapper.
Broker mappers can import SAML attributes or OIDC ID/Access token claims into user attributes and user role mappings.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/identity-provider-mapper.png" alt="identity provider mapper"></span></p></div>
<div class="paragraph"><p>Select a mapper from the <code>Mapper Type</code> list.  Hover over the tooltip to see a description of what the mapper does.  The
tooltips also describe what configuration information you need to enter. Click <code>Save</code> and your new mapper will be added.</p></div>
<div class="paragraph"><p>For JSON based claims, you can use dot notation for nesting and square brackets to access array fields by index.
For example 'contact.address[0].country'.</p></div>
<div class="paragraph"><p>To investigate the structure of user profile JSON data provided by social providers you can enable the <code>DEBUG</code> level logger <code>org.keycloak.social.user_profile_dump</code>.
This is done in the server&#8217;s app-server configuration file (domain.xml or standalone.xml).</p></div></section><section id="_available_user_session_data"><h2>Available User Session Data</h2><div class="paragraph"><p>After a user logs in from the external IDP, there is some additional user session note data that Red Hat Single Sign-On stores that you can access.
This data can be propagated to the client requesting a login via the token or SAML assertion being passed back to it by using an appropriate client mapper.</p></div>
<div class="dlist"><dl><dt class="hdlist1">identity_provider</dt><dd><p>This is the IDP alias of the broker used to perform the login.</p></dd><dt class="hdlist1">identity_provider_identity</dt><dd><p>This is the IDP username of the currently authenticated user. This is often the same as the Red Hat Single Sign-On username, but doesn&#8217;t necessarily needs to be.
For example Red Hat Single Sign-On user <code>john</code> can be linked to the Facebook user <code>john123@gmail.com</code>, so in that case value of user session note will be <code>john123@gmail.com</code> .</p></dd></dl></div>
<div class="paragraph"><p>You can use a <a href="#_protocol-mappers">Protocol Mapper</a> of type <code>User Session Note</code> to propagate this information to your clients.</p></div></section><section id="_identity_broker_first_login"><h2>First Login Flow</h2><div class="paragraph"><p>When a user logs in through identity brokering some aspects of the user are imported and linked within the realm&#8217;s local database.
When Red Hat Single Sign-On successfully authenticates users through an external identity provider
there can be two situations:</p></div>
<div class="ulist"><ul><li><p>There is already a Red Hat Single Sign-On user account imported and linked with the authenticated identity provider account.
In this case, Red Hat Single Sign-On will just authenticate as the existing user and redirect back to application.</p></li><li><p>There is not yet an existing Red Hat Single Sign-On user account imported and linked for this external user.
Usually you just want to register and import the new account into Red Hat Single Sign-On database, but what if there is an existing
Red Hat Single Sign-On account with the same email? Automatically linking the existing local account to the external
identity provider is a potential security hole as you can&#8217;t always trust the information you get from the external identity provider.</p></li></ul></div>
<div class="paragraph"><p>Different organizations have different requirements when dealing with some of the conflicts and situations listed above.
For this, there is a <code>First Login Flow</code> option in the IDP settings which allows you to choose a <a href="#_authentication-flows">workflow</a> that will be
used after a user logs in from an external IDP the first time.
By default it points to <code>first broker login</code> flow, but you can configure and use your own flow and use different flows for different identity providers.</p></div>
<div class="paragraph"><p>The flow itself is configured in admin console under <code>Authentication</code> tab.
When you choose <code>First Broker Login</code> flow, you will see what authenticators are used by default.
You can re-configure the existing flow. (For example you can disable some authenticators, mark some of them as <code>required</code>, configure some authenticators, etc).</p></div>
<h3>Default First Login Flow</h3><div class="paragraph"><p>Let&#8217;s describe the default behavior provided by <code>First Broker Login</code> flow.</p></div>
<div class="dlist"><dl><dt class="hdlist1">Review Profile</dt><dd><p>This authenticator might display the profile info page, where the user can review their profile retrieved from an identity provider.
The authenticator is configurable.
You can set the <code>Update Profile On First Login</code> option.
When <code>On</code>, users will be always presented with the profile page asking for additional information in order to federate their identities.
When <code>missing</code>, users will be presented with the profile page only if some mandatory information (email, first name, last name) is not provided by the identity provider.
If <code>Off</code>, the profile page won&#8217;t be displayed, unless user clicks in later phase on <code>Review profile info</code> link (page displayed in later phase
by <code>Confirm Link Existing Account</code> authenticator).</p></dd><dt class="hdlist1">Create User If Unique</dt><dd><p>This authenticator checks if there is already an existing Red Hat Single Sign-On account with the same email or username like the account from the identity provider.
If it&#8217;s not, then the authenticator just creates a new local Red Hat Single Sign-On account and links it with the identity provider and the whole flow is finished.
Otherwise it goes to the next <code>Handle Existing Account</code> subflow.
If you always want to ensure that there is no duplicated account, you can mark this authenticator as <code>REQUIRED</code>. In this case, the user
will see the error page if there is an existing Red Hat Single Sign-On account and the user will need to link his identity provider account through Account management.</p></dd><dt class="hdlist1">Confirm Link Existing Account</dt><dd><p>On the info page, the user will see that there is an existing Red Hat Single Sign-On account with the same email.
They can review their profile again and use different email or username (flow is restarted and goes back to <code>Review Profile</code> authenticator).
Or they can confirm that they want to link their identity provider account with their existing Red Hat Single Sign-On account.
Disable this authenticator if you don&#8217;t want users to see this confirmation page, but go straight to linking identity provider account by email verification or re-authentication.</p></dd><dt class="hdlist1">Verify Existing Account By Email</dt><dd><p>This authenticator is <code>ALTERNATIVE</code> by default, so it&#8217;s used only if the realm has SMTP setup configured.
It will send email to the user, where they can confirm that they want to link the identity provider with their Red Hat Single Sign-On account.
Disable this if you don&#8217;t want to confirm linking by email, but instead you always want users to reauthenticate with their password (and alternatively OTP).</p></dd><dt class="hdlist1">Verify Existing Account By Re-authentication</dt><dd><p>This authenticator is used if email authenticator is disabled or not available (SMTP not configured for realm). It will display a login screen
where the user needs to authenticate with his password to link their Red Hat Single Sign-On account with the Identity provider.
User can also re-authenticate with some different identity provider, which is already linked to their Red Hat Single Sign-On account.
You can also force users to use OTP. Otherwise it&#8217;s optional and used only if OTP is already set for the user account.</p></dd></dl></div>
<h3>Automatically Link Existing First Login Flow</h3><div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">The AutoLink authenticator would be dangerous in a generic environment where users can register themselves using arbitrary usernames/email addresses. Do not use this authenticator unless registration of users is carefully curated and usernames/email addresses are assigned, not requested.</td></tr></table></div>
<div class="paragraph"><p>In order to configure a first login flow in which users are automatically linked without being prompted, create a new flow with the following two authenticators:</p></div>
<div class="dlist"><dl><dt class="hdlist1">Create User If Unique</dt><dd><p>This authenticator ensures that unique users are handled. Set the authenticator requirement to "Alternative".</p></dd><dt class="hdlist1">Automatically Link Brokered Account</dt><dd><p>Automatically link brokered identities without any validation with this authenticator. This is useful in an intranet environment of multiple user databases each with overlapping usernames/email addresses, but different passwords, and you want to allow users to use any password without having to validate. This is only reasonable if you manage all internal databases, and usernames/email addresses from one database matching those in another database belong to the same person. Set the authenticator requirement to "Alternative".</p></dd></dl></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">The described setup uses two authenticators, and is the simplest one, but it is possible to use other
authenticators according to your needs. For example, you can add the Review Profile authenticator to the beginning of the flow if you still want end users to confirm their profile information.</td></tr></table></div></section><section id="_retrieving_external_idp_tokens"><h2>Retrieving External IDP Tokens</h2><div class="paragraph"><p>Red Hat Single Sign-On allows you to store tokens and responses from the authentication process with the external IDP.
For that, you can use the <code>Store Token</code> configuration option on the IDP&#8217;s settings page.</p></div>
<div class="paragraph"><p>Application code can retrieve these tokens and responses to pull in extra user information, or to securely invoke requests on the external IDP.
For example, an application might want to use the Google token to invoke on other Google services and REST APIs.
To retrieve a token for a particular identity provider you need to send a request as follows:</p></div>
<pre class="highlight listingblock"><code>GET /auth/realms/{realm}/broker/{provider_alias}/token HTTP/1.1
Host: localhost:8080
Authorization: Bearer &lt;KEYCLOAK ACCESS TOKEN&gt;</code></pre>
<div class="paragraph"><p>An application must have authenticated with Red Hat Single Sign-On and have received an access token.  This access token
will need to have the <code>broker</code> client-level role <code>read-token</code> set.  This means that the user must have a role mapping for this role
and the client application must have that role within its scope.
In this case, given that you are accessing a protected service in Red Hat Single Sign-On, you need to send the access token issued by Red Hat Single Sign-On during the user authentication.
In the broker configuration page you can automatically assign this role to newly imported users by turning on the <code>Stored Tokens Readable</code> switch.</p></div>
<div class="paragraph"><p>These external tokens can be re-established by either logging in again through the provider, or using the client-initiated account linking API.</p></div></section><section id="_identity_broker_logout"><h2>Identity broker logout</h2><div class="paragraph"><p>When logout from Red Hat Single Sign-On is triggered, Red Hat Single Sign-On will send a request to the external identity provider
that was used to login to Keycloak, and the user will be logged out from this identity provider as well.
It is possible to skip this behavior and avoid logout at the external identity provider.
See <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/securing_applications_and_services_guide/#_java_adapter_logout">adapter logout documentation</a> for more details.</p></div></section></section>
<section><section id="_user_session_management"><h2>User Session Management</h2><div class="paragraph"><p>When a user logs into a realm, Red Hat Single Sign-On maintains a user session for them and remembers each and every client they
have visited within the session.  There are a lot of administrative
functions that realm admins can perform on these user sessions.  They can view login stats for the entire realm and dive down
into each client to see who is logged in and where.  Admins can logout a user or set of users from the Admin Console. They
can revoke tokens and set up all the token and session timeouts there too.</p></div></section><section id="_administering_sessions"><h2>Administering Sessions</h2><div class="paragraph"><p>If you go to the <code>Sessions</code> left menu item you can see a top level view of the number of sessions that are currently active in the realm.</p></div>
<div class="paragraph"><div class="title">Sessions</div><p><span class="image"><img src="rhsso-images/sessions.png" alt="sessions"></span></p></div>
<div class="paragraph"><p>A list of clients is given and how many active sessions there currently are for that client. You can also logout all
users in the realm by clicking the <code>Logout all</code> button on the right side of this list.</p></div>
<h3>Logout All Limitations</h3><div class="paragraph"><p>Any SSO cookies set will now be invalid and clients that request authentication in active browser sessions will now have to
re-login.  Only certain clients are notified of this logout event, specifically clients that are using the Red Hat Single Sign-On
OIDC client adapter. Other client types (i.e. SAML) will not receive a backchannel logout request.</p></div>
<div class="paragraph"><p>It is important to note that any outstanding access tokens are not revoked by clicking <code>Logout all</code>.  They have to
expire naturally.  You have to push a <a href="#_revocation-policy">revocation policy</a> out to
clients, but that also only works with clients using the Red Hat Single Sign-On OIDC client adapter.</p></div>
<h3>Application Drilldown</h3><div class="paragraph"><p>On the <code>Sessions</code> page, you can also drill down to each client. This will bring you to the <code>Sessions</code> tab of that client.
Clicking on the <code>Show Sessions</code> button there allows you to see which users are logged into that application.</p></div>
<div class="paragraph"><div class="title">Application Sessions</div><p><span class="image"><img src="rhsso-images/application-sessions.png" alt="application sessions"></span></p></div>
<h3>User Drilldown</h3><div class="paragraph"><p>If you go to the <code>Sessions</code> tab of an individual user, you can also view the session information.</p></div>
<div class="paragraph"><div class="title">User Sessions</div><p><span class="image"><img src="rhsso-images/user-sessions.png" alt="user sessions"></span></p></div></section><section id="_revocation-policy"><h2>Revocation Policies</h2><div class="paragraph"><p>If your system is compromised you will want a way to revoke all sessions and access tokens that have been handed out.
You can do this by going to the <code>Revocation</code> tab of the <code>Sessions</code> screen.</p></div>
<div class="paragraph"><div class="title">Revocation</div><p><span class="image"><img src="rhsso-images/revocation.png" alt="revocation"></span></p></div>
<div class="paragraph"><p>You can only set a time-based revocation policy.  The console allows you to specify a time and date where any session
or token issued before that time and date is invalid.  The <code>Set to now</code> will set the policy to the current time and date.
The <code>Push</code> button will push this revocation policy to any registered OIDC client that has the Red Hat Single Sign-On
OIDC client adapter installed.</p></div></section><section id="_timeouts"><h2>Session and Token Timeouts</h2><div class="paragraph"><p>Red Hat Single Sign-On gives you fine grain control of session, cookie, and token timeouts.  This is all done on the
<code>Tokens</code> tab in the <code>Realm Settings</code> left menu item.</p></div>
<div class="paragraph"><div class="title">Tokens Tab</div><p><span class="image"><img src="rhsso-images/tokens-tab.png" alt="tokens tab"></span></p></div>
<div class="paragraph"><p>Let&#8217;s walk through each of the items on this page.</p></div>
<table class="tableblock frame-all grid-all" style="width:100%"><colgroup><col style="width:50%"><col style="width:50%"></colgroup><thead><tr><th class="tableblock halign-left valign-top">Configuration</th><th class="tableblock halign-left valign-top">Description</th></tr><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Revoke Refresh Token</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">For OIDC clients that are doing the refresh token flow, this flag, if on, will revoke that refresh token and issue another with the request that the client has to use.
 This basically means that refresh tokens have a one time use.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SSO Session Idle</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Also pertains to OIDC clients.  If the user is not active for longer than this timeout, the user session will be invalidated.  How is idle time checked?
A client requesting authentication will bump the idle timeout.  Refresh token requests will also bump the idle timeout.
There is a small window of time that is always added to the idle timeout before the session is actually invalidated (See note below).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SSO Session Max</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Maximum time before a user session is expired and invalidated.  This is a hard number and time.  It controls the maximum time
 a user session can remain active, regardless of activity.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SSO Session Idle Remember Me</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Same as the standard SSO Session Idle configuration but specific to logins with remember me enabled. It allows for the specification of longer
 session idle timeouts when remember me is selected during the login process. It is an optional configuration and if not set to a value
 bigger than 0 it uses the same idle timeout set in the SSO Session Idle configuration.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">SSO Session Max Remember Me</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Same as the standard SSO Session Max but specific to logins with remember me enabled. It allows for the specification of longer lived
 sessions when remember me is selected during the login process. It is an optional configuration and if not set to a value bigger than 0
 it uses the same session lifespan set in the SSO Session Max configuration.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Offline Session Idle</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">For <a href="#_offline-access">offline access</a>, this is the time the session is allowed to remain idle before the offline token is revoked.
There is a small window of time that is always added to the idle timeout before the session is actually invalidated (See note below).</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Offline Session Max Limited</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">For <a href="#_offline-access">offline access</a>, if this flag is on, Offline Session Max is enabled to control the maximum time the offline token can remain active, regardless of activity.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Offline Session Max</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">For <a href="#_offline-access">offline access</a>, this is the maximum time before the corresponding offline token is revoked. This is a hard number and time. It controls the maximum time the offline token can remain active, regardless of activity.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Access Token Lifespan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">When an OIDC access token is created, this value affects the expiration.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Access Token Lifespan For Implicit Flow</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">With the Implicit Flow no refresh token is provided. For this reason there&#8217;s a separate timeout for access tokens created with the Implicit Flow.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Client login timeout</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">This is the maximum time that a client has to finish the Authorization Code Flow in OIDC.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Login timeout</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Total time a login must take.  If authentication takes longer than this time then the user will have to start the authentication process over.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Login action timeout</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Maximum time a user can spend on any one page in the authentication process.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">User-Initiated Action Lifespan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Maximum time before an action permit sent by a user (e.g. forgot password e-mail) is expired. This value is recommended to be short because it is expected that the user would react to self-created action quickly.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Default Admin-Initiated Action Lifespan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Maximum time before an action permit sent to a user by an admin is expired. This value is recommended to be long to allow admins send e-mails for users that are currently offline. The default timeout can be overridden right before issuing the token.</p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock">Override User-Initiated Action Lifespan</p></td><td class="tableblock halign-left valign-top"><p class="tableblock">Permits the possibility of having independent timeouts per operation (e.g. e-mail verification, forgot password, user actions and Identity Provider E-mail Verification). This field is non mandatory and if nothing is specified it defaults to the value configured at <em>User-Initiated Action Lifespan</em>.</p></td></tr></table>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">For idle timeouts, there is a small window of time (2 minutes) during which the session is kept unexpired. For example, when you have
timeout set to 30 minutes, it will be actually 32 minutes before the session is expired. This is needed for some corner-case scenarios in
cluster and cross-datacenter environments, in cases where the token was refreshed on one cluster node for a very short time before the
expiration and the other cluster nodes would in the meantime incorrectly consider the session as expired, because they had not yet received
the message about successful refresh from the node which did the refresh.</td></tr></table></div></section><section id="_offline-access"><h2>Offline Access</h2><div class="paragraph"><p>Offline access is a feature described in <a href="https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess">OpenID Connect specification</a> .
The idea is that during login, your client application will request an Offline token instead of a classic Refresh token.
The application can save this offline token in a database or on disk and can use it later even if user is logged out.
This is useful if your application needs to do some "offline" actions on behalf of user even when the user is not online.
An example is a periodic backup of some data every night.</p></div>
<div class="paragraph"><p>Your application is responsible for persisting the offline token in some storage (usually a database) and then using it to manually retrieve new access token from Red Hat Single Sign-On server.</p></div>
<div class="paragraph"><p>The difference between a classic Refresh token and an Offline token is, that an offline token will never expire by default and is not subject of <code>SSO Session Idle timeout</code> and <code>SSO Session Max lifespan</code> .
The offline token is valid even after a user logout or server restart.
However by default you do need to use the offline token for a refresh token action at least once per 30 days (this value, <code>Offline Session Idle timeout</code>, can be changed in the administration console in the <code>Tokens</code> tab under <code>Realm Settings</code>).
Moreover, if you enable the option <code>Offline Session Max Limited</code>, then the offline token expires after 60 days regardless of using the offline token for a refresh token action (this value, <code>Offline Session Max</code>, can also be changed in the administration console in the Tokens tab under Realm Settings).
Also if you enable the option <code>Revoke refresh tokens</code>, then each offline token can be used just once. So after refresh, you always need to store the new offline token from refresh response into your DB instead of the previous one.</p></div>
<div class="paragraph"><p>Users can view and revoke offline tokens that have been granted by them in the <a href="#_account-service">User Account Service</a>.
The admin user can revoke offline tokens for individual users in admin console in the <code>Consents</code> tab of a particular user.
The admin can also view all the offline tokens issued in the <code>Offline Access</code> tab of each client.
Offline tokens can also be revoked by setting a <a href="#_revocation-policy">revocation policy</a>.</p></div>
<div class="paragraph"><p>To be able to issue an offline token, users need to have the role mapping for the realm-level role <code>offline_access</code>.
Clients also need to have that role in their scope. Finally, the client needs to have an <code>offline_access</code> client scope added as an <code>Optional
client scope</code> to it, which is done by default.</p></div>
<div class="paragraph"><p>The client can request an offline token by adding the parameter <code>scope=offline_access</code> when sending authorization request to Red Hat Single Sign-On.
The Red Hat Single Sign-On OIDC client adapter automatically adds this parameter when you use it to access secured URL of your application (i.e.
http://localhost:8080/customer-portal/secured?scope=offline_access). The Direct Access Grant and Service Accounts also
support offline tokens if you include <code>scope=offline_access</code> in the body of the authentication request.</p></div></section></section>
<section><section id="_user-storage-federation"><h2>User Storage Federation</h2><div class="paragraph"><p>Many companies have existing user databases that hold information about users and their passwords or other credentials.
In many cases, it is just not possible to migrate off of those existing stores to a pure Red Hat Single Sign-On deployment.
Red Hat Single Sign-On can federate existing external user databases.
Out of the box we have support for LDAP and Active Directory.  You can also code your own extension for any custom
user databases you might have using our User Storage SPI.</p></div><div class="paragraph"><p>The way it works is that when a user logs in, Red Hat Single Sign-On will look into its own internal user store to find the user.
If it can&#8217;t find it there it will iterate
over every User Storage provider you have configured for the realm until it finds a match.  Data from the external store is mapped into a common user model that is consumed by the Red Hat Single Sign-On
runtime.  This common user model can then be mapped to OIDC token claims and SAML assertion attributes.</p></div><div class="paragraph"><p>External user databases rarely have every piece of data needed to support all the features that Red Hat Single Sign-On has.
In this case, the User Storage Provider can opt to store some things locally in the Red Hat Single Sign-On user store.
Some providers even import the user locally and sync periodically with the external store.  All this depends on the capabilities of the provider and how its configured.  For example, your
external user store may not support OTP.  Depending on the provider, this OTP can be handled and stored by Red Hat Single Sign-On.</p></div></section><section id="_adding_a_provider"><h2>Adding a Provider</h2><div class="paragraph"><p>To add a storage provider go to the <code>User Federation</code> left menu item in the Admin Console.</p></div>
<div class="paragraph"><div class="title">User Federation</div><p><span class="image"><img src="rhsso-images/user-federation.png" alt="user federation"></span></p></div>
<div class="paragraph"><p>On the center, there is an <code>Add Provider</code> list box.  Choose the provider type you want to add and you will be brought to the configuration page of that provider.</p></div></section><section id="_dealing_with_provider_failures"><h2>Dealing with Provider Failures</h2><div class="paragraph"><p>If a User Storage Provider fails, that is, if your LDAP server is down, you may have trouble logging in and may not be able to view users in the admin console.
Red Hat Single Sign-On does not catch failures when using a Storage Provider to lookup a user.  It will abort the invocation.  So, if you have a Storage Provider with a higher
priority that fails during user lookup, the login or user query will fail entirely with an exception and abort.  It will not fail over to the next configured provider.</p></div>
<div class="paragraph"><p>The local Red Hat Single Sign-On user database is always searched first to resolve users before any LDAP or custom User Storage Provider.
You may want to consider creating an admin account that is stored in the local Red Hat Single Sign-On user database just in case any problems come up in connecting
to your LDAP and custom back ends.</p></div>
<div class="paragraph"><p>Each LDAP and custom User Storage Provider has an <code>enable</code> switch on its admin console page.  Disabling the User Storage Provider will skip the provider when
doing user queries so that you can view and login with users that might be stored in a different provider with lower priority.  If your provider is using an
<code>import</code> strategy and you disable it, imported users are still available for lookup, but only in read only mode.  You will not be able to modify these users until
you re-enable the provider.</p></div>
<div class="paragraph"><p>The reason why Red Hat Single Sign-On does not fail over if a Storage Provider lookup fails is that user databases often have duplicate usernames or duplicate emails between them.
This can cause security issues and unforeseen problems as the user may be loaded from one external store when the admin is expecting the user to be loaded from another.</p></div></section><section id="_ldap"><h2>LDAP and Active Directory</h2><div class="paragraph"><p>Red Hat Single Sign-On comes with a built-in LDAP/AD provider.  It is possible to federate multiple different LDAP servers in the same
Red Hat Single Sign-On realm.  You can map LDAP user attributes into the Red Hat Single Sign-On common user model.
By default, it maps username, email, first name, and last name, but you are free to configure additional <a href="#_ldap_mappers">mappings</a>.
The LDAP provider also supports password validation via LDAP/AD protocols and different storage, edit, and synchronization modes.</p></div>
<div class="paragraph"><p>To configure a federated LDAP store go to the Admin Console.
Click on the <code>User Federation</code> left menu option.
When you get to this page there is an <code>Add Provider</code> select box.
You should see <em>ldap</em> within this list.
Selecting <em>ldap</em> will bring you to the LDAP configuration page.</p></div>
<h3>Storage Mode</h3><div class="paragraph"><p>By default, Red Hat Single Sign-On will import users from LDAP into the local Red Hat Single Sign-On user database. This copy of the user
is either synchronized on demand, or through a periodic background task.
The one exception to this is passwords.  Passwords are not imported and password validation is
delegated to the LDAP server.  The benefits to this approach is that all Red Hat Single Sign-On features will work as any extra
per-user data that is needed can be stored locally.  This approach also reduces load on the LDAP server as uncached users are loaded
from the Red Hat Single Sign-On database the 2nd time they are accessed.  The only load your LDAP server will have is password validation.
The downside to this approach is that when a user is first queried, this will require a Red Hat Single Sign-On database insert.  The import will
also have to be synchronized with your LDAP server as needed.</p></div>
<div class="paragraph"><p>Alternatively, you can choose not to import users into the Red Hat Single Sign-On user database.  In this case, the common user model
that the  Red Hat Single Sign-On runtime uses is backed only by the LDAP server.  This means that if LDAP doesn&#8217;t support
a piece of data that a Red Hat Single Sign-On feature needs that feature will not work.
The benefit to this approach is that you do not have the overhead of importing and synchronizing a copy of the LDAP user into the
Red Hat Single Sign-On user database.</p></div>
<div class="paragraph"><p>This storage mode is controled by the <code>Import Users</code> switch.  Set to <code>On</code> to import users.</p></div>
<h3>Edit Mode</h3><div class="paragraph"><p>Users, through the <a href="#_account-service">User Account Service</a>, and admins through the Admin Console
have the ability to modify user metadata.  Depending on your setup you may or may not have LDAP update privileges.  The
<code>Edit Mode</code> configuration option defines the edit policy you have with your LDAP store.</p></div>
<div class="dlist"><dl><dt class="hdlist1">READONLY</dt><dd><p>Username, email, first name, last name, and other mapped attributes will be unchangeable.
Red Hat Single Sign-On will show an error anytime anybody tries to update these fields.
Also, password updates will not be supported.</p></dd><dt class="hdlist1">WRITABLE</dt><dd><p>Username, email, first name, last name, and other mapped attributes and passwords can all be updated and will be synchronized automatically with your LDAP store.</p></dd><dt class="hdlist1">UNSYNCED</dt><dd><p>Any changes to username, email, first name, last name, and passwords will be stored in Red Hat Single Sign-On local storage.
It is up to you to figure out how to synchronize back to LDAP. This allows Red Hat Single Sign-On deployments to support
updates of user metadata on a read-only LDAP server.  This option only applies when you are importing users from LDAP into the local Red Hat Single Sign-On user database.</p></dd></dl></div>
<h3>Other config options</h3><div class="dlist"><dl><dt class="hdlist1">Console Display Name</dt><dd><p>Name used when this provider is referenced in the admin console</p></dd><dt class="hdlist1">Priority</dt><dd><p>The priority of this provider when looking up users or adding a user.</p></dd><dt class="hdlist1">Sync Registrations</dt><dd><p>Does your LDAP support adding new users?  Click this switch if you want new users created by Red Hat Single Sign-On in the admin console or the registration page
to be added to LDAP.</p></dd><dt class="hdlist1">Allow Kerberos authentication</dt><dd><p>Enable Kerberos/SPNEGO authentication in realm with users data provisioned from LDAP.
More info in <a href="#_kerberos">Kerberos section</a>.</p></dd><dt class="hdlist1">Other options</dt><dd><p>The rest of the configuration options should be self explanatory.
You can mouseover the tooltips in Admin Console to see some more details about them.</p></dd></dl></div>
<h3>Connect to LDAP over SSL</h3><div class="paragraph"><p>When you configure a secured connection URL to your LDAP store(for example <code>ldaps://myhost.com:636</code> ),
Red Hat Single Sign-On will use SSL for the communication with LDAP server.
The important thing is to properly configure a truststore on the Red Hat Single Sign-On server side, otherwise Red Hat Single Sign-On can&#8217;t trust the SSL connection to LDAP.</p></div>
<div class="paragraph"><p>The global truststore for the Red Hat Single Sign-On can be configured with the Truststore SPI.  Please check out the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a> for more detail.
If you don&#8217;t configure the truststore SPI, the truststore will fallback to the default mechanism provided by Java (either the file provided by system property <code>javax.net.ssl.trustStore</code>
or the cacerts file from the JDK if the system property is not set).</p></div>
<div class="paragraph"><p>There is a configuration property <code>Use Truststore SPI</code> in the LDAP federation provider configuration, where you can choose whether the Truststore SPI is used.
By default, the value is <code>Only for ldaps</code>, which is fine for most deployments.  The Truststore SPI will only be used
if the connection to LDAP starts with <code>ldaps</code>.</p></div>
<h3>Sync of LDAP users to Red Hat Single Sign-On</h3><div class="paragraph"><p>If you have import enabled, the LDAP Provider will automatically take care of synchronization (import) of needed LDAP users into the Red Hat Single Sign-On local database.
As users log in, the LDAP provider will import the LDAP user
into the Red Hat Single Sign-On database and then authenticate against the LDAP password. This is the only time users will be imported.
If you go to the <code>Users</code> left menu item in the Admin Console and click the <code>View all users</code> button, you will only see those LDAP users that
have been authenticated at least once by Red Hat Single Sign-On.  It is implemented this way so that admins don&#8217;t accidentally try to import a huge LDAP DB of users.</p></div>
<div class="paragraph"><p>If you want to sync all LDAP users into the Red Hat Single Sign-On database, you may configure and enable the <code>Sync Settings</code> of the LDAP provider you configured.
There are 2 types of synchronization:</p></div>
<div class="dlist"><dl><dt class="hdlist1">Periodic Full sync</dt><dd><p>This will synchronize all LDAP users into Red Hat Single Sign-On DB.
Those LDAP users, which already exist in Red Hat Single Sign-On and were changed in LDAP directly will be updated in Red Hat Single Sign-On DB
(For example if user <code>Mary Kelly</code> was changed in LDAP to <code>Mary Smith</code>).</p></dd><dt class="hdlist1">Periodic Changed users sync</dt><dd><p>When syncing occurs, only those users that were created or updated after the last sync will be updated and/or imported.</p></dd></dl></div>
<div class="paragraph"><p>The best way to handle syncing is to click the <code>Synchronize all users</code> button when you first create the LDAP provider,
then set up a periodic sync of changed users.  The configuration page for your LDAP Provider has several options to support you.</p></div>
<h3>LDAP Mappers</h3><div class="paragraph"><p>LDAP mappers are <code>listeners</code>, which are triggered by the LDAP Provider at various points, provide another extension point to LDAP integration.
They are triggered when a user logs in via LDAP and needs to be imported, during Red Hat Single Sign-On initiated registration, or when a user is queried from the Admin Console.
When you create an LDAP Federation provider, Red Hat Single Sign-On will automatically provide set of built-in <code>mappers</code> for this provider.
You are free to change this set and create a new mapper or update/delete existing ones.</p></div>
<div class="dlist"><dl><dt class="hdlist1">User Attribute Mapper</dt><dd><p>This allows you to specify which LDAP attribute is mapped to which attribute of Red Hat Single Sign-On user.
So, for example, you can configure that LDAP attribute <code>mail</code> to the attribute <code>email</code> in the Red Hat Single Sign-On database.
For this mapper implementation, there is always a one-to-one mapping (one LDAP attribute is mapped to one Red Hat Single Sign-On attribute)</p></dd><dt class="hdlist1">FullName Mapper</dt><dd><p>This allows you to specify that the full name of the user, which is saved in some LDAP attribute (usually <code>cn</code> ) will be mapped to <code>firstName</code> and <code>lastname</code> attributes in the Red Hat Single Sign-On database.
Having <code>cn</code> to contain full name of user is a common case for some LDAP deployments.</p></dd><dt class="hdlist1">Role Mapper</dt><dd><p>This allows you to configure role mappings from LDAP into Red Hat Single Sign-On role mappings.
One Role mapper can be used to map LDAP roles (usually groups from a particular branch of LDAP tree) into roles corresponding to either realm roles or client roles of a specified client.
It&#8217;s not a problem to configure more Role mappers for the same LDAP provider.
So for example you can specify that role mappings from groups under
<code>ou=main,dc=example,dc=org</code> will be mapped to realm role mappings and role mappings from groups under
<code>ou=finance,dc=example,dc=org</code> will be mapped to client role mappings of client <code>finance</code> .</p></dd><dt class="hdlist1">Hardcoded Role Mapper</dt><dd><p>This mapper will grant a specified Red Hat Single Sign-On role to each Red Hat Single Sign-On user linked with LDAP.</p></dd><dt class="hdlist1">Group Mapper</dt><dd><p>This allows you to configure group mappings from LDAP into Red Hat Single Sign-On group mappings.
Group mapper can be used to map LDAP groups from a particular branch of an LDAP tree into groups in Red Hat Single Sign-On.
It will also propagate user-group mappings from LDAP into user-group mappings in Red Hat Single Sign-On.</p></dd><dt class="hdlist1">MSAD User Account Mapper</dt><dd><p>This mapper is specific to Microsoft Active Directory (MSAD). It&#8217;s able to tightly integrate the MSAD user account state
into the Red Hat Single Sign-On account state (account enabled, password is expired etc).
It&#8217;s using the <code>userAccountControl</code> and <code>pwdLastSet</code> LDAP attributes.  (both are specific to MSAD and are not LDAP standard).
For example if <code>pwdLastSet</code> is <code>0</code>, the Red Hat Single Sign-On user is required to update their password
and there will be an UPDATE_PASSWORD required action added to the user. If <code>userAccountControl</code> is
<code>514</code> (disabled account) the Red Hat Single Sign-On user is disabled as well.</p></dd><dt class="hdlist1">Certificate Mapper</dt><dd><p>This mapper is specific for mapping X.509 certificates. It will generally be used in conjunction with X.509 authentication
and <code>Full certificate in PEM format</code> as an identity source.
It behaves the same way as the <code>User Attribute Mapper</code>, but allows Red Hat Single Sign-On to filter for an LDAP attribute which stores
a certificate in either PEM or DER format. It is generally advised to enable <code>Always Read Value From LDAP</code> with this mapper.</p></dd></dl></div>
<div class="paragraph"><p>By default, there are User Attribute mappers that map basic Red Hat Single Sign-On user attributes like username, firstname, lastname, and email to corresponding LDAP attributes.
You are free to extend these and provide additional attribute mappings.
Admin console provides tooltips, which should help with configuring the corresponding mappers.</p></div>
<h3>Password Hashing</h3><div class="paragraph"><p>When the password of user is updated from Red Hat Single Sign-On and sent to LDAP, it is always sent in plain-text. This is different from
updating the password to built-in Red Hat Single Sign-On database, when the hashing and salting is applied to the password before it is sent to DB.
In the case of LDAP, the Red Hat Single Sign-On relies on the LDAP server to provide hashing and salting of passwords.</p></div>
<div class="paragraph"><p>Most of LDAP servers (Microsoft Active Directory, RHDS, FreeIPA) provide this by default. Some others (OpenLDAP, ApacheDS) may store the passwords
in plain-text by default and you may need to explicitly enable password hashing for them. See the documentation of your LDAP server more details.</p></div></section><section id="_sssd"><h2>SSSD and FreeIPA Identity Management Integration</h2><div class="paragraph"><p>Red Hat Single Sign-On also comes with a built-in <a href="https://fedoraproject.org/wiki/Features/SSSD">SSSD</a> (System Security Services Daemon) plugin. SSSD is part of the latest Fedora or Red Hat Enterprise Linux and provides access to multiple identity and authentication providers. It provides benefits such as failover and offline support. To see configuration options and for more information see <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system-level_authentication_guide/sssd">the Red Hat Enterprise Linux Identity Management documentation</a>.</p></div>
<div class="paragraph"><p>SSSD also integrates with the FreeIPA identity management (IdM) server, providing authentication and access control. For Red Hat Single Sign-On, we benefit from this integration authenticating against PAM services and retrieving user data from SSSD. For more information about using Red Hat Identity Management in Linux environments, see <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/linux_domain_identity_authentication_and_policy_guide/index">the Red Hat Enterprise Linux Identity Management documentation</a>.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/keycloak-sssd-freeipa-integration-overview.png" alt="keycloak sssd freeipa integration overview"></span></p></div>
<div class="paragraph"><p>Most of the communication between Red Hat Single Sign-On and SSSD occurs through read-only D-Bus interfaces. For this reason, the only way to provision and update users is to use the FreeIPA/IdM administration interface. By default, like the LDAP federation provider, it is set up only to import username, email, first name, and last name.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Groups and roles are automatically registered, but not synchronized, so any changes made by the Red Hat Single Sign-On administrator directly in Red Hat Single Sign-On is not synchronized with SSSD.</td></tr></table></div>
<div class="paragraph"><p>Information on how to configure the FreeIPA/IdM server follows.</p></div>
<h3>FreeIPA/IdM Server</h3><div class="paragraph"><p>As a matter of simplicity, a <a href="https://hub.docker.com/r/freeipa/freeipa-server/">FreeIPA Docker image</a> already available is used. To set up a server, see the <a href="https://www.freeipa.org/page/Quick_Start_Guide">FreeIPA documentation</a>.</p></div>
<div class="paragraph"><p>Running a FreeIPA server with Docker requires this command:</p></div>
<div class="literalblock"><div class="content"><pre>docker run --name freeipa-server-container -it \
-h server.freeipa.local -e PASSWORD=YOUR_PASSWORD \
-v /sys/fs/cgroup:/sys/fs/cgroup:ro \
-v /var/lib/ipa-data:/data:Z freeipa/freeipa-server</pre></div></div>
<div class="paragraph"><p>The parameter <code>-h</code> with <code>server.freeipa.local</code> represents the FreeIPA/IdM server hostname. Be sure to change <code>YOUR_PASSWORD</code> to a password of your choosing.</p></div>
<div class="paragraph"><p>After the container starts, change <code>/etc/hosts</code> to:</p></div>
<div class="literalblock"><div class="content"><pre>x.x.x.x     server.freeipa.local</pre></div></div>
<div class="paragraph"><p>If you do not make this change, you must set up a DNS server.</p></div>
<div class="paragraph"><p>So that the SSSD federation provider is started and running on Red Hat Single Sign-On you must enroll your Linux machine in the IPA domain:</p></div>
<div class="literalblock"><div class="content"><pre>ipa-client-install --mkhomedir -p admin -w password</pre></div></div>
<div class="paragraph"><p>To ensure that everything is working as expected, on the client machine, run:</p></div>
<div class="literalblock"><div class="content"><pre>kinit admin</pre></div></div>
<div class="paragraph"><p>You should be prompted for the password. After that, you can add users to the IPA server using this command:</p></div>
<div class="literalblock"><div class="content"><pre>$ ipa user-add john --first=John --last=Smith --email=john@smith.com --phone=042424242 --street="Testing street" \      --city="Testing city" --state="Testing State" --postalcode=0000000000</pre></div></div>
<h3>SSSD and D-Bus</h3><div class="paragraph"><p>As mentioned previously, the federation provider obtains the data from SSSD using D-BUS and authentication occurs using PAM.</p></div>
<div class="paragraph"><p>First, you have to install the sssd-dbus RPM, which allows information from SSSD to be transmitted over the system bus.</p></div>
<div class="literalblock"><div class="content"><pre>$ sudo yum install sssd-dbus</pre></div></div>
<div class="paragraph"><p>You must run this provisioning script:</p></div>
<pre class="highlight listingblock"><code>$ .../bin/federation-sssd-setup.sh</code></pre>
<div class="paragraph"><p>This script makes the necessary changes to <code>/etc/sssd/sssd.conf</code>:</p></div>
<div class="literalblock"><div class="content"><pre>[domain/your-hostname.local]
...
ldap_user_extra_attrs = mail:mail, sn:sn, givenname:givenname, telephoneNumber:telephoneNumber
...
[sssd]
services = nss, sudo, pam, ssh, ifp
...
[ifp]
allowed_uids = root, yourOSUsername
user_attributes = +mail, +telephoneNumber, +givenname, +sn</pre></div></div>
<div class="paragraph"><p>Also, a <code>keycloak</code> file is included under <code>/etc/pam.d/</code>:</p></div>
<div class="literalblock"><div class="content"><pre>auth    required   pam_sss.so
account required   pam_sss.so</pre></div></div>
<div class="paragraph"><p>Ensure everything is working as expected by running <code>dbus-send</code>:</p></div>
<div class="literalblock"><div class="content"><pre>sudo dbus-send --print-reply --system --dest=org.freedesktop.sssd.infopipe /org/freedesktop/sssd/infopipe org.freedesktop.sssd.infopipe.GetUserGroups string:john</pre></div></div>
<div class="paragraph"><p>You should be able to see the user&#8217;s group. If this command returns a timeout or an error, it means that the federation provider will also not be able to retrieve anything on Red Hat Single Sign-On.</p></div>
<div class="paragraph"><p>Most of the time this occurs because the machine was not enrolled in the FreeIPA IdM server or you do not have permission to access the SSSD service.</p></div>
<div class="paragraph"><p>If you do not have permission, ensure that the user running Red Hat Single Sign-On is included in the <code>/etc/sssd/sssd.conf</code> file in the following section:</p></div>
<div class="literalblock"><div class="content"><pre>[ifp]
allowed_uids = root, your_username</pre></div></div>
<h3>Enabling the SSSD Federation Provider</h3><div class="paragraph"><p>Red Hat Single Sign-On uses DBus-Java to communicate at a low level with D-Bus, which depends on the <a href="http://www.matthew.ath.cx/projects/java/">Unix Sockets Library</a>.</p></div>
<div class="paragraph"><p>Before enabling the SSSD Federation provider, you must install the RPM for this library:</p></div>
<div class="literalblock"><div class="content"><pre>$ sudo yum install rh-sso7-libunix-dbus-java</pre></div></div>
<div class="paragraph"><p>For authentication with PAM Red Hat Single Sign-On uses JNA. Be sure you have this package installed:</p></div>
<div class="literalblock"><div class="content"><pre>$ sudo yum install jna</pre></div></div>
<div class="paragraph"><p>Use <code>sssctl user-checks</code> command to validate your setup:</p></div>
<div class="literalblock"><div class="content"><pre>$ sudo sssctl user-checks admin -s keycloak</pre></div></div></section><section id="_configuring_a_federated_sssd_store"><h2>Configuring a Federated SSSD Store</h2><div class="paragraph"><p>After installation, you need to configure a federated SSSD store.</p></div>
<div class="paragraph"><p>To configure a federated SSSD store, complete the following steps:</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Navigate to the Administration Console.</p></li><li><p>From the left menu, select <strong>User Federation.</strong></p></li><li><p>From the <strong>Add Provider</strong> dropdown list, select <strong>sssd.</strong> The sssd configuration page opens.</p></li><li><p>Click <strong>Save</strong>.</p></li></ol></div>
<div class="paragraph"><p>Now you can authenticate against Red Hat Single Sign-On using FreeIPA/IdM credentials.</p></div></section><section id="_custom_providers"><h2>Custom Providers</h2><div class="paragraph"><p>Red Hat Single Sign-On does have an SPI for User Storage Federation that you can use to write your own custom providers.
You can find documentation for this in our <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a>.</p></div></section></section>
<section><section id="_auditing_and_events"><h2>Auditing and Events</h2><div class="paragraph"><p>Red Hat Single Sign-On provides a rich set of auditing capabilities.  Every single login action can be recorded and stored in
the database and reviewed in the Admin Console.  All admin actions can also be recorded and reviewed.  There is also a Listener SPI
with which plugins can listen for these events and perform some action.  Built-in listeners include a simple log file and the ability
to send an email if an event occurs.</p></div></section><section id="_login_events"><h2>Login Events</h2><div class="paragraph"><p>Login events occur for things like when a user logs in successfully, when somebody enters in a bad password, or when a user account
is updated.  Every single event that happens to a user can be recorded and viewed.  By default, no events are stored
or viewed in the Admin Console.  Only error events are logged to the console and the server&#8217;s log file.  To start
persisting  you&#8217;ll need to enable storage.  Go to the <code>Events</code> left menu item and select the <code>Config</code> tab.</p></div>
<div class="paragraph"><div class="title">Event Configuration</div><p><span class="image"><img src="rhsso-images/login-events-config.png" alt="login events config"></span></p></div>
<div class="paragraph"><p>To start storing events you&#8217;ll need to turn the <code>Save Events</code> switch to on under the <code>Login Events Settings</code>.</p></div>
<div class="paragraph"><div class="title">Save Events</div><p><span class="image"><img src="rhsso-images/login-events-settings.png" alt="login events settings"></span></p></div>
<div class="paragraph"><p>The <code>Saved Types</code> field allows you to specify which event types you want to store in the event store.  The <code>Clear events</code>
button allows you to delete all the events in the database. The <code>Expiration</code> field allows you to specify how long you want
to keep events stored.  Once you&#8217;ve enabled storage of login events and decided on your settings, don&#8217;t forget to click
the <code>Save</code> button on the bottom of this page.</p></div>
<div class="paragraph"><p>To view events, go to the <code>Login Events</code> tab.</p></div>
<div class="paragraph"><div class="title">Login Events</div><p><span class="image"><img src="rhsso-images/login-events.png" alt="login events"></span></p></div>
<div class="paragraph"><p>As you can see, there&#8217;s a lot of information stored and, if you are storing every event, there are a lot of events stored for
each login action.  The <code>Filter</code> button on this page allows you to filter which events you are actually interested in.</p></div>
<div class="paragraph"><div class="title">Login Event Filter</div><p><span class="image"><img src="rhsso-images/login-events-filter.png" alt="login events filter"></span></p></div>
<div class="paragraph"><p>In this screenshot, we&#8217;re filtering only <code>Login</code> events.  Clicking the <code>Update</code> button runs the filter.</p></div>
<h3>Event Types</h3><div class="paragraph"><p>Login events:</p></div>
<div class="ulist"><ul><li><p>Login - A user has logged in.</p></li><li><p>Register - A user has registered.</p></li><li><p>Logout - A user has logged out.</p></li><li><p>Code to Token - An application/client has exchanged a code for a token.</p></li><li><p>Refresh Token - An application/client has refreshed a token.</p></li></ul></div>
<div class="paragraph"><p>Account events:</p></div>
<div class="ulist"><ul><li><p>Social Link - An account has been linked to a social provider.</p></li><li><p>Remove Social Link - A social provider has been removed from an account.</p></li><li><p>Update Email - The email address for an account has changed.</p></li><li><p>Update Profile - The profile for an account has changed.</p></li><li><p>Send Password Reset - A password reset email has been sent.</p></li><li><p>Update Password - The password for an account has changed.</p></li><li><p>Update TOTP - The TOTP settings for an account have changed.</p></li><li><p>Remove TOTP - TOTP has been removed from an account.</p></li><li><p>Send Verify Email - An email verification email has been sent.</p></li><li><p>Verify Email - The email address for an account has been verified.</p></li></ul></div>
<div class="paragraph"><p>For all events there is a corresponding error event.</p></div>
<h3>Event Listener</h3><div class="paragraph"><p>Event listeners listen for events and perform an action based on that event.  There are two built-in
listeners that come with Red Hat Single Sign-On: Logging Event Listener and Email Event Listener.</p></div>
<div class="paragraph"><p>The Logging Event Listener writes to a log file whenever an error event occurs and is enabled by default.
Here&#8217;s an example log message:</p></div>
<pre class="highlight listingblock"><code>11:36:09,965 WARN  [org.keycloak.events] (default task-51) type=LOGIN_ERROR, realmId=master,
                    clientId=myapp,
                    userId=19aeb848-96fc-44f6-b0a3-59a17570d374, ipAddress=127.0.0.1,
                    error=invalid_user_credentials, auth_method=openid-connect, auth_type=code,
                    redirect_uri=http://localhost:8180/myapp,
                    code_id=b669da14-cdbb-41d0-b055-0810a0334607, username=admin</code></pre>
<div class="paragraph"><p>This logging is very useful if you want to use a tool like Fail2Ban to detect if there is a hacker bot somewhere that
is trying to guess user passwords.  You can parse the log file for <code>LOGIN_ERROR</code> and pull out the IP Address. Then feed this information
into Fail2Ban so that it can help prevent attacks.</p></div>
<div class="paragraph"><p>The Email Event Listener sends an email to the user&#8217;s account when an event occurs.
The Email Event Listener only supports the following events at the moment:</p></div>
<div class="ulist"><ul><li><p>Login Error</p></li><li><p>Update Password</p></li><li><p>Update TOTP</p></li><li><p>Remove TOTP</p></li></ul></div>
<div class="paragraph"><p>To enable the Email Listener go to the <code>Config</code> tab and click on the <code>Event Listeners</code> field.  This will show a drop down list box
where you can select email.</p></div>
<div class="paragraph"><p>You can exclude one or more events by editing the <code>standalone.xml</code>, <code>standalone-ha.xml</code>, or <code>domain.xml</code>
that comes with your distribution and adding for example:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;spi name="eventsListener"&gt;
  &lt;provider name="email" enabled="true"&gt;
    &lt;properties&gt;
      &lt;property name="exclude-events" value="[&amp;quot;UPDATE_TOTP&amp;quot;,&amp;quot;REMOVE_TOTP&amp;quot;]"/&gt;
    &lt;/properties&gt;
  &lt;/provider&gt;
&lt;/spi&gt;</code></pre>
<div class="paragraph"><p>See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_installation_and_configuration_guide/">Server Installation and Configuration Guide</a> for more details on
where the <code>standalone.xml</code>, <code>standalone-ha.xml</code>, or <code>domain.xml</code> file lives.</p></div></section><section id="_admin_events"><h2>Admin Events</h2><div class="paragraph"><p>Any action an admin performs within the admin console can be recorded for auditing purposes.
The Admin Console performs administrative functions by invoking on the Red Hat Single Sign-On REST interface.  Red Hat Single Sign-On
audits these REST invocations.  The resulting events can then be viewed in the Admin Console.</p></div>
<div class="paragraph"><p>To enable auditing of Admin actions, go to the <code>Events</code> left menu item and select the <code>Config</code> tab.</p></div>
<div class="paragraph"><div class="title">Event Configuration</div><p><span class="image"><img src="rhsso-images/login-events-config.png" alt="login events config"></span></p></div>
<div class="paragraph"><p>In the <code>Admin Events Settings</code> section, turn on the <code>Save Events</code> switch.</p></div>
<div class="paragraph"><div class="title">Admin Event Configuration</div><p><span class="image"><img src="rhsso-images/admin-events-settings.png" alt="admin events settings"></span></p></div>
<div class="paragraph"><p>The <code>Include Representation</code> switch will include any JSON document that is sent through the admin REST API.  This allows you to view exactly what an admin has done, but can lead to a lot of information stored in the
database.  The <code>Clear admin events</code> button allows you to wipe out the current information stored.</p></div>
<div class="paragraph"><p>To view the admin events go to the <code>Admin Events</code> tab.</p></div>
<div class="paragraph"><div class="title">Admin Events</div><p><span class="image"><img src="rhsso-images/admin-events.png" alt="admin events"></span></p></div>
<div class="paragraph"><p>If the <code>Details</code> column has a <code>Representation</code> box, you can click on that to view the JSON that was sent with that operation.</p></div>
<div class="paragraph"><div class="title">Admin Representation</div><p><span class="image"><img src="rhsso-images/admin-events-representation.png" alt="admin events representation"></span></p></div>
<div class="paragraph"><p>You can also filter for the events you are interested in by clicking the <code>Filter</code> button.</p></div>
<div class="paragraph"><div class="title">Admin Event Filter</div><p><span class="image"><img src="rhsso-images/admin-events-filter.png" alt="admin events filter"></span></p></div></section></section>
<section><section id="_export_import"><h2>Export and Import</h2><div class="paragraph"><p>Red Hat Single Sign-On has the ability to export and import the entire database.
This can be especially useful if you want to migrate your whole Red Hat Single Sign-On database from one environment to another or migrate to a different database (for example from MySQL to Oracle). Export and import is triggered at server boot time  and its parameters are passed in via Java system properties.
It is important to note that because import and export happens at server startup, no other actions should be taken on the server or the database while this happens.</p></div><div class="paragraph"><p>You can export/import your database either to:</p></div><div class="ulist"><ul><li><p>Directory on local filesystem</p></li><li><p>Single JSON file on your filesystem</p></li></ul></div><div class="paragraph"><p>When importing using the directory strategy, note that the files need to follow the naming convention specified below.
If you are importing files which were previously exported, the files already follow this convention.</p></div><div class="ulist"><ul><li><p>&lt;REALM_NAME&gt;-realm.json, such as "acme-roadrunner-affairs-realm.json" for the realm named "acme-roadrunner-affairs"</p></li><li><p>&lt;REALM_NAME&gt;-users-&lt;INDEX&gt;.json, such as "acme-roadrunner-affairs-users-0.json" for the first users file of the realm named "acme-roadrunner-affairs"</p></li></ul></div><div class="paragraph"><p>If you export to a directory, you can also specify the number of users that will be stored in each JSON file.</p></div><div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">If you have bigger amount of users in your database (500 or more), it&#8217;s highly recommended to export into directory rather
      than to single file. Exporting into single file may lead to the very big file. Also the directory provider is using separate transaction for each "page" (file with users),
      which leads to much better performance.
      Default count of users per file (and transaction) is 50, which showed us best performance, but you have possibility to override (See below).
      Exporting to single file is using one transaction per whole export and one per whole import, which results in bad performance with large amount of users.</td></tr></table></div><div class="paragraph"><p>To export into unencrypted directory you can use:</p></div><pre class="highlight listingblock"><code>bin/standalone.sh -Dkeycloak.migration.action=export
-Dkeycloak.migration.provider=dir -Dkeycloak.migration.dir=&lt;DIR TO EXPORT TO&gt;</code></pre><div class="paragraph"><p>And similarly for import just use <code>-Dkeycloak.migration.action=import</code> instead of <code>export</code> .
To export into single JSON file you can use:</p></div><pre class="highlight listingblock"><code>bin/standalone.sh -Dkeycloak.migration.action=export
-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=&lt;FILE TO EXPORT TO&gt;</code></pre><div class="paragraph"><p>Here&#8217;s an example of importing:</p></div><pre class="highlight listingblock"><code>bin/standalone.sh -Dkeycloak.migration.action=import
-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=&lt;FILE TO IMPORT&gt;
-Dkeycloak.migration.strategy=OVERWRITE_EXISTING</code></pre><div class="paragraph"><p>Other available options are:</p></div><div class="dlist"><dl><dt class="hdlist1">-Dkeycloak.migration.realmName</dt><dd><p>This property is used if you want to export just one specified realm instead of all.
If not specified, then all realms will be exported.</p></dd><dt class="hdlist1">-Dkeycloak.migration.usersExportStrategy</dt><dd><p>This property is used to specify where users are exported.
Possible values are:</p><div class="ulist"><ul><li><p>DIFFERENT_FILES - Users will be exported into different files according to the maximum number of users per file. This is default value.</p></li><li><p>SKIP - Exporting of users will be skipped completely.</p></li><li><p>REALM_FILE - All users will be exported to same file with the realm settings. (The result will be a file like "foo-realm.json" with both realm data and users.)</p></li><li><p>SAME_FILE - All users will be exported to same file but different from the realm file. (The result will be a file like "foo-realm.json" with realm data and "foo-users.json" with users.)</p></li></ul></div></dd><dt class="hdlist1">-Dkeycloak.migration.usersPerFile</dt><dd><p>This property is used to specify the number of users per file (and also per DB transaction). It&#8217;s 50 by default.
It&#8217;s used only if usersExportStrategy is DIFFERENT_FILES</p></dd><dt class="hdlist1">-Dkeycloak.migration.strategy</dt><dd><p>This property is used during import.
It can be used to specify how to proceed if a realm with same name already exists in the database where you are going to import data.
Possible values are:</p><div class="ulist"><ul><li><p>IGNORE_EXISTING - Ignore importing if a realm of this name already exists.</p></li><li><p>OVERWRITE_EXISTING - Remove existing realm and import it again with new data from the JSON file.
If you want to fully migrate one environment to another and ensure that the new environment will contain the same data
as the old one, you can specify this.</p></li></ul></div></dd></dl></div><div class="paragraph"><p>When importing realm files that weren&#8217;t exported before, the option <code>keycloak.import</code> can be used.
If more than one realm file needs to be imported, a comma separated list of file names can be specified.
This is more appropriate than the cases before, as this will happen only after the master realm has been initialized.
Examples:</p></div><div class="ulist"><ul><li><p>-Dkeycloak.import=/tmp/realm1.json</p></li><li><p>-Dkeycloak.import=/tmp/realm1.json,/tmp/realm2.json</p></li></ul></div></section><section id="_admin_console_exportimport"><h2>Admin console export/import</h2><div class="paragraph"><p>Import of most resources can be performed from the admin console as well as export of most resources.
Export of users is not supported.</p></div>
<div class="paragraph"><p>Note: Attributes containing secrets or private information will be masked in export file. Export files obtained via Admin Console
are thus not appropriate for backups or data transfer between servers. Only boot-time exports are appropriate for that.</p></div>
<div class="paragraph"><p>The files created during a "startup" export can also be used to import from the admin UI.
This way, you can export from one realm and import to another realm. Or, you can export from one server and import to another.
Note: The admin console export/import allows just one realm per file.</p></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">The admin console import allows you to "overwrite" resources if you choose.
Use this feature with caution, especially on a production system. Export .json files from Admin Console Export operation
are generally not appropriate for data import since they contain invalid values for secrets.</td></tr></table></div>
<div class="admonitionblock warning"><table><tr><td class="icon"><div class="title">Warning</div></td><td class="content">The admin console export allows you to export clients, groups, and roles. If there is a great number of any of these
assets in your realm, the operation may take some time to complete. During that time server may not be responsive to user requests.
Use this feature with caution, especially on a production system.</td></tr></table></div></section></section>
<section><section id="_vault-administration"><h2>Using Vault to Obtain Secrets</h2><div class="paragraph"><p>Several fields in the administration support obtaining the value of a secret from an external vault.</p></div><div class="paragraph"><p>To obtain a secret from a vault instead of entering it directly, enter
the following specially crafted string into the appropriate field:
<code><strong>${vault.</strong><em>entry-name</em><strong>}</strong></code> where you replace the <code><em>entry-name</em></code>
with the name of the secret as recognized by the vault.</p></div><div class="paragraph"><p>Currently, the secret can be obtained from the vault in the following fields:</p></div><div class="dlist"><dl><dt class="hdlist1">SMTP password</dt><dd><p>In realm <a href="#_email">SMTP settings</a></p></dd><dt class="hdlist1">LDAP bind credential</dt><dd><p>In <a href="#_ldap">LDAP settings</a> of LDAP-based user federation.</p></dd><dt class="hdlist1">OIDC identity provider secret</dt><dd><p>In <em>Client Secret</em> inside identity provider <a href="#_identity_broker_oidc">OpenID Connect Config</a></p></dd></dl></div><div class="paragraph"><p>To use a vault, a vault provider must be registered within Red Hat Single Sign-On.
It is possible to either use a built-in provider described below or
implement your own provider. See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more information.</p></div></section><section id="_kubernetes_openshift_files_plaintext_vault_provider"><h2>Kubernetes / OpenShift files plaintext vault provider</h2><div class="paragraph"><p>Red Hat Single Sign-On supports vault implementation for <a href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes secrets</a>. These secrets
can be mounted as data volumes, and they appear as a directory with a flat file structure, where each secret is represented by a file whose name is the secret name, and contents of that file is the secret value.</p></div>
<div class="paragraph"><p>The files within this directory have to be named as secret name prefixed by realm name and an underscore. All underscores within the secret name or the realm name have to be doubled in the file name. For example, for a field within a realm called <code>sso_realm</code>, a reference to a secret with name <code>secret-name</code> would be written as <code>${vault.secret-name}</code>, and the file name looked up would be <code>sso__realm_secret-name</code> (note the underscore doubled in realm name).</p></div>
<div class="paragraph"><p>To use this type of secret store, you have to declare the <code>files-plaintext</code> vault provider in standalone.xml, and set its parameter for the directory that contains the mounted volume. The following example shows the <code>files-plaintext</code>
provider with the directory where vault files are searched for set to <code>standalone/configuration/vault</code> relative to Red Hat Single Sign-On base directory:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;spi name="vault"&gt;
    &lt;default-provider&gt;files-plaintext&lt;/default-provider&gt;
    &lt;provider name="files-plaintext" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="dir" value="${jboss.home.dir}/standalone/configuration/vault/" /&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</code></pre>
<div class="paragraph"><p>Here is the equivalent configuration using CLI commands:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">/subsystem=keycloak-server/spi=vault/:add
/subsystem=keycloak-server/spi=vault/provider=files-plaintext/:add(enabled=true,properties={dir =&gt; "${jboss.home.dir}/standalone/configuration/vault"})</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">There is at most one vault provider active per Red Hat Single Sign-On instance
at any given time, and the vault provider in each instance within the cluster
have to be configured consistently.</td></tr></table></div></section></section>
<section><section id="_account-service"><h2>User Account Service</h2><div class="paragraph"><p>Red Hat Single Sign-On has a built-in User Account Service which every user has access to.  This service allows users to manage their account,
change their credentials, update their profile, and view their login sessions.  The URL to this service is <code>&lt;server-root&gt;/auth/realms/{realm-name}/account</code>.</p></div><div class="paragraph"><div class="title">Account Service</div><p><span class="image"><img src="rhsso-images/account-service-profile.png" alt="account service profile"></span></p></div><div class="paragraph"><p>The initial page is the user&#8217;s profile, which is the <code>Account</code> left menu item.  This is where they specify basic data about themselves.  This screen can be extended
to allow the user to manage additional attributes.  See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more details.</p></div><div class="paragraph"><p>The <code>Password</code> left menu item allows the user to change their password.</p></div><div class="paragraph"><div class="title">Password Update</div><p><span class="image"><img src="rhsso-images/account-service-password.png" alt="account service password"></span></p></div><div class="paragraph"><p>The <code>Authenticator</code> menu item allows the user to set up OTP if they desire.  This will only show up if OTP is a valid authentication mechanism for your realm.
Users are given directions to install <a href="https://freeotp.github.io/">FreeOTP</a> or <a href="https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2">Google Authenticator</a> on their mobile device to be their OTP generator.
The QR code you see in the screen shot can be scanned into the FreeOTP or Google Authenticator mobile application for nice and easy setup.</p></div><div class="paragraph"><div class="title">OTP Authenticator</div><p><span class="image"><img src="rhsso-images/account-service-authenticator.png" alt="account service authenticator"></span></p></div><div class="paragraph"><p>The <code>Federated Identity</code> menu item allows the user to link their account with an <a href="#_identity_broker">identity broker</a> (this is usually used to link social provider
accounts together).  This will show the list of external identity providers you have configured for your realm.</p></div><div class="paragraph"><div class="title">Federated Identity</div><p><span class="image"><img src="rhsso-images/account-service-federated-identity.png" alt="account service federated identity"></span></p></div><div class="paragraph"><p>The <code>Sessions</code> menu item allows the user to view and manage which devices are logged in and from where.  They can perform logout of these sessions from this screen too.</p></div><div class="paragraph"><div class="title">Sessions</div><p><span class="image"><img src="rhsso-images/account-service-sessions.png" alt="account service sessions"></span></p></div><div class="paragraph"><p>The <code>Applications</code> menu item shows users which applications they have access to.</p></div><div class="paragraph"><div class="title">Applications</div><p><span class="image"><img src="rhsso-images/account-service-apps.png" alt="account service apps"></span></p></div></section><section id="_themeable"><h2>Themeable</h2><div class="paragraph"><p>Like all UIs in Red Hat Single Sign-On, the User Account Service is completely themeable and internationalizable.
See the <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a> for more details.</p></div></section></section>
<section><section id="_threat_model_mitigation"><h2>Threat Model Mitigation</h2><div class="paragraph"><p>This chapter discusses possible security vulnerabilities any authentication server could have and how Red Hat Single Sign-On
mitigates those vulnerabilities.
A good list of potential vulnerabilities and what security implementations should do to mitigate them can be found in
the <a href="https://tools.ietf.org/html/rfc6819">OAuth 2.0 Threat Model</a> document put out by the IETF.
Many of those vulnerabilities are discussed here.</p></div></section><section id="_host"><h2>Host</h2><div class="paragraph"><p>Red Hat Single Sign-On uses the public hostname for a number of things. For example, in the token issuer fields and URLs sent in
password reset emails.</p></div>
<div class="paragraph"><p>By default, the hostname is based on the request headers and there is no check to make sure this hostname is valid.</p></div>
<div class="paragraph"><p>If you are not using a load balancer or proxy in front of Red Hat Single Sign-On that prevents invalid host headers, you must
explicitly configure what hostnames should be accepted.</p></div>
<div class="paragraph"><p>The Hostname SPI provides a way to configure the hostname for a request. Out of the box there are two providers. These are
request and fixed. It is also possible to develop your own provider in the case the built-in providers do not provide
the functionality needed.</p></div>
<h3>Request provider</h3><div class="paragraph"><p>This is the default hostname provider and uses request headers to determine the hostname. As it uses the headers from
the request it is important to use this in combination with a proxy or a filter that rejects invalid hostnames.</p></div>
<div class="paragraph"><p>It is beyond the scope of this documentation to provide instructions on how to configure valid hostnames for a proxy. To
configure it in a filter you need to edit standalone.xml to set permitted aliases for the server. The following example
will only permit requests to <code>auth.example.com</code>:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
    &lt;server name="default-server" default-host="ignore"&gt;
        ...
        &lt;host name="default-host" alias="auth.example.com"&gt;
            &lt;location name="/" handler="welcome-content"/&gt;
            &lt;http-invoker security-realm="ApplicationRealm"/&gt;
        &lt;/host&gt;
    &lt;/server&gt;
&lt;/subsystem&gt;</code></pre>
<div class="paragraph"><p>The changes that have been made from the default config is to add the attribute <code>default-host="ignore"</code> and update the
attribute <code>alias</code>. <code>default-host="ignore"</code> prevents unknown hosts from being handled, while <code>alias</code> is used to list the
accepted hosts.</p></div>
<div class="paragraph"><p>Here is the equivalent configuration using CLI commands:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">/subsystem=undertow/server=default-server:write-attribute(name=default-host,value=ignore)
/subsystem=undertow/server=default-server/host=default-host:write-attribute(name=alias,value=[auth.example.com]

:reload</code></pre>
<h3>Fixed provider</h3><div class="paragraph"><p>The fixed provider makes it possible to configure a fixed hostname. Unlike the request provider the fixed
provider allows internal applications to invoke Red Hat Single Sign-On on an alternative URL (for example an internal IP
address). It is also possible to override the hostname for a specific realm through the configuration of the realm in the
admin console.</p></div>
<div class="paragraph"><p>This is the recommended provider to use in production.</p></div>
<div class="paragraph"><p>To change to the fixed provider and configure the hostname edit standalone.xml. The following example shows the fixed
provider with the hostname set to auth.example.com:</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;spi name="hostname"&gt;
    &lt;default-provider&gt;fixed&lt;/default-provider&gt;
    &lt;provider name="fixed" enabled="true"&gt;
        &lt;properties&gt;
            &lt;property name="hostname" value="auth.example.com"/&gt;
            &lt;property name="httpPort" value="-1"/&gt;
            &lt;property name="httpsPort" value="-1"/&gt;
        &lt;/properties&gt;
    &lt;/provider&gt;
&lt;/spi&gt;</code></pre>
<div class="paragraph"><p>Here is the equivalent configuration using CLI commands:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">/subsystem=keycloak-server/spi=hostname:write-attribute(name=default-provider, value="fixed")
/subsystem=keycloak-server/spi=hostname/provider=fixed:write-attribute(name=properties.hostname,value="auth.example.com")</code></pre>
<div class="paragraph"><p>By default the <code>httpPort</code> and <code>httpsPort</code> are received from the request. As long as any proxies are configured correctly
it should not be necessary to change this. It is possible to configure fixed ports if necessary by setting the <code>httpPort</code> and
<code>httpsPort</code> properties on the fixed provider.</p></div>
<div class="paragraph"><p>In most cases the scheme should be set correctly. This may not be true if the reverse proxy is unable to set the <code>X-Forwarded-For</code> header
correctly, or if there is an internal application using non-https to invoke Red Hat Single Sign-On. In such cases it is possible
to set the <code>alwaysHttps</code> to <code>true</code>.</p></div>
<h3>Custom provider</h3><div class="paragraph"><p>To develop a custom hostname provider you need to implement <code>org.keycloak.urls.HostnameProviderFactory</code> and
<code>org.keycloak.urls.HostnameProvider</code>.</p></div>
<div class="paragraph"><p>Follow the instructions in the Service Provider Interfaces section in <a href="https://access.redhat.com/documentation/en-us/red_hat_single_sign-on_continuous_delivery/6/html-single/server_developer_guide/">Server Developer Guide</a>
for more information on how to develop a custom provider.</p></div></section><section id="_admin_endpoints_and_console"><h2>Admin Endpoints and Console</h2><div class="paragraph"><p>The Red Hat Single Sign-On administrative REST API and the web console are exposed by default on the same port as non-admin
usage. If you are exposing Red Hat Single Sign-On on the Internet, we recommend not also exposing the admin endpoints on the
Internet.</p></div>
<div class="paragraph"><p>This can be achieve either directly in Red Hat Single Sign-On or with a proxy such as Apache or nginx.</p></div>
<div class="paragraph"><p>For the proxy option please follow the documentation for the proxy. You need to control access to any requests
to <code>/auth/admin</code>.</p></div>
<div class="paragraph"><p>To achieve this directly in Red Hat Single Sign-On there are a few options. This document covers two options, IP restriction
and separate ports.</p></div>
<h3>IP Restriction</h3><div class="paragraph"><p>It is possible to restrict access to <code>/auth/admin</code> to only specific IP addresses.</p></div>
<div class="paragraph"><p>The following example restricts access to <code>/auth/admin</code> to IP addresses in the range <code>10.0.0.1</code> to <code>10.0.0.255</code>.</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
    ...
    &lt;server name="default-server"&gt;
        ...
        &lt;host name="default-host" alias="localhost"&gt;
            ...
            &lt;filter-ref name="ipAccess"/&gt;
        &lt;/host&gt;
    &lt;/server&gt;
    &lt;filters&gt;
        &lt;expression-filter name="ipAccess" expression="path-prefix('/auth/admin') -&gt; ip-access-control(acl={'10.0.0.0/24 allow'})"/&gt;
    &lt;/filters&gt;
    ...
&lt;/subsystem&gt;</code></pre>
<div class="paragraph"><p>Equivalent configuration using CLI commands:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">/subsystem=undertow/configuration=filter/expression-filter=ipAccess:add(,expression="path-prefix[/auth/admin] -&gt; ip-access-control(acl={'10.0.0.0/24 allow'})")
/subsystem=undertow/server=default-server/host=default-host/filter-ref=ipAccess:add()</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">For IP restriction if you are using a proxy it is important to configure it correctly to make sure Red Hat Single Sign-On
receives the client IP address and not the proxy IP address</td></tr></table></div>
<h3>Port Restriction</h3><div class="paragraph"><p>It is possible to expose <code>/auth/admin</code> to a different port that is not exposed on the Internet.</p></div>
<div class="paragraph"><p>The following example exposes <code>/auth/admin</code> on port <code>8444</code> while not permitting access with the default port <code>8443</code>.</p></div>
<pre class="highlight listingblock"><code class="xml language-xml">&lt;subsystem xmlns="urn:jboss:domain:undertow:10.0"&gt;
    ...
    &lt;server name="default-server"&gt;
        ...
        &lt;https-listener name="https" socket-binding="https" security-realm="ApplicationRealm" enable-http2="true"/&gt;
        &lt;https-listener name="https-admin" socket-binding="https-admin" security-realm="ApplicationRealm" enable-http2="true"/&gt;
        &lt;host name="default-host" alias="localhost"&gt;
            ...
            &lt;filter-ref name="portAccess"/&gt;
        &lt;/host&gt;
    &lt;/server&gt;
    &lt;filters&gt;
        &lt;expression-filter name="portAccess" expression="path-prefix('/auth/admin') and not equals(%p, 8444) -&gt; response-code(403)"/&gt;
    &lt;/filters&gt;
    ...
&lt;/subsystem&gt;

...

&lt;socket-binding-group name="standard-sockets" default-interface="public" port-offset="${jboss.socket.binding.port-offset:0}"&gt;
    ...
    &lt;socket-binding name="https" port="${jboss.https.port:8443}"/&gt;
    &lt;socket-binding name="https-admin" port="${jboss.https.port:8444}"/&gt;
    ...
&lt;/socket-binding-group&gt;</code></pre>
<div class="paragraph"><p>Equivalent configuration using CLI commands:</p></div>
<pre class="highlight listingblock"><code class="bash language-bash">/socket-binding-group=standard-sockets/socket-binding=https-admin/:add(port=8444)

/subsystem=undertow/server=default-server/https-listener=https-admin:add(socket-binding=https-admin, security-realm=ApplicationRealm, enable-http2=true)

/subsystem=undertow/configuration=filter/expression-filter=portAccess:add(,expression="path-prefix('/auth/admin') and not equals(%p, 8444) -&gt; response-code(403)")
/subsystem=undertow/server=default-server/host=default-host/filter-ref=portAccess:add()</code></pre></section><section id="_password_guess_brute_force_attacks"><h2>Password guess: brute force attacks</h2><div class="paragraph"><p>A brute force attack happens when an attacker is trying to guess a user&#8217;s password.
Red Hat Single Sign-On has some limited brute force detection capabilities.
If turned on, a user account will be temporarily disabled if a threshold of login failures is reached.
To enable this feature go to the <code>Realm Settings</code> left menu item, click on the <code>Security Defenses</code> tab, then additional
go to the <code>Brute Force Detection</code> sub-tab.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content">Brute Force Detection is disabled by default. Enabling this feature is highly recommended to protect against this type of attack.</td></tr></table></div>
<div class="paragraph"><div class="title">Brute Force Detection</div><p><span class="image"><img src="rhsso-images/brute-force.png" alt="brute force"></span></p></div>
<div class="paragraph"><p>There are 2 different configurations for brute force detection; permanent lockout and temporary lockout. Permanent lockout will disable a user&#8217;s account after an attack is detected; the account will be disabled until an administrator renables it. Temporary lockout will disable a user&#8217;s account for a time period after an attack is detected; the time period for which the account is disabled increases the longer the attack continues.</p></div>
<div class="paragraph"><p><strong>Common Parameters</strong></p></div>
<div class="exampleblock"><div class="content"><div class="dlist"><dl><dt class="hdlist1">Max Login Failures</dt><dd><p>Maximum number of login failures permitted. Default value is 30.</p></dd><dt class="hdlist1">Quick Login Check Milli Seconds</dt><dd><p>Minimum time required between login attempts. Default is 1000.</p></dd><dt class="hdlist1">Minimum Quick Login Wait</dt><dd><p>Minimum amount of time the user will be temporarily disabled if logins attempts are quicker than <em>Quick Login Check Milli Seconds</em>. Default is 1 minute.</p></dd></dl></div></div></div>
<div class="paragraph"><p><strong>Temporary Lockout Parameters</strong></p></div>
<div class="exampleblock"><div class="content"><div class="dlist"><dl><dt class="hdlist1">Wait Increment</dt><dd><p>Amount of time added to the time a user is temporarily disabled after each time <em>Max Login Failures</em> is reached. Default is 1 minute.</p></dd><dt class="hdlist1">Max Wait</dt><dd><p>The maximum amount of time for which a user will be temporarily disabled. Default is 15 minutes.</p></dd><dt class="hdlist1">Failure Reset Time</dt><dd><p>Time after which the failure count will be reset; timer runs from the last failed login. Default is 12 hours.</p></dd></dl></div></div></div>
<div class="paragraph"><p><strong>Permanent Lockout Algorithm</strong></p></div>
<div class="exampleblock"><div class="content"><div class="olist arabic"><ol class="arabic"><li><p>On successful login</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Reset <code>count</code></p></li></ol></div></li><li><p>On failed login</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Increment <code>count</code></p></li><li><p>If <code>count</code> greater than <em>Max Login Failures</em></p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Permanently disable user</p></li></ol></div></li><li><p>Else if time between this failure and the last failure is less than <em>Quick Login Check Milli Seconds</em></p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Temporarily disable user for <em>Minimum Quick Login Wait</em></p></li></ol></div></li></ol></div></li></ol></div>
<div class="paragraph"><p>When a user is disabled they can not login until an administrator enables the user; enabling an account resets <code>count</code>.</p></div></div></div>
<div class="paragraph"><p><strong>Temporary Lockout Algorithm</strong></p></div>
<div class="exampleblock"><div class="content"><div class="olist arabic"><ol class="arabic"><li><p>On successful login</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>Reset <code>count</code></p></li></ol></div></li><li><p>On failed login</p><div class="olist loweralpha"><ol class="loweralpha" type="a"><li><p>If time between this failure and the last failure is greater than <em>Failure Reset Time</em></p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Reset <code>count</code></p></li></ol></div></li><li><p>Increment <code>count</code></p></li><li><p>Calculate <code>wait</code> using <em>Wait Increment</em> * (<code>count</code> / <em>Max Login Failures</em>). The division is an integer division so will always be rounded down to a whole number</p></li><li><p>If <code>wait</code> equals 0 and time between this failure and the last failure is less than <em>Quick Login Check Milli Seconds</em> then set <code>wait</code> to <em>Minimum Quick Login Wait</em> instead</p><div class="olist lowerroman"><ol class="lowerroman" type="i"><li><p>Temporarily disable the user for the smaller of <code>wait</code> and <em>Max Wait</em> seconds</p></li></ol></div></li></ol></div></li></ol></div>
<div class="paragraph"><p>Login failures when a user is temporarily disabled do not increment <code>count</code>.</p></div></div></div>
<div class="paragraph"><p>The downside of Red Hat Single Sign-On brute force detection is that the server becomes vulnerable to denial of service attacks.
An attacker can simply try to guess passwords for any accounts it knows and these account will be disabled.
Eventually we will expand this functionality to take client IP address into account when deciding whether to block a user.</p></div>
<div class="paragraph"><p>A better option might be a tool like <a href="http://www.fail2ban.org/wiki/index.php/Main_Page">Fail2Ban</a>.  You can point this service at the Red Hat Single Sign-On server&#8217;s log file.
Red Hat Single Sign-On logs every login failure and client IP address that had the failure.  Fail2Ban can be used to modify
firewalls after it detects an attack to block connections from specific IP addresses.</p></div>
<h3>Password Policies</h3><div class="paragraph"><p>Another thing you should do to prevent password guess is to have a complex enough password policy to ensure that
users pick hard to guess passwords.  See the <a href="#_password-policies">Password Policies</a> chapter for more details.</p></div>
<div class="paragraph"><p>The best way to prevent password guessing though is to set up the server to use a one-time-password (OTP).</p></div></section><section id="_clickjacking"><h2>Clickjacking</h2><div class="paragraph"><p>With clickjacking, a malicious site loads the target site in a transparent iFrame overlaid on top of a set of dummy
buttons that are carefully constructed to be placed directly under important buttons on the target site.
When a user clicks a visible button, they are actually clicking a button (such as a "login" button) on the hidden page.
An attacker can steal a user&#8217;s authentication credentials and access their resources.</p></div>
<div class="paragraph"><p>By default, every response by Red Hat Single Sign-On sets some specific browser headers that can prevent this from happening.
Specifically, it sets <a href="https://tools.ietf.org/html/rfc7034">X-FRAME_OPTIONS</a> and <a href="http://www.w3.org/TR/CSP/">Content-Security-Policy</a>.
You should take a look at the definition of both of these headers as there is a lot of fine-grain browser access you can control.
In the admin console you can specify the values these headers will have.  Go to the <code>Realm Settings</code> left menu item and
click the <code>Security Defenses</code> tab and make sure you are on the <code>Headers</code> sub-tab.</p></div>
<div class="paragraph"><p><span class="image"><img src="rhsso-images/security-headers.png" alt="security headers"></span></p></div>
<div class="paragraph"><p>By default, Red Hat Single Sign-On only sets up a <em>same-origin</em> policy for iframes.</p></div></section><section id="_sslhttps_requirement"><h2>SSL/HTTPS Requirement</h2><div class="paragraph"><p>If you do not use SSL/HTTPS for all communication between the Red Hat Single Sign-On auth server and the clients it secures, you will be very vulnerable to man in the middle attacks.
OAuth 2.0/OpenID Connect uses access tokens for security.
Without SSL/HTTPS, attackers can sniff your network and obtain an access token.
Once they have an access token they can do any operation that the token has been given permission for.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On has <a href="#_ssl_modes">three modes for SSL/HTTPS</a>.
SSL can be hard to set up, so out of the box, Red Hat Single Sign-On allows non-HTTPS communication over private IP addresses like
localhost, 192.168.x.x, and other private IP addresses.
In production, you should make sure SSL is enabled and required across the board.</p></div>
<div class="paragraph"><p>On the adapter/client side, Red Hat Single Sign-On allows you to turn off the SSL trust manager.
The trust manager ensures identity the client is talking to.
It checks the DNS domain name against the server&#8217;s certificate.
In production you should make sure that each of your client adapters is configured to use a truststore.
Otherwise you are vulnerable to DNS man in the middle attacks.</p></div></section><section id="_csrf_attacks"><h2>CSRF Attacks</h2><div class="paragraph"><p>Cross-site request forgery (CSRF) is a web-based attack whereby HTTP requests are transmitted from a user that the
web site trusts or has authenticated with(e.g. via HTTP redirects or HTML forms).  Any site that uses cookie based authentication is vulnerable to these types of attacks.
These attacks are mitigated by matching a state cookie against a posted form or query parameter.</p></div>
<div class="paragraph"><p>The OAuth 2.0 login specification requires that a state cookie be used and matched against a transmitted state parameter.
Red Hat Single Sign-On fully implements this part of the specification so all logins are protected.</p></div>
<div class="paragraph"><p>The Red Hat Single Sign-On Admin Console is a pure JavaScript/HTML5 application that makes REST calls to the backend Red Hat Single Sign-On admin REST API.
These calls all require bearer token authentication and are made via JavaScript Ajax calls.
CSRF does not apply here.
The admin REST API can also be configured to validate the CORS origins as well.</p></div>
<div class="paragraph"><p>The only part of Red Hat Single Sign-On that really falls into CSRF is the user account management pages.
To mitigate this Red Hat Single Sign-On sets a state cookie and also embeds the value of this state cookie within hidden form fields or query parameters in action links.
This query or form parameter is checked against the state cookie to verify that the call was made by the user.</p></div></section><section id="_unspecific-redirect-uris"><h2>Unspecific Redirect URIs</h2><div class="paragraph"><p>For the <a href="#_oidc-auth-flows">Authorization Code Flow</a>, if you register redirect URIs that
are too general, then it would be possible for a rogue client to impersonate a different client that has a broader scope
of access.  This could happen for instance if two clients live under the same domain.  So, it&#8217;s a good idea to make your
registered redirect URIs as specific as feasible.</p></div></section><section id="_compromised_access_and_refresh_tokens"><h2>Compromised Access and Refresh Tokens</h2><div class="paragraph"><p>There are a few things you can do to mitigate access tokens and refresh tokens from being stolen. The most important thing is to enforce SSL/HTTPS communication between Red Hat Single Sign-On and its clients and applications. It might seem obvious, but since Red Hat Single Sign-On does not have SSL enabled by default, an administrator might not realize that it is necessary.</p></div>
<div class="paragraph"><p>Another thing you can do to mitigate leaked access tokens is to shorten their lifespans.  You can specify this within the <a href="#_timeouts">timeouts page</a>.
Short lifespans (minutes) for access tokens for clients and applications to refresh their access tokens after a short amount of time. If an admin detects a leak, they can logout all user sessions to invalidate these refresh tokens or set up a revocation policy. Making sure refresh tokens always stay private to the client and are never transmitted ever is very important as well.</p></div>
<div class="paragraph"><p>You can also mitigate against leaked access tokens and refresh tokens by issuing these tokens as holder-of-key tokens. See <a href="#_mtls-client-certificate-bound-tokens">OAuth 2.0 Mutual TLS Client Certificate Bound Access Token</a> to learn how.</p></div>
<div class="paragraph"><p>If an access token or refresh token is compromised, the first thing you should do is go to the admin console and push a not-before revocation policy to all applications. This will enforce that any tokens issued prior to that date are now invalid. Pushing new not-before policy will also ensure that application will be forced to download new public keys from Red Hat Single Sign-On, hence it is also useful for the case, when you think that realm signing key was compromised.
More info in the  <a href="#realm_keys">keys chapter</a>.</p></div>
<div class="paragraph"><p>You can also disable specific applications, clients, and users if you feel that any one of those entities is completely compromised.</p></div></section><section id="_compromised_authorization_code"><h2>Compromised Authorization Code</h2><div class="paragraph"><p>For the <a href="#_oidc-auth-flows">OIDC Auth Code Flow</a>, it would be very hard for an attacker to compromise Red Hat Single Sign-On authorization codes.
Red Hat Single Sign-On generates a cryptographically strong random value for its authorization codes so it would be very hard to guess an access token.
An authorization code can only be used once to obtain an access token.
In the admin console you can specify how long an authorization code is valid for on the <a href="#_timeouts">timeouts page</a>.
This value should be really short, as short as a few seconds and just long enough for the client to make the request to obtain a token from the code.</p></div>
<div class="paragraph"><p>You can also mitigate against leaked autorization codes by applying PKCE to clients. See <a href="#_proof-key-for-code-exchange">Proof Key for Code Exchange (PKCE)</a> to learn how.</p></div></section><section id="_open_redirectors"><h2>Open redirectors</h2><div class="paragraph"><p>An attacker could use the end-user authorization endpoint and the redirect URI parameter to abuse the authorization server as an open redirector.
An open redirector is an endpoint using a parameter to automatically redirect a user agent to the location specified by the parameter value without any validation.
An attacker could utilize a user&#8217;s trust in an authorization server to launch a phishing attack.</p></div>
<div class="paragraph"><p>Red Hat Single Sign-On requires that all registered applications and clients register at least one redirection URI pattern.
Any time a client asks Red Hat Single Sign-On to perform a redirect (on login or logout for example), Red Hat Single Sign-On will check the redirect URI vs.
the list of valid registered URI patterns.
It is important that clients and applications register as specific a URI pattern as possible to mitigate open redirector attacks.</p></div></section><section id="_password_database_compromised"><h2>Password database compromised</h2><div class="paragraph"><p>Red Hat Single Sign-On does not store passwords in raw text.
It stores a hash of them using the PBKDF2 algorithm.  It actually uses
a default of 20,000 hashing iterations!  This is the security community&#8217;s recommended number of iterations.
This can be a rather large performance hit on your system as PBKDF2, by design, gobbles up a significant amount of CPU.
It is up to you to decide how serious you want to be to protect your password database.</p></div></section><section id="_limiting_scope"><h2>Limiting Scope</h2><div class="paragraph"><p>By default, each new client application has an unlimited <code>role scope mappings</code>.  This means that every access token that is created
for that client will contain all the permissions the user has.  If the client gets compromised and the access token
is leaked, then each system that the user has permission to access is now also compromised.  It is highly suggested
that you limit the roles an access token is assigned by using the <a href="#_role_scope_mappings">Scope menu</a> for each client.
Or alternatively, you can set role scope mappings at the Client Scope level and assign Client Scopes to your client by using the
<a href="#_client_scopes_linking">Client Scope menu</a>.</p></div></section><section id="_limit_token_audience"><h2>Limit Token Audience</h2><div class="paragraph"><p>In environments where the level of trust among services is low, it is a good practice to limit the audiences on the token. The
motivation behind this is described in the <a href="https://tools.ietf.org/html/rfc6819#section-5.1.5.5">OAuth2 Threat Model</a> document and
more details are in the <a href="#_audience">Audience Support section</a>.</p></div></section><section id="_sql_injection_attacks"><h2>SQL Injection Attacks</h2><div class="paragraph"><p>At this point in time, there is no knowledge of any SQL injection vulnerabilities in Red Hat Single Sign-On.</p></div></section></section>
<section><section id="_the_admin_cli"><h2>The Admin CLI</h2><div class="paragraph"><p>In previous chapters, we described how to use the Red Hat Single Sign-On Admin Console to perform administrative tasks. You can also perform those tasks from the command-line interface (CLI) by using the Admin CLI command-line tool.</p></div></section><section id="_installing_the_admin_cli"><h2>Installing the Admin CLI</h2><div class="paragraph"><p>The Admin CLI is packaged inside Red Hat Single Sign-On Server distribution. You can find execution scripts inside the <code class="filename">bin</code> directory.</p></div>
<div class="paragraph"><p>The Linux script is called <code class="filename">kcadm.sh</code>, and the script for Windows is called <code class="filename">kcadm.bat</code>.</p></div>
<div class="paragraph"><p>You can add the Red Hat Single Sign-On server directory to your <code class="filename">PATH</code> to use the client from any location on your file system.</p></div>
<div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p></li></ul></div>
<pre class="highlight listingblock"><code>$ export PATH=$PATH:$KEYCLOAK_HOME/bin
$ kcadm.sh</code></pre>
<div class="ulist"><ul><li><p>Windows:</p></li></ul></div>
<pre class="highlight listingblock"><code>c:\&gt; set PATH=%PATH%;%KEYCLOAK_HOME%\bin
c:\&gt; kcadm</code></pre>
<div class="paragraph"><p>We assume the <code>KEYCLOAK_HOME</code> environment (env) variable is set to the path where you extracted the Red Hat Single Sign-On Server distribution.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>To avoid repetition, the rest of this document only gives Windows examples in places where the difference in the CLI is more than just in the <code class="command">kcadm</code> command name.</p></div></td></tr></table></div></section><section id="_using_the_admin_cli"><h2>Using the Admin CLI</h2><div class="paragraph"><p>The Admin CLI works by making HTTP requests to Admin REST endpoints. Access to them is protected and requires authentication.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>Consult the Admin REST API documentation for details about JSON attributes for specific endpoints.</p></div></td></tr></table></div>
<div class="olist arabic"><ol class="arabic"><li><p>Start an authenticated session by providing credentials, that is, logging in. You are ready to perform create, read, update, and delete (CRUD) operations.</p><div class="paragraph"><p>For example, on</p></div>
<div class="ulist"><ul><li><p>Linux:</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin
$ kcadm.sh create realms -s realm=demorealm -s enabled=true -o
$ CID=$(kcadm.sh create clients -r demorealm -s clientId=my_client -s 'redirectUris=["http://localhost:8980/myapp/*"]' -i)
$ kcadm.sh get clients/$CID/installation/providers/keycloak-oidc-keycloak-json</code></pre></li><li><p>Windows:</p><pre class="highlight nowrap listingblock"><code>c:\&gt; kcadm config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin
c:\&gt; kcadm create realms -s realm=demorealm -s enabled=true -o
c:\&gt; kcadm create clients -r demorealm -s clientId=my_client -s "redirectUris=[\"http://localhost:8980/myapp/*\"]" -i &gt; clientid.txt
c:\&gt; set /p CID=&lt;clientid.txt
c:\&gt; kcadm get clients/%CID%/installation/providers/keycloak-oidc-keycloak-json</code></pre></li></ul></div></li><li><p>In a production environment, you must access Red Hat Single Sign-On with <code>https:</code> to avoid exposing tokens to network sniffers. If a server&#8217;s certificate is not issued by one of the trusted certificate authorities (CAs) that are included in Java&#8217;s default certificate truststore, prepare a <code class="filename">truststore.jks</code> file and instruct the Admin CLI to use it.</p><div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh config truststore --trustpass $PASSWORD ~/.keycloak/truststore.jks</code></pre></li><li><p>Windows:</p><pre class="highlight nowrap listingblock"><code>c:\&gt; kcadm config truststore --trustpass %PASSWORD% %HOMEPATH%\.keycloak\truststore.jks</code></pre></li></ul></div></li></ol></div></section><section id="_authenticating"><h2>Authenticating</h2><div class="paragraph"><p>When you log in with the Admin CLI, you specify a server endpoint URL and a realm, and then you specify a user name. Another option is to specify only a clientId, which results in using a special "service account". When you log in using a user name, you must use a password for the specified user. When you log in using a clientId, you only need the client secret, not the user password. You could also use <code class="command">Signed JWT</code> instead of the client secret.</p></div>
<div class="paragraph"><p>Make sure the account used for the session has the proper permissions to invoke Admin REST API operations. For example, the <code>realm-admin</code> role of the <code>realm-management</code> client allows the user to administer the realm within which the user is defined.</p></div>
<div class="paragraph"><p>There are two primary mechanisms for authentication. One mechanism uses <code class="command">kcadm config credentials</code> to start an authenticated session.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin</code></pre>
<div class="paragraph"><p>This approach maintains an authenticated session between the <code class="command">kcadm</code> command invocations by saving the obtained access token and the associated refresh token. It may also maintain other secrets in a private configuration file. See <a href="#_working_with_alternative_configurations">next chapter</a> for more information on the configuration file.</p></div>
<div class="paragraph"><p>The second approach only authenticates each command invocation for the duration of that invocation. This approach increases the load on the server and the time spent with roundtrips obtaining tokens. The benefit of this approach is not needing to save any tokens between invocations, which means nothing is saved to disk. This mode is used when the <code class="command">--no-config</code> argument is specified.</p></div>
<div class="paragraph"><p>For example, when performing an operation, we specify all the information required for authentication.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms --no-config --server http://localhost:8080/auth --realm master --user admin --password admin</code></pre>
<div class="paragraph"><p>Run the <code class="command">kcadm.sh help</code> command for more information on using the Admin CLI.</p></div>
<div class="paragraph"><p>Run the <code class="command">kcadm.sh config credentials --help</code> command for more information about starting an authenticated session.</p></div></section><section id="_working_with_alternative_configurations"><h2>Working with alternative configurations</h2><div class="paragraph"><p>By default, the Admin CLI automatically maintains a configuration file called <code class="filename">kcadm.config</code> located under the user&#8217;s home directory. In Linux-based systems, the full path name is <code class="filename">$HOME/.keycloak/kcadm.config</code>. On Windows, the full path name is <code class="filename">%HOMEPATH%\.keycloak\kcadm.config</code>. You can use the <code class="command">--config</code> option to point to a different file or location so you can maintain multiple authenticated sessions in parallel.</p></div>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>It is best to perform operations tied to a single configuration file from a single thread.</p></div></td></tr></table></div>
<div class="paragraph"><p>Make sure you do not make the configuration file visible to other users on the system. It contains access tokens and secrets that should be kept private. By default, the <code class="filename">~/.keycloak</code> directory and its content are created automatically with proper access limits. If the directory already exists, its permissions are not updated.</p></div>
<div class="paragraph"><p>If your unique circumstances require you to avoid storing secrets inside a configuration file, you can do so. It will be less convenient and you will have to make more token requests. To not store secrets, use the <code class="command">--no-config</code> option with all your commands and specify all the authentication information needed by the <code class="command">config credentials</code> command with each <code class="command">kcadm</code> invocation.</p></div></section><section id="_basic_operations_and_resource_uris"><h2>Basic operations and resource URIs</h2><div class="paragraph"><p>The Admin CLI allows you to generically perform CRUD operations against Admin REST API endpoints with additional commands that simplify performing certain tasks.</p></div>
<div class="paragraph"><p>The main usage pattern is listed below, where the <code class="command">create</code>, <code class="command">get</code>, <code class="command">update</code>, and <code class="command">delete</code> commands are mapped to the HTTP verbs <code>POST</code>, <code>GET</code>, <code>PUT</code>, and <code>DELETE</code>, respectively.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create ENDPOINT [ARGUMENTS]
$ kcadm.sh get ENDPOINT [ARGUMENTS]
$ kcadm.sh update ENDPOINT [ARGUMENTS]
$ kcadm.sh delete ENDPOINT [ARGUMENTS]</code></pre>
<div class="paragraph"><p>ENDPOINT is a target resource URI and can either be absolute (starting with <code>http:</code> or <code>https:</code>) or relative, used to compose an absolute URL of the following format:</p></div>
<pre class="highlight nowrap listingblock"><code>SERVER_URI/admin/realms/REALM/ENDPOINT</code></pre>
<div class="paragraph"><p>For example, if you authenticate against the server <a href="http://localhost:8080/auth" class="bare">http://localhost:8080/auth</a> and realm is <code class="filename">master</code>, then using <code class="filename">users</code> as ENDPOINT results in the resource URL <a href="http://localhost:8080/auth/admin/realms/master/users" class="bare">http://localhost:8080/auth/admin/realms/master/users</a>.</p></div>
<div class="paragraph"><p>If you set ENDPOINT to <code class="filename">clients</code>, the effective resource URI would be <a href="http://localhost:8080/auth/admin/realms/master/clients" class="bare">http://localhost:8080/auth/admin/realms/master/clients</a>.</p></div>
<div class="paragraph"><p>There is a <code class="filename">realms</code> endpoint that is treated slightly differently because it is the container for realms. It resolves to:</p></div>
<pre class="highlight nowrap listingblock"><code>SERVER_URI/admin/realms</code></pre>
<div class="paragraph"><p>There is also a <code class="filename">serverinfo</code> endpoint, which is treated the same way because it is independent of realms.</p></div>
<div class="paragraph"><p>When you authenticate as a user with realm-admin powers, you might need to perform commands on multiple realms. In that case, specify the <code class="command">-r</code> option to tell explicitly which realm the command should be executed against. Instead of using <code class="filename">REALM</code> as specified via the <code class="command">--realm</code> option of <code class="command">kcadm.sh config credentials</code>, the <code class="filename">TARGET_REALM</code> is used.</p></div>
<pre class="highlight nowrap listingblock"><code>SERVER_URI/admin/realms/TARGET_REALM/ENDPOINT</code></pre>
<div class="paragraph"><p>For example,</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin
$ kcadm.sh create users -s username=testuser -s enabled=true -r demorealm</code></pre>
<div class="paragraph"><p>In this example, you start a session authenticated as the <code class="filename">admin</code> user in the <code class="filename">master</code> realm. You then perform a POST call against the resource URL <code class="filename"><a href="http://localhost:8080/auth/admin/realms/demorealm/users" class="bare">http://localhost:8080/auth/admin/realms/demorealm/users</a></code>.</p></div>
<div class="paragraph"><p>The <code class="command">create</code> and <code class="command">update</code> commands send a JSON body to the server by default. You can use <code class="filename">-f FILENAME</code> to read a premade document from a file. When you can use <code class="command">-f -</code> option, the message body is read from standard input. You can also specify individual attributes and their values as seen in the previous <code class="command">create users</code> example. They are composed into a JSON body and sent to the server.</p></div>
<div class="paragraph"><p>There are several ways to update a resource using the <code class="command">update</code> command. You can first determine the current state of a resource and save it to a file, and then edit that file and send it to the server for updating.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight listingblock"><code>$ kcadm.sh get realms/demorealm &gt; demorealm.json
$ vi demorealm.json
$ kcadm.sh update realms/demorealm -f demorealm.json</code></pre>
<div class="paragraph"><p>This method updates the resource on the server with all the attributes in the sent JSON document.</p></div>
<div class="paragraph"><p>Another option is to perform an on-the-fly update using the <code class="command">-s, --set</code> options to set new values.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight listingblock"><code>$ kcadm.sh update realms/demorealm -s enabled=false</code></pre>
<div class="paragraph"><p>That method only updates the <code class="command">enabled</code> attribute to <code>false</code>.</p></div>
<div class="paragraph"><p>By default, the <code class="commamd">update</code> command first performs a <code class="command">get</code> and then merges the new attribute values with existing values. This is the preferred behavior. In some cases, the endpoint may support the <code class="command">PUT</code> command but not the <code class="command">GET</code> command. You can use the <code class="command">-n</code> option to perform a "no-merge" update, which performs a <code class="command">PUT</code> command without first running a <code class="command">GET</code> command.</p></div></section><section id="_realm_operations"><h2>Realm operations</h2><h4 id="_creating_a_new_realm" class="discrete">Creating a new realm</h4>
<div class="paragraph"><p>Use the <code class="command">create</code> command on the <code>realms</code> endpoint to create a new enabled realm, and set the attributes to <code>realm</code> and <code>enabled</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create realms -s realm=demorealm -s enabled=true</code></pre>
<div class="paragraph"><p>A realm is not enabled by default. By enabling it, you can use a realm immediately for authentication.</p></div>
<div class="paragraph"><p>A description for a new object can also be in a JSON format.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create realms -f demorealm.json</code></pre>
<div class="paragraph"><p>You can send a JSON document with realm attributes directly from a file or piped to a standard input.</p></div>
<div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p></li></ul></div>
<pre class="highlight listingblock"><code>$ kcadm.sh create realms -f - &lt;&lt; EOF
{ "realm": "demorealm", "enabled": true }
EOF</code></pre>
<div class="ulist"><ul><li><p>Windows:</p></li></ul></div>
<pre class="highlight listingblock"><code>c:\&gt; echo { "realm": "demorealm", "enabled": true } | kcadm create realms -f -</code></pre>
<h4 id="_listing_existing_realms" class="discrete">Listing existing realms</h4>
<div class="paragraph"><p>The following command returns a list of all realms.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>A list of realms is additionally filtered on the server to return only realms a user can see.</p></div></td></tr></table></div>
<div class="paragraph"><p>Returning the entire realm description often provides too much information. Most users are interested only in a subset of attributes, such as realm name and whether the realm is enabled. You can specify which attributes to return by using the <code class="command">--fields</code> option.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms --fields realm,enabled</code></pre>
<div class="paragraph"><p>You can also display the result as comma separated values.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms --fields realm --format csv --noquotes</code></pre>
<h4 id="_getting_a_specific_realm" class="discrete">Getting a specific realm</h4>
<div class="paragraph"><p>You append a realm name to a collection URI to get an individual realm.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms/master</code></pre>
<h4 id="_updating_a_realm" class="discrete">Updating a realm</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the <code class="command">-s</code> option to set new values for the attributes when you want to change only some of the realm&#8217;s attributes.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update realms/demorealm -s enabled=false</code></pre></li><li><p>If you want to set all writable attributes with new values, run a <code class="command">get</code> command, edit the current values in the JSON file, and resubmit.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms/demorealm &gt; demorealm.json
$ vi demorealm.json
$ kcadm.sh update realms/demorealm -f demorealm.json</code></pre></li></ol></div>
<h4 id="_deleting_a_realm" class="discrete">Deleting a realm</h4>
<div class="paragraph"><p>Run the following command to delete a realm.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete realms/demorealm</code></pre>
<h4 id="_turning_on_all_login_page_options_for_the_realm" class="discrete">Turning on all login page options for the realm</h4>
<div class="paragraph"><p>Set the attributes controlling specific capabilities to <code>true</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update realms/demorealm -s registrationAllowed=true -s registrationEmailAsUsername=true -s rememberMe=true -s verifyEmail=true -s resetPasswordAllowed=true -s editUsernameAllowed=true</code></pre>
<h4 id="_listing_the_realm_keys" class="discrete">Listing the realm keys</h4>
<div class="paragraph"><p>Use the <code class="command">get</code> operation on the <code class="filename">keys</code> endpoint of the target realm.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get keys -r demorealm</code></pre>
<h4 id="_generating_new_realm_keys" class="discrete">Generating new realm keys</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Get the ID of the target realm before adding a new RSA-generated key pair.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms/demorealm --fields id --format csv --noquotes</code></pre></li><li><p>Add a new key provider with a higher priority than the existing providers as revealed by <code class="command">kcadm.sh get keys -r demorealm</code>.</p><div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=rsa-generated -s providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=["101"]' -s 'config.enabled=["true"]' -s 'config.active=["true"]' -s 'config.keySize=["2048"]'</code></pre></li><li><p>Windows:</p><pre class="highlight nowrap listingblock"><code>c:\&gt; kcadm create components -r demorealm -s name=rsa-generated -s providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "config.priority=[\"101\"]" -s "config.enabled=[\"true\"]" -s "config.active=[\"true\"]" -s "config.keySize=[\"2048\"]"</code></pre></li></ul></div></li><li><p>Set the <code>parentId</code> attribute to the value of the target realm&#8217;s ID.</p><div class="paragraph"><p>The newly added key should now become the active key as revealed by <code class="command">kcadm.sh get keys -r demorealm</code>.</p></div></li></ol></div>
<h4 id="_adding_new_realm_keys_from_a_java_key_store_file" class="discrete">Adding new realm keys from a Java Key Store file</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Add a new key provider to add a new key pair already prepared as a JKS file on the server.</p><div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=java-keystore -s providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=["101"]' -s 'config.enabled=["true"]' -s 'config.active=["true"]' -s 'config.keystore=["/opt/keycloak/keystore.jks"]' -s 'config.keystorePassword=["secret"]' -s 'config.keyPassword=["secret"]' -s 'config.alias=["localhost"]'</code></pre></li><li><p>Windows:</p><pre class="highlight nowrap listingblock"><code>c:\&gt; kcadm create components -r demorealm -s name=java-keystore -s providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "config.priority=[\"101\"]" -s "config.enabled=[\"true\"]" -s "config.active=[\"true\"]" -s "config.keystore=[\"/opt/keycloak/keystore.jks\"]" -s "config.keystorePassword=[\"secret\"]" -s "config.keyPassword=[\"secret\"]" -s "config.alias=[\"localhost\"]"</code></pre></li></ul></div></li><li><p>Make sure to change the attribute values for <code>keystore</code>, <code>keystorePassword</code>, <code>keyPassword</code>, and <code>alias</code> to match your specific keystore.</p></li><li><p>Set the <code>parentId</code> attribute to the value of the target realm&#8217;s ID.</p></li></ol></div>
<h4 id="_making_the_key_passive_or_disabling_the_key" class="discrete">Making the key passive or disabling the key</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Identify the key you want to make passive</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh get keys -r demorealm</code></pre></li><li><p>Use the key&#8217;s <code>providerId</code> attribute to construct an endpoint URI, such as <code class="filename">components/PROVIDER_ID</code>.</p></li><li><p>Perform an <code class="command">update</code>.</p><div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh update components/PROVIDER_ID -r demorealm -s 'config.active=["false"]'</code></pre></li><li><p>Windows:</p><pre class="highlight nowrap listingblock"><code>c:\&gt; kcadm update components/PROVIDER_ID -r demorealm -s "config.active=[\"false\"]"</code></pre>
<div class="paragraph"><p>You can update other key attributes.</p></div></li></ul></div></li><li><p>Set a new <code>enabled</code> value to disable the key, for example, <code>config.enabled=["false"]</code>.</p></li><li><p>Set a new <code>priority</code> value to change the key&#8217;s priority, for example, <code>config.priority=["110"]</code>.</p></li></ol></div>
<h4 id="_deleting_an_old_key" class="discrete">Deleting an old key</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Make sure the key you are deleting has been passive and disabled to prevent any existing tokens held by applications and users from abruptly failing to work.</p></li><li><p>Identify the key you want to make passive.</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh get keys -r demorealm</code></pre></li><li><p>Use the <code>providerId</code> of that key to perform a delete.</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete components/PROVIDER_ID -r demorealm</code></pre></li></ol></div>
<h4 id="_configuring_event_logging_for_a_realm" class="discrete">Configuring event logging for a realm</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command on the <code class="filename">events/config</code> endpoint.</p></div>
<div class="paragraph"><p>The <code>eventsListeners</code> attribute contains a list of EventListenerProviderFactory IDs that specify all event listeners receiving events. Separately, there are attributes that control a built-in event storage, which allows querying past events via the Admin REST API. There is separate control over logging of service calls (<code>eventsEnabled</code>) and auditing events triggered during Admin Console or Admin REST API (<code>adminEventsEnabled</code>). You may want to set up expiry of old events so that your database does not fill up; <code>eventsExpiration</code> is set to time-to-live expressed in seconds.</p></div>
<div class="paragraph"><p>Here is an example of setting up a built-in event listener that receives all the events and logs them through jboss-logging. (Using a logger called <code>org.keycloak.events</code>, error events are logged as <code>WARN</code>, and others are logged as <code>DEBUG</code>.)</p></div>
<div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p></li></ul></div>
<pre class="highlight listingblock"><code>$ kcadm.sh update events/config -r demorealm -s 'eventsListeners=["jboss-logging"]'</code></pre>
<div class="ulist"><ul><li><p>Windows:</p></li></ul></div>
<pre class="highlight listingblock"><code>c:\&gt; kcadm update events/config -r demorealm -s "eventsListeners=[\"jboss-logging\"]"</code></pre>
<div class="paragraph"><p>Here is an example of turning on storage of all available ERROR events&#8212;not including auditing events&#8212;for 2 days so they can be retrieved via Admin REST.</p></div>
<div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p></li></ul></div>
<pre class="highlight listingblock"><code>$ kcadm.sh update events/config -r demorealm -s eventsEnabled=true -s 'enabledEventTypes=["LOGIN_ERROR","REGISTER_ERROR","LOGOUT_ERROR","CODE_TO_TOKEN_ERROR","CLIENT_LOGIN_ERROR","FEDERATED_IDENTITY_LINK_ERROR","REMOVE_FEDERATED_IDENTITY_ERROR","UPDATE_EMAIL_ERROR","UPDATE_PROFILE_ERROR","UPDATE_PASSWORD_ERROR","UPDATE_TOTP_ERROR","VERIFY_EMAIL_ERROR","REMOVE_TOTP_ERROR","SEND_VERIFY_EMAIL_ERROR","SEND_RESET_PASSWORD_ERROR","SEND_IDENTITY_PROVIDER_LINK_ERROR","RESET_PASSWORD_ERROR","IDENTITY_PROVIDER_FIRST_LOGIN_ERROR","IDENTITY_PROVIDER_POST_LOGIN_ERROR","CUSTOM_REQUIRED_ACTION_ERROR","EXECUTE_ACTIONS_ERROR","CLIENT_REGISTER_ERROR","CLIENT_UPDATE_ERROR","CLIENT_DELETE_ERROR"]' -s eventsExpiration=172800</code></pre>
<div class="ulist"><ul><li><p>Windows:</p></li></ul></div>
<pre class="highlight listingblock"><code>c:\&gt; kcadm update events/config -r demorealm -s eventsEnabled=true -s "enabledEventTypes=[\"LOGIN_ERROR\",\"REGISTER_ERROR\",\"LOGOUT_ERROR\",\"CODE_TO_TOKEN_ERROR\",\"CLIENT_LOGIN_ERROR\",\"FEDERATED_IDENTITY_LINK_ERROR\",\"REMOVE_FEDERATED_IDENTITY_ERROR\",\"UPDATE_EMAIL_ERROR\",\"UPDATE_PROFILE_ERROR\",\"UPDATE_PASSWORD_ERROR\",\"UPDATE_TOTP_ERROR\",\"VERIFY_EMAIL_ERROR\",\"REMOVE_TOTP_ERROR\",\"SEND_VERIFY_EMAIL_ERROR\",\"SEND_RESET_PASSWORD_ERROR\",\"SEND_IDENTITY_PROVIDER_LINK_ERROR\",\"RESET_PASSWORD_ERROR\",\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\",\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\",\"CUSTOM_REQUIRED_ACTION_ERROR\",\"EXECUTE_ACTIONS_ERROR\",\"CLIENT_REGISTER_ERROR\",\"CLIENT_UPDATE_ERROR\",\"CLIENT_DELETE_ERROR\"]" -s eventsExpiration=172800</code></pre>
<div class="paragraph"><p>Here is an example of how to reset stored event types to <strong>all available event types</strong>; setting to empty list is the same as enumerating all.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update events/config -r demorealm -s enabledEventTypes=[]</code></pre>
<div class="paragraph"><p>Here is an example of how to enable storage of auditing events.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update events/config -r demorealm -s adminEventsEnabled=true -s adminEventsDetailsEnabled=true</code></pre>
<div class="paragraph"><p>Here is an example of how to get the last 100 events; they are ordered from newest to oldest.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get events --offset 0 --limit 100</code></pre>
<div class="paragraph"><p>Here is an example of how to delete all saved events.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm delete events</code></pre>
<h4 id="_flushing_the_caches" class="discrete">Flushing the caches</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the <code class="command">create</code> command and one of the following endpoints: <code class="filename">clear-realm-cache</code>, <code class="filename">clear-user-cache</code>, or <code class="filename">clear-keys-cache</code>.</p></li><li><p>Set <code>realm</code> to the same value as the target realm.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create clear-realm-cache -r demorealm -s realm=demorealm
$ kcadm.sh create clear-user-cache -r demorealm -s realm=demorealm
$ kcadm.sh create clear-keys-cache -r demorealm -s realm=demorealm</code></pre></li></ol></div>
<h4 id="_importing_a_realm_from_exported_json_file" class="discrete">Importing a realm from exported .json file</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the <code class="command">create</code> command on the <code class="filename">partialImport</code> endpoint.</p></li><li><p>Set <code>ifResourceExists</code> to one of <code>FAIL</code>, <code>SKIP</code>, <code>OVERWRITE</code>.</p></li><li><p>Use <code>-f</code> to submit the exported realm <code>.json</code> file</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create partialImport -r demorealm2 -s ifResourceExists=FAIL -o -f demorealm.json</code></pre>
<div class="paragraph"><p>If realm does not yet exist, you first have to create it.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create realms -s realm=demorealm2 -s enabled=true</code></pre></li></ol></div></section><section id="_role_operations"><h2>Role operations</h2><h4 id="_creating_a_realm_role" class="discrete">Creating a realm role</h4>
<div class="paragraph"><p>Use the <code class="filename">roles</code> endpoint to create a realm role.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create roles -r demorealm -s name=user -s 'description=Regular user with limited set of permissions'</code></pre>
<h4 id="_creating_a_client_role" class="discrete">Creating a client role</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Identify the client first and then use the <code class="command">get</code> command to list available clients when creating a client role.</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh get clients -r demorealm --fields id,clientId</code></pre></li><li><p>Create a new role by using the <code class="command">clientId</code> attribute to construct an endpoint URI, such as <code class="filename">clients/ID/roles</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles -r demorealm -s name=editor -s 'description=Editor can edit, and publish any article'</code></pre></li></ol></div>
<h4 id="_listing_realm_roles" class="discrete">Listing realm roles</h4>
<div class="paragraph"><p>Use the <code class="command">get</code> command on the <code class="filename">roles</code> endpoint to list existing realm roles.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get roles -r demorealm</code></pre>
<div class="paragraph"><p>You can also use the <code class="command">get-roles</code> command.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm</code></pre>
<h4 id="_listing_client_roles" class="discrete">Listing client roles</h4>
<div class="paragraph"><p>There is a dedicated <code class="command">get-roles</code> command to simplify listing realm and client roles. It is an extension of the <code class="command">get</code> command and behaves the same with additional semantics for listing roles.</p></div>
<div class="paragraph"><p>Use the <code class="command">get-roles</code> command, passing it either the clientId attribute (via the <code class="command">--cclientid</code> option) or <code class="command">id</code> (via the <code class="command">--cid</code> option) to identify the client to list client roles.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --cclientid realm-management</code></pre>
<h4 id="_getting_a_specific_realm_role" class="discrete">Getting a specific realm role</h4>
<div class="paragraph"><p>Use the <code class="command">get</code> command and the role <code class="filename">name</code> to construct an endpoint URI for a specific realm role: <code class="filename">roles/ROLE_NAME</code>, where <code class="filename">user</code> is the name of the existing role.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get roles/user -r demorealm</code></pre>
<div class="paragraph"><p>You can also use the special <code class="command">get-roles</code> command, passing it a role name (via the <code class="command">--rolename</code> option) or ID (via the <code class="command">--roleid</code> option).</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rolename user</code></pre>
<h4 id="_getting_a_specific_client_role" class="discrete">Getting a specific client role</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">get-roles</code> command, passing it either the clientId attribute (via the <code class="command">--cclientid</code> option) or ID (via the <code class="command">--cid</code> option) to identify the client, and passing it either the role name (via the <code class="command">--rolename</code> option) or ID (via the <code class="command">--roleid</code>) to identify a specific client role.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --cclientid realm-management --rolename manage-clients</code></pre>
<h4 id="_updating_a_realm_role" class="discrete">Updating a realm role</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command with the same endpoint URI that you used to get a specific realm role.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update roles/user -r demorealm -s 'description=Role representing a regular user'</code></pre>
<h4 id="_updating_a_client_role" class="discrete">Updating a client role</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command with the same endpoint URI that you used to get a specific client role.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor -r demorealm -s 'description=User that can edit, and publish articles'</code></pre>
<h4 id="_deleting_a_realm_role" class="discrete">Deleting a realm role</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command with the same endpoint URI that you used to get a specific realm role.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete roles/user -r demorealm</code></pre>
<h4 id="_deleting_a_client_role" class="discrete">Deleting a client role</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command with the same endpoint URI that you used to get a specific client role.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor -r demorealm</code></pre>
<h4 id="_listing_assigned_available_and_effective_realm_roles_for_a_composite_role" class="discrete">Listing assigned, available, and effective realm roles for a composite role</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">get-roles</code> command to list assigned, available, and effective realm roles for a composite role.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>To list <strong>assigned</strong> realm roles for the composite role, you can specify the target composite role by either name (via the <code class="command">--rname</code> option) or ID (via the <code class="command">--rid</code> option).</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rname testrole</code></pre></li><li><p>Use the additional <code class="command">--effective</code> option to list <strong>effective</strong> realm roles.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rname testrole --effective</code></pre></li><li><p>Use the <code class="command">--available</code> option to list realm roles that can still be added to the composite role.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rname testrole --available</code></pre></li></ol></div>
<h4 id="_listing_assigned_available_and_effective_client_roles_for_a_composite_role" class="discrete">Listing assigned, available, and effective client roles for a composite role</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">get-roles</code> command to list assigned, available, and effective client roles for a composite role.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>To list <strong>assigned</strong> client roles for the composite role, you can specify the target composite role by either name (via the <code class="command">--rname</code> option) or ID (via the <code class="command">--rid</code> option) and client by either the clientId attribute (via the <code class="command">--cclientid</code> option) or ID (via the <code class="command">--cid</code> option).</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management</code></pre></li><li><p>Use the additional <code class="command">--effective</code> option to list <strong>effective</strong> realm roles.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management --effective</code></pre></li><li><p>Use the <code class="command">--available</code> option to list realm roles that can still be added to the target composite role.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-management --available</code></pre></li></ol></div>
<h4 id="_adding_realm_roles_to_a_composite_role" class="discrete">Adding realm roles to a composite role</h4>
<div class="paragraph"><p>There is a dedicated <code class="command">add-roles</code> command that can be used for adding realm roles and client roles.</p></div>
<div class="paragraph"><p>The following example adds the <code class="command">user</code> role to the composite role <code class="command">testrole</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh add-roles --rname testrole --rolename user -r demorealm</code></pre>
<h4 id="_removing_realm_roles_from_a_composite_role" class="discrete">Removing realm roles from a composite role</h4>
<div class="paragraph"><p>There is a dedicated <code class="command">remove-roles</code> command that can be used to remove realm roles and client roles.</p></div>
<div class="paragraph"><p>The following example removes the <code class="command">user</code> role from the target composite role <code class="command">testrole</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh remove-roles --rname testrole --rolename user -r demorealm</code></pre>
<h4 id="_adding_client_roles_to_a_realm_role" class="discrete">Adding client roles to a realm role</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">add-roles</code> command that can be used for adding realm roles and client roles.</p></div>
<div class="paragraph"><p>The following example adds the roles defined on the client <code class="command">realm-management</code> - <code>create-client</code> role and the <code class="command">view-users</code> role to the <code class="command">testrole</code> composite role.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh add-roles -r demorealm --rname testrole --cclientid realm-management --rolename create-client --rolename view-users</code></pre>
<h4 id="_adding_client_roles_to_a_client_role" class="discrete">Adding client roles to a client role</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Determine the ID of the composite client role by using the <code class="command">get-roles</code> command.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --cclientid test-client --rolename operations</code></pre></li><li><p>Assume that there is a client with a clientId attribute of <code class="filename">test-client</code>, a client role called <code class="filename">support</code>, and another client role called <code class="filename">operations</code>, which becomes a composite role, that has an ID of "fc400897-ef6a-4e8c-872b-1581b7fa8a71".</p></li><li><p>Use the following example to add another role to the composite role.</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh add-roles -r demorealm --cclientid test-client --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --rolename support</code></pre></li><li><p>List the roles of a composite role by using the <code class="command">get-roles --all</code> command.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --all</code></pre></li></ol></div>
<h4 id="_removing_client_roles_from_a_composite_role" class="discrete">Removing client roles from a composite role</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">remove-roles</code> command to remove client roles from a composite role.</p></div>
<div class="paragraph"><p>Use the following example to remove two roles defined on the client <code class="command">realm management</code> - <code>create-client</code> role and the <code class="command">view-users</code> role from the <code class="command">testrole</code> composite role.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh remove-roles -r demorealm --rname testrole --cclientid realm-management --rolename create-client --rolename view-users</code></pre>
<h4 id="_adding_client_roles_to_a_group" class="discrete">Adding client roles to a group</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">add-roles</code> command that can be used for adding realm roles and client roles.</p></div>
<div class="paragraph"><p>The following example adds the roles defined on the client <code class="command">realm-management</code> - <code>create-client</code> role and the <code class="command">view-users</code> role to the <code class="command">Group</code> group (via the <code class="command">--gname</code> option). The group can alternatively be specified by ID (via the <code class="command">--gid</code> option).</p></div>
<div class="paragraph"><p>See <a href="#_group_operations">Group operations</a> for more operations that can be performed to groups.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh add-roles -r demorealm --gname Group --cclientid realm-management --rolename create-client --rolename view-users</code></pre>
<h4 id="_removing_client_roles_from_a_group" class="discrete">Removing client roles from a group</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">remove-roles</code> command to remove client roles from a group.</p></div>
<div class="paragraph"><p>Use the following example to remove two roles defined on the client <code class="command">realm management</code> - <code>create-client</code> role and the <code class="command">view-users</code> role from the <code class="command">Group</code> group.</p></div>
<div class="paragraph"><p>See <a href="#_group_operations">Group operations</a> for more operations that can be performed to groups.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh remove-roles -r demorealm --gname Group --cclientid realm-management --rolename create-client --rolename view-users</code></pre></section><section id="_client_operations"><h2>Client operations</h2><h4 id="_creating_a_client" class="discrete">Creating a client</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">create</code> command on a <code class="filename">clients</code> endpoint to create a new client.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true</code></pre></li><li><p>Specify a secret if you want to set a secret for adapters to authenticate.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true -s clientAuthenticatorType=client-secret -s secret=d0b8122f-8dfb-46b7-b68a-f5cc4e25d000</code></pre></li></ol></div>
<h4 id="_listing_clients" class="discrete">Listing clients</h4>
<div class="paragraph"><p>Use the <code class="command">get</code> command on the <code class="filename">clients</code> endpoint to list clients.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get clients -r demorealm --fields id,clientId</code></pre>
<div class="paragraph"><p>This example filters the output to list only the <code class="filename">id</code> and <code class="filename">clientId</code> attributes.</p></div>
<h4 id="_getting_a_specific_client" class="discrete">Getting a specific client</h4>
<div class="paragraph"><p>Use a client&#8217;s ID to construct an endpoint URI that targets a specific client, such as <code class="filename">clients/ID</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm</code></pre>
<h4 id="_getting_the_current_secret_for_a_specific_client" class="discrete">Getting the current secret for a specific client</h4>
<div class="paragraph"><p>Use a client&#8217;s ID to construct an endpoint URI, such as <code class="filename">clients/ID/client-secret</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get clients/$CID/client-secret</code></pre>
<h4 id="_getting_an_adapter_configuration_file_keycloak_json_for_a_specific_client" class="discrete">Getting an adapter configuration file (keycloak.json) for a specific client</h4>
<div class="paragraph"><p>Use a client&#8217;s ID to construct an endpoint URI that targets a specific client, such as <code class="filename">clients/ID/installation/providers/keycloak-oidc-keycloak-json</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-oidc-keycloak-json -r demorealm</code></pre>
<h4 id="_getting_a_wildfly_subsystem_adapter_configuration_for_a_specific_client" class="discrete">Getting a WildFly subsystem adapter configuration for a specific client</h4>
<div class="paragraph"><p>Use a client&#8217;s ID to construct an endpoint URI that targets a specific client, such as <code class="filename">clients/ID/installation/providers/keycloak-oidc-jboss-subsystem</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-oidc-jboss-subsystem -r demorealm</code></pre>
<h4 id="_getting_a_docker_v2_example_configuration_for_a_specific_client" class="discrete">Getting a Docker-v2 example configuration for a specific client</h4>
<div class="paragraph"><p>Use a client&#8217;s ID to construct an endpoint URI that targets a specific client, such as <code class="filename">clients/ID/installation/providers/docker-v2-compose-yaml</code>.</p></div>
<div class="paragraph"><p>Note that response will be in <code>.zip</code> format.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get http://localhost:8080/auth/admin/realms/demorealm/clients/8f271c35-44e3-446f-8953-b0893810ebe7/installation/providers/docker-v2-compose-yaml -r demorealm &gt; keycloak-docker-compose-yaml.zip</code></pre>
<h4 id="_updating_a_client" class="discrete">Updating a client</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command with the same endpoint URI that you used to get a specific client.</p></div>
<div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p></li></ul></div>
<pre class="highlight listingblock"><code>$ kcadm.sh update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm -s enabled=false -s publicClient=true -s 'redirectUris=["http://localhost:8080/myapp/*"]' -s baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp</code></pre>
<div class="ulist"><ul><li><p>Windows:</p></li></ul></div>
<pre class="highlight listingblock"><code>c:\&gt; kcadm update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm -s enabled=false -s publicClient=true -s "redirectUris=[\"http://localhost:8080/myapp/*\"]" -s baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp</code></pre>
<h4 id="_deleting_a_client" class="discrete">Deleting a client</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command with the same endpoint URI that you used to get a specific client.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm</code></pre>
<h4 id="_adding_or_removing_roles_for_clients_service_account" class="discrete">Adding or removing roles for client&#8217;s service account</h4>
<div class="paragraph"><p>Service account for the client is just a special kind of user account with username <code class="filename">service-account-CLIENT_ID</code>.
You can perform user operations on this account as if it was a regular user.</p></div></section><section id="_user_operations"><h2>User operations</h2><h4 id="_creating_a_user" class="discrete">Creating a user</h4>
<div class="paragraph"><p>Run the <code class="command">create</code> command on the <code class="filename">users</code> endpoint to create a new user.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create users -r demorealm -s username=testuser -s enabled=true</code></pre>
<h4 id="_listing_users" class="discrete">Listing users</h4>
<div class="paragraph"><p>Use the <code class="filename">users</code> endpoint to list users. The target user will have to change the password the next time they log in.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get users -r demorealm --offset 0 --limit 1000</code></pre>
<div class="paragraph"><p>You can filter users by <code class="filename">username</code>, <code class="filename">firstName</code>, <code class="filename">lastName</code>, or <code class="filename">email</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get users -r demorealm -q email=google.com
$ kcadm.sh get users -r demorealm -q username=testuser</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>Filtering does not use exact matching. For example, the above example would match the value of the <code class="filename">username</code> attribute against the <code class="filename">*testuser*</code> pattern.</p></div></td></tr></table></div>
<div class="paragraph"><p>You can also filter across multiple attributes by specifying multiple <code class="command">-q</code> options, which return only users that match the condition for all the attributes.</p></div>
<h4 id="_getting_a_specific_user" class="discrete">Getting a specific user</h4>
<div class="paragraph"><p>Use a user&#8217;s ID to compose an endpoint URI, such as <code class="filename">users/USER_ID</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm</code></pre>
<h4 id="_updating_a_user" class="discrete">Updating a user</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command with the same endpoint URI that you used to get a specific user.</p></div>
<div class="paragraph"><p>For example, on:</p></div>
<div class="ulist"><ul><li><p>Linux:</p></li></ul></div>
<pre class="highlight listingblock"><code>$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s 'requiredActions=["VERIFY_EMAIL","UPDATE_PROFILE","CONFIGURE_TOTP","UPDATE_PASSWORD"]'</code></pre>
<div class="ulist"><ul><li><p>Windows:</p></li></ul></div>
<pre class="highlight listingblock"><code>c:\&gt; kcadm update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s "requiredActions=[\"VERIFY_EMAIL\",\"UPDATE_PROFILE\",\"CONFIGURE_TOTP\",\"UPDATE_PASSWORD\"]"</code></pre>
<h4 id="_deleting_a_user" class="discrete">Deleting a user</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command with the same endpoint URI that you used to get a specific user.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm</code></pre>
<h4 id="_resetting_a_users_password" class="discrete">Resetting a user&#8217;s password</h4>
<div class="paragraph"><p>Use the dedicated <code class="command">set-password</code> command to reset a user&#8217;s password.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh set-password -r demorealm --username testuser --new-password NEWPASSWORD --temporary</code></pre>
<div class="paragraph"><p>That command sets a temporary password for the user. The target user will have to change the password the next time they log in.</p></div>
<div class="paragraph"><p>You can use <code class="command">--userid</code> if you want to specify the user by using the <code class="filename">id</code> attribute.</p></div>
<div class="paragraph"><p>You can achieve the same result using the <code class="command">update</code> command on an endpoint constructed from the one you used to get a specific user, such as <code class="filename">users/USER_ID/reset-password</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2/reset-password -r demorealm -s type=password -s value=NEWPASSWORD -s temporary=true -n</code></pre>
<div class="paragraph"><p>The last parameter (<code class="command">-n</code>) ensures that only the <code class="command">PUT</code> command is performed without a prior <code class="command">GET</code> command. It is necessary in this instance because the <code class="command">reset-password</code> endpoint does not support <code class="command">GET</code>.</p></div>
<h4 id="_listing_assigned_available_and_effective_realm_roles_for_a_user" class="discrete">Listing assigned, available, and effective realm roles for a user</h4>
<div class="paragraph"><p>You can use a dedicated <code class="command">get-roles</code> command to list assigned, available, and effective realm roles for a user.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Specify the target user by either user name or ID to list <strong>assigned</strong> realm roles for the user.</p><div class="paragraph"><p>For example:</p></div></li></ol></div>
<pre class="highlight listingblock"><code>$ kcadm.sh get-roles -r demorealm --uusername testuser</code></pre>
<div class="olist arabic"><ol class="arabic"><li><p>Use the additional <code class="command">--effective</code> option to list <strong>effective</strong> realm roles.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --uusername testuser --effective</code></pre></li><li><p>Use the <code class="command">--available</code> option to list realm roles that can still be added to the user.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --uusername testuser --available</code></pre></li></ol></div>
<h4 id="_listing_assigned_available_and_effective_client_roles_for_a_user" class="discrete">Listing assigned, available, and effective client roles for a user</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">get-roles</code> command to list assigned, available, and effective client roles for a user.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Specify the target user by either a user name (via the <code class="command">--uusername</code> option) or an ID (via the <code class="command">--uid</code> option) and client by either a clientId attribute (via the <code class="command">--cclientid</code> option) or an ID (via the <code class="command">--cid</code> option) to list <strong>assigned</strong> client roles for the user.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management</code></pre></li><li><p>Use the additional <code class="command">--effective</code> option to list <strong>effective</strong> realm roles.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management --effective</code></pre></li><li><p>Use the <code class="command">--available</code> option to list realm roles that can still be added to the user.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-management --available</code></pre></li></ol></div>
<h4 id="_adding_realm_roles_to_a_user" class="discrete">Adding realm roles to a user</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">add-roles</code> command to add realm roles to a user.</p></div>
<div class="paragraph"><p>Use the following example to add the <code class="command">user</code> role to user <code class="command">testuser</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh add-roles --uusername testuser --rolename user -r demorealm</code></pre>
<h4 id="_removing_realm_roles_from_a_user" class="discrete">Removing realm roles from a user</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">remove-roles</code> command to remove realm roles from a user.</p></div>
<div class="paragraph"><p>Use the following example to remove the <code class="command">user</code> role from the user <code class="command">testuser</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh remove-roles --uusername testuser --rolename user -r demorealm</code></pre>
<h4 id="_adding_client_roles_to_a_user" class="discrete">Adding client roles to a user</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">add-roles</code> command to add client roles to a user.</p></div>
<div class="paragraph"><p>Use the following example to add two roles defined on the client <code class="command">realm management</code> - <code>create-client</code> role and the <code class="command">view-users</code> role to the user <code>testuser</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh add-roles -r demorealm --uusername testuser --cclientid realm-management --rolename create-client --rolename view-users</code></pre>
<h4 id="_removing_client_roles_from_a_user" class="discrete">Removing client roles from a user</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">remove-roles</code> command to remove client roles from a user.</p></div>
<div class="paragraph"><p>Use the following example to remove two roles defined on the realm management client.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh remove-roles -r demorealm --uusername testuser --cclientid realm-management --rolename create-client --rolename view-users</code></pre>
<h4 id="_listing_a_users_sessions" class="discrete">Listing a user&#8217;s sessions</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Identify the user&#8217;s ID, and then use it to compose an endpoint URI, such as <code class="filename">users/ID/sessions</code>.</p></li><li><p>Use the <code class="command">get</code> command to retrieve a list of the user&#8217;s sessions.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$kcadm get users/6da5ab89-3397-4205-afaa-e201ff638f9e/sessions</code></pre></li></ol></div>
<h4 id="_logging_out_a_user_from_a_specific_session" class="discrete">Logging out a user from a specific session</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Determine the session&#8217;s ID as described above.</p></li><li><p>Use the session&#8217;s ID to compose an endpoint URI, such as <code class="filename">sessions/ID</code>.</p></li><li><p>Use the <code class="command">delete</code> command to invalidate the session.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete sessions/d0eaa7cc-8c5d-489d-811a-69d3c4ec84d1</code></pre></li></ol></div>
<h4 id="_logging_out_a_user_from_all_sessions" class="discrete">Logging out a user from all sessions</h4>
<div class="paragraph"><p>You need a user&#8217;s ID to construct an endpoint URI, such as <code class="filename">users/ID/logout</code>.</p></div>
<div class="paragraph"><p>Use the <code class="command">create</code> command to perform <code class="command">POST</code> on that endpoint URI.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create users/6da5ab89-3397-4205-afaa-e201ff638f9e/logout -r demorealm -s realm=demorealm -s user=6da5ab89-3397-4205-afaa-e201ff638f9e</code></pre></section><section id="_group_operations"><h2>Group operations</h2><h4 id="_creating_a_group" class="discrete">Creating a group</h4>
<div class="paragraph"><p>Use the <code class="command">create</code> command on the <code class="filename">groups</code> endpoint to create a new group.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create groups -r demorealm -s name=Group</code></pre>
<h4 id="_listing_groups" class="discrete">Listing groups</h4>
<div class="paragraph"><p>Use the <code class="command">get</code> command on the <code class="filename">groups</code> endpoint to list groups.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get groups -r demorealm</code></pre>
<h4 id="_getting_a_specific_group" class="discrete">Getting a specific group</h4>
<div class="paragraph"><p>Use the group&#8217;s ID to construct an endpoint URI, such as <code>groups/GROUP_ID</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm</code></pre>
<h4 id="_updating_a_group" class="discrete">Updating a group</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command with the same endpoint URI that you used to get a specific group.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update groups/51204821-0580-46db-8f2d-27106c6b5ded -s 'attributes.email=["group@example.com"]' -r demorealm</code></pre>
<h4 id="_deleting_a_group" class="discrete">Deleting a group</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command with the same endpoint URI that you used to get a specific group.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm</code></pre>
<h4 id="_creating_a_subgroup" class="discrete">Creating a subgroup</h4>
<div class="paragraph"><p>Find the ID of the parent group by listing groups, and then use that ID to construct an endpoint URI, such as <code class="filename">groups/GROUP_ID/children</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r demorealm -s name=SubGroup</code></pre>
<h4 id="_moving_a_group_under_another_group" class="discrete">Moving a group under another group</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Find the ID of an existing parent group and of an existing child group.</p></li><li><p>Use the parent group&#8217;s ID to construct an endpoint URI, such as <code class="filename">groups/PARENT_GROUP_ID/children</code>.</p></li><li><p>Run the <code class="command">create</code> command on this endpoint and pass the child group&#8217;s ID as a JSON body.</p></li></ol></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r demorealm -s id=08d410c6-d585-4059-bb07-54dcb92c5094</code></pre>
<h4 id="_get_groups_for_a_specific_user" class="discrete">Get groups for a specific user</h4>
<div class="paragraph"><p>Use a user&#8217;s ID to determine a user&#8217;s membership in groups to compose an endpoint URI, such as <code class="filename">users/USER_ID/groups</code>.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups -r demorealm</code></pre>
<h4 id="_adding_a_user_to_a_group" class="discrete">Adding a user to a group</h4>
<div class="paragraph"><p>Use the <code class="command">update</code> command with an endpoint URI composed from user&#8217;s ID and a group&#8217;s ID, such as <code class="filename">users/USER_ID/groups/GROUP_ID</code>, to add a user to a group.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh update users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20 -r demorealm -s realm=demorealm -s userId=b544f379-5fc4-49e5-8a8d-5cfb71f46f53 -s groupId=ce01117a-7426-4670-a29a-5c118056fe20 -n</code></pre>
<h4 id="_removing_a_user_from_a_group" class="discrete">Removing a user from a group</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command on the same endpoint URI as used for adding a user to a group, such as <code class="filename">users/USER_ID/groups/GROUP_ID</code>, to remove a user from a group.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20 -r demorealm</code></pre>
<h4 id="_listing_assigned_available_and_effective_realm_roles_for_a_group" class="discrete">Listing assigned, available, and effective realm roles for a group</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">get-roles</code> command to list assigned, available, and effective realm roles for a group.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Specify the target group by name (via the <code class="command">--gname</code> option), path (via the [command] <code>--gpath</code> option), or ID (via the <code class="command">--gid</code> option) to list <strong>assigned</strong> realm roles for the group.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --gname Group</code></pre></li><li><p>Use the additional <code class="command">--effective</code> option to list <strong>effective</strong> realm roles.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --gname Group --effective</code></pre></li><li><p>Use the <code class="command">--available</code> option to list realm roles that can still be added to the group.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --gname Group --available</code></pre></li></ol></div>
<h4 id="_listing_assigned_available_and_effective_client_roles_for_a_group" class="discrete">Listing assigned, available, and effective client roles for a group</h4>
<div class="paragraph"><p>Use a dedicated <code class="command">get-roles</code> command to list assigned, available, and effective client roles for a group.</p></div>
<div class="olist arabic"><ol class="arabic"><li><p>Specify the target group by either name (via the <code class="command">--gname</code> option) or ID (via the <code class="command">--gid</code> option), and client by either the clientId attribute (via the [command] <code>--cclientid</code> option) or ID (via the <code class="command">--id</code> option) to list <strong>assigned</strong> client roles for the user.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management</code></pre></li><li><p>Use the additional <code class="command">--effective</code> option to list <strong>effective</strong> realm roles.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management --effective</code></pre></li><li><p>Use the <code class="command">--available</code> option to list realm roles that can still be added to the group.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management --available</code></pre></li></ol></div></section><section id="_identity_provider_operations"><h2>Identity provider operations</h2><h4 id="_listing_available_identity_providers" class="discrete">Listing available identity providers</h4>
<div class="paragraph"><p>Use the <code class="filename">serverinfo</code> endpoint to list available identity providers.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get serverinfo -r demorealm --fields 'identityProviders(*)'</code></pre>
<div class="admonitionblock note"><table><tr><td class="icon"><div class="title">Note</div></td><td class="content"><div class="paragraph"><p>The <code class="filename">serverinfo</code> endpoint is handled similarly to the <code class="filename">realms</code> endpoint in that it is not resolved relative to a target realm because it exists outside any specific realm.</p></div></td></tr></table></div>
<h4 id="_listing_configured_identity_providers" class="discrete">Listing configured identity providers</h4>
<div class="paragraph"><p>Use the <code class="filename">identity-provider/instances</code> endpoint.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get identity-provider/instances -r demorealm --fields alias,providerId,enabled</code></pre>
<h4 id="_getting_a_specific_configured_identity_provider" class="discrete">Getting a specific configured identity provider</h4>
<div class="paragraph"><p>Use the <code class="command">alias</code> attribute of the identity provider to construct an endpoint URI, such as <code class="filename">identity-provider/instances/ALIAS</code>, to get a specific identity provider.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get identity-provider/instances/facebook -r demorealm</code></pre>
<h4 id="_removing_a_specific_configured_identity_provider" class="discrete">Removing a specific configured identity provider</h4>
<div class="paragraph"><p>Use the <code class="command">delete</code> command with the same endpoint URI that you used to get a specific configured identity provider to remove a specific configured identity provider.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete identity-provider/instances/facebook -r demorealm</code></pre>
<h4 id="_configuring_a_keycloak_openid_connect_identity_provider" class="discrete">Configuring a Keycloak OpenID Connect identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">keycloak-oidc</code> as the <code class="command">providerId</code> when creating a new identity provider instance.</p></li><li><p>Provide the <code class="command">config</code> attributes: <code class="command">authorizationUrl</code>, <code class="command">tokenUrl</code>, <code class="command">clientId</code>, and <code class="command">clientSecret</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=keycloak-oidc -s providerId=keycloak-oidc -s enabled=true -s 'config.useJwksUrl="true"' -s config.authorizationUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-connect/auth -s config.tokenUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-connect/token -s config.clientId=demo-oidc-provider -s config.clientSecret=secret</code></pre></li></ol></div>
<h4 id="_configuring_an_openid_connect_identity_provider" class="discrete">Configuring an OpenID Connect identity provider</h4>
<div class="paragraph"><p>Configure the generic OpenID Connect provider the same way you configure the Keycloak OpenID Connect provider, except that you set the <code class="command">providerId</code> attribute value to <code class="command">oidc</code>.</p></div>
<h4 id="_configuring_a_saml_2_identity_provider" class="discrete">Configuring a SAML 2 identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">saml</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes: <code class="command">singleSignOnServiceUrl</code>, <code class="command">nameIDPolicyFormat</code>, and <code class="command">signatureAlgorithm</code>.</p></li></ol></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=saml -s providerId=saml -s enabled=true -s 'config.useJwksUrl="true"' -s config.singleSignOnServiceUrl=http://localhost:8180/auth/realms/saml-broker-realm/protocol/saml -s config.nameIDPolicyFormat=urn:oasis:names:tc:SAML:2.0:nameid-format:persistent -s config.signatureAlgorithm=RSA_SHA256</code></pre>
<h4 id="_configuring_a_facebook_identity_provider" class="discrete">Configuring a Facebook identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">facebook</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes: <code class="command">clientId</code> and <code class="command">clientSecret</code>. You can find these attributes in the Facebook Developers application configuration page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=facebook -s providerId=facebook -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=FACEBOOK_CLIENT_ID -s config.clientSecret=FACEBOOK_CLIENT_SECRET</code></pre></li></ol></div>
<h4 id="_configuring_a_google_identity_provider" class="discrete">Configuring a Google identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">google</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes: <code class="command">clientId</code> and <code class="command">clientSecret</code>. You can find these attributes in the Google Developers application configuration page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google -s providerId=google -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=GOOGLE_CLIENT_ID -s config.clientSecret=GOOGLE_CLIENT_SECRET</code></pre></li></ol></div>
<h4 id="_configuring_a_twitter_identity_provider" class="discrete">Configuring a Twitter identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">twitter</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes <code class="command">clientId</code> and <code class="command">clientSecret</code>. You can find these attributes in the Twitter Application Management application configuration page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google -s providerId=google -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=TWITTER_API_KEY -s config.clientSecret=TWITTER_API_SECRET</code></pre></li></ol></div>
<h4 id="_configuring_a_github_identity_provider" class="discrete">Configuring a GitHub identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">github</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes <code class="command">clientId</code> and <code class="command">clientSecret</code>. You can find these attributes in the GitHub Developer Application Settings page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=github -s providerId=github -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=GITHUB_CLIENT_ID -s config.clientSecret=GITHUB_CLIENT_SECRET</code></pre></li></ol></div>
<h4 id="_configuring_a_linkedin_identity_provider" class="discrete">Configuring a LinkedIn identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">linkedin</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes <code class="command">clientId</code> and <code class="command">clientSecret</code>. You can find these attributes in the LinkedIn Developer Console application page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=linkedin -s providerId=linkedin -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=LINKEDIN_CLIENT_ID -s config.clientSecret=LINKEDIN_CLIENT_SECRET</code></pre></li></ol></div>
<h4 id="_configuring_a_microsoft_live_identity_provider" class="discrete">Configuring a Microsoft Live identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code class="command">microsoft</code> as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes <code>clientId</code> and <code>clientSecret</code>. You can find these attributes in the Microsoft Application Registration Portal page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=microsoft -s providerId=microsoft -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=MICROSOFT_APP_ID -s config.clientSecret=MICROSOFT_PASSWORD</code></pre></li></ol></div>
<h4 id="_configuring_a_stack_overflow_identity_provider" class="discrete">Configuring a Stack Overflow identity provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use <code>stackoverflow</code> command as the <code class="command">providerId</code>.</p></li><li><p>Provide the <code class="command">config</code> attributes <code class="command">clientId</code>, <code class="command">clientSecret</code>, and <code class="command">key</code>. You can find these attributes in the Stack Apps OAuth page for your application.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create identity-provider/instances -r demorealm -s alias=stackoverflow -s providerId=stackoverflow -s enabled=true  -s 'config.useJwksUrl="true"' -s config.clientId=STACKAPPS_CLIENT_ID -s config.clientSecret=STACKAPPS_CLIENT_SECRET -s config.key=STACKAPPS_KEY</code></pre></li></ol></div></section><section id="_storage_provider_operations"><h2>Storage provider operations</h2><h4 id="_configuring_a_kerberos_storage_provider" class="discrete">Configuring a Kerberos storage provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the <code class="command">create</code> command against the <code class="filename">components</code> endpoint.</p></li><li><p>Specify realm id as a value of the <code class="command">parentId</code> attribute.</p></li><li><p>Specify <code class="command">kerberos</code> as the value of the <code class="command">providerId</code> attribute, and <code class="command">org.keycloak.storage.UserStorageProvider</code> as the value of the <code class="command">providerType</code> attribute.</p></li><li><p>For example:</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s parentId=demorealmId -s id=demokerberos -s name=demokerberos -s providerId=kerberos -s providerType=org.keycloak.storage.UserStorageProvider -s 'config.priority=["0"]' -s 'config.debug=["false"]' -s 'config.allowPasswordAuthentication=["true"]' -s 'config.editMode=["UNSYNCED"]' -s 'config.updateProfileFirstLogin=["true"]' -s 'config.allowKerberosAuthentication=["true"]' -s 'config.kerberosRealm=["KEYCLOAK.ORG"]' -s 'config.keyTab=["http.keytab"]' -s 'config.serverPrincipal=["HTTP/localhost@KEYCLOAK.ORG"]' -s 'config.cachePolicy=["DEFAULT"]'</code></pre></li></ol></div>
<h4 id="_configuring_an_ldap_user_storage_provider" class="discrete">Configuring an LDAP user storage provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the <code class="command">create</code> command against the <code class="filename">components</code> endpoint.</p></li><li><p>Specify <code class="command">ldap</code> as a value of the <code class="command">providerId</code> attribute, and <code class="command">org.keycloak.storage.UserStorageProvider</code> as the value of the <code class="command">providerType</code> attribute.</p></li><li><p>Provide the realm ID as the value of the <code class="command">parentId</code> attribute.</p></li><li><p>Use the following example to create a Kerberos-integrated LDAP provider.</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=kerberos-ldap-provider -s providerId=ldap -s providerType=org.keycloak.storage.UserStorageProvider -s parentId=3d9c572b-8f33-483f-98a6-8bb421667867  -s 'config.priority=["1"]' -s 'config.fullSyncPeriod=["-1"]' -s 'config.changedSyncPeriod=["-1"]' -s 'config.cachePolicy=["DEFAULT"]' -s config.evictionDay=[] -s config.evictionHour=[] -s config.evictionMinute=[] -s config.maxLifespan=[] -s 'config.batchSizeForSync=["1000"]' -s 'config.editMode=["WRITABLE"]' -s 'config.syncRegistrations=["false"]' -s 'config.vendor=["other"]' -s 'config.usernameLDAPAttribute=["uid"]' -s 'config.rdnLDAPAttribute=["uid"]' -s 'config.uuidLDAPAttribute=["entryUUID"]' -s 'config.userObjectClasses=["inetOrgPerson, organizationalPerson"]' -s 'config.connectionUrl=["ldap://localhost:10389"]'  -s 'config.usersDn=["ou=People,dc=keycloak,dc=org"]' -s 'config.authType=["simple"]' -s 'config.bindDn=["uid=admin,ou=system"]' -s 'config.bindCredential=["secret"]' -s 'config.searchScope=["1"]' -s 'config.useTruststoreSpi=["ldapsOnly"]' -s 'config.connectionPooling=["true"]' -s 'config.pagination=["true"]' -s 'config.allowKerberosAuthentication=["true"]' -s 'config.serverPrincipal=["HTTP/localhost@KEYCLOAK.ORG"]' -s 'config.keyTab=["http.keytab"]' -s 'config.kerberosRealm=["KEYCLOAK.ORG"]' -s 'config.debug=["true"]' -s 'config.useKerberosForPasswordAuthentication=["true"]'</code></pre></li></ol></div>
<h4 id="_removing_a_user_storage_provider_instance" class="discrete">Removing a user storage provider instance</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the storage provider instance&#8217;s <code class="command">id</code> attribute to compose an endpoint URI, such as <code class="filename">components/ID</code>.</p></li><li><p>Run the <code class="command">delete</code> command against this endpoint.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh delete components/3d9c572b-8f33-483f-98a6-8bb421667867 -r demorealm</code></pre></li></ol></div>
<h4 id="_triggering_synchronization_of_all_users_for_a_specific_user_storage_provider" class="discrete">Triggering synchronization of all users for a specific user storage provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the storage provider&#8217;s <code class="command">id</code> attribute to compose an endpoint URI, such as <code class="filename">user-storage/ID_OF_USER_STORAGE_INSTANCE/sync</code>.</p></li><li><p>Add the <code class="command">action=triggerFullSync</code> query parameter and run the <code class="command">create</code> command.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create user-storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerFullSync</code></pre></li></ol></div>
<h4 id="_triggering_synchronization_of_changed_users_for_a_specific_user_storage_provider" class="discrete">Triggering synchronization of changed users for a specific user storage provider</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Use the storage provider&#8217;s <code class="command">id</code> attribute to compose an endpoint URI, such as <code class="filename">user-storage/ID_OF_USER_STORAGE_INSTANCE/sync</code>.</p></li><li><p>Add the <code class="command">action=triggerChangedUsersSync</code> query parameter and run the <code class="command">create</code> command.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create user-storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerChangedUsersSync</code></pre></li></ol></div>
<h4 id="_test_ldap_user_storage_connectivity" class="discrete">Test LDAP user storage connectivity</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">get</code> command on the <code class="filename">testLDAPConnection</code> endpoint.</p></li><li><p>Provide query parameters <code class="command">bindCredential</code>, <code class="command">bindDn</code>, <code class="command">connectionUrl</code>, and <code class="command">useTruststoreSpi</code>, and then set the <code class="command">action</code> query parameter to <code class="command">testConnection</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get testLDAPConnection -q action=testConnection -q bindCredential=secret -q bindDn=uid=admin,ou=system -q connectionUrl=ldap://localhost:10389 -q useTruststoreSpi=ldapsOnly</code></pre></li></ol></div>
<h4 id="_test_ldap_user_storage_authentication" class="discrete">Test LDAP user storage authentication</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">get</code> command on the <code class="filename">testLDAPConnection</code> endpoint.</p></li><li><p>Provide the query parameters <code class="command">bindCredential</code>, <code class="command">bindDn</code>, <code class="command">connectionUrl</code>, and <code class="command">useTruststoreSpi</code>, and then set the <code class="command">action</code> query parameter to <code class="command">testAuthentication</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get testLDAPConnection -q action=testAuthentication -q bindCredential=secret -q bindDn=uid=admin,ou=system -q connectionUrl=ldap://localhost:10389 -q useTruststoreSpi=ldapsOnly</code></pre></li></ol></div></section><section id="_adding_mappers"><h2>Adding mappers</h2><h4 id="_adding_a_hardcoded_role_ldap_mapper" class="discrete">Adding a hardcoded role LDAP mapper</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">create</code> command on the <code class="filename">components</code> endpoint.</p></li><li><p>Set the <code class="command">providerType</code> attribute to <code class="filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.</p></li><li><p>Set the <code class="command">parentId</code> attribute to the ID of the LDAP provider instance.</p></li><li><p>Set the <code class="command">providerId</code> attribute to <code class="command">hardcoded-ldap-role-mapper</code>. Make sure to provide a value of <code class="command">role</code> configuration parameter.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=hardcoded-ldap-role-mapper -s providerId=hardcoded-ldap-role-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.role=["realm-management.create-client"]'</code></pre></li></ol></div>
<h4 id="_adding_an_ms_active_directory_mapper" class="discrete">Adding an MS Active Directory mapper</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">create</code> command on the <code class="filename">components</code> endpoint.</p></li><li><p>Set the <code class="command">providerType</code> attribute to <code class="filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.</p></li><li><p>Set the <code class="command">parentId</code> attribute to the ID of the LDAP provider instance.</p></li><li><p>Set the <code class="command">providerId</code> attribute to <code class="filename">msad-user-account-control-mapper</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=msad-user-account-control-mapper -s providerId=msad-user-account-control-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea</code></pre></li></ol></div>
<h4 id="_adding_a_user_attribute_ldap_mapper" class="discrete">Adding a user attribute LDAP mapper</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">create</code> command on the <code class="filename">components</code> endpoint.</p></li><li><p>Set the <code class="command">providerType</code> attribute to <code class="filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.</p></li><li><p>Set the <code class="command">parentId</code> attribute to the ID of the LDAP provider instance.</p></li><li><p>Set the <code class="command">providerId</code> attribute to <code class="filename">user-attribute-ldap-mapper</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=user-attribute-ldap-mapper -s providerId=user-attribute-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config."user.model.attribute"=["email"]' -s 'config."ldap.attribute"=["mail"]' -s 'config."read.only"=["false"]' -s 'config."always.read.value.from.ldap"=["false"]' -s 'config."is.mandatory.in.ldap"=["false"]'</code></pre></li></ol></div>
<h4 id="_adding_a_group_ldap_mapper" class="discrete">Adding a group LDAP mapper</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">create</code> command on the <code class="filename">components</code> endpoint.</p></li><li><p>Set the <code class="command">providerType</code> attribute to <code class="filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.</p></li><li><p>Set the <code class="command">parentId</code> attribute to the ID of the LDAP provider instance.</p></li><li><p>Set the <code class="command">providerId</code> attribute to <code class="filename">group-ldap-mapper</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=group-ldap-mapper -s providerId=group-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config."groups.dn"=[]' -s 'config."group.name.ldap.attribute"=["cn"]' -s 'config."group.object.classes"=["groupOfNames"]' -s 'config."preserve.group.inheritance"=["true"]' -s 'config."membership.ldap.attribute"=["member"]' -s 'config."membership.attribute.type"=["DN"]' -s 'config."groups.ldap.filter"=[]' -s 'config.mode=["LDAP_ONLY"]' -s 'config."user.roles.retrieve.strategy"=["LOAD_GROUPS_BY_MEMBER_ATTRIBUTE"]' -s 'config."mapped.group.attributes"=["admins-group"]' -s 'config."drop.non.existing.groups.during.sync"=["false"]' -s 'config.roles=["admins"]' -s 'config.groups=["admins-group"]' -s 'config.group=[]' -s 'config.preserve=["true"]' -s 'config.membership=["member"]'</code></pre></li></ol></div>
<h4 id="_adding_a_full_name_ldap_mapper" class="discrete">Adding a full name LDAP mapper</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Run the <code class="command">create</code> command on the <code class="filename">components</code> endpoint.</p></li><li><p>Set the <code class="command">providerType</code> attribute to <code class="filename">org.keycloak.storage.ldap.mappers.LDAPStorageMapper</code>.</p></li><li><p>Set the <code class="command">parentId</code> attribute to the ID of the LDAP provider instance.</p></li><li><p>Set the <code class="command">providerId</code> attribute to <code class="filename">full-name-ldap-mapper</code>.</p><div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh create components -r demorealm -s name=full-name-ldap-mapper -s providerId=full-name-ldap-mapper -s providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config."ldap.full.name.attribute"=["cn"]' -s 'config."read.only"=["false"]' -s 'config."write.only"=["true"]'</code></pre></li></ol></div></section><section id="_authentication_operations"><h2>Authentication operations</h2><h4 id="_setting_a_password_policy" class="discrete">Setting a password policy</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Set the realm&#8217;s <code class="command">passwordPolicy</code> attribute to an enumeration expression that includes the specific policy provider ID and optional configuration.</p></li><li><p>Use the following example to set a password policy to default values. The default values include:</p><div class="ulist"><ul><li><p>27,500 hashing iterations</p></li><li><p>at least one special character</p></li><li><p>at least one uppercase character</p></li><li><p>at least one digit character</p></li><li><p>not be equal to a user&#8217;s <code class="filename">username</code></p></li><li><p>be at least eight characters long</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh update realms/demorealm -s 'passwordPolicy="hashIterations and specialChars and upperCase and digits and notUsername and length"'</code></pre></li></ul></div></li><li><p>If you want to use values different from defaults, pass the configuration in brackets.</p></li><li><p>Use the following example to set a password policy to:</p><div class="ulist"><ul><li><p>25,000 hash iterations</p></li><li><p>at least two special characters</p></li><li><p>at least two uppercase characters</p></li><li><p>at least two lowercase characters</p></li><li><p>at least two digits</p></li><li><p>be at least nine characters long</p></li><li><p>not be equal to a user&#8217;s <code class="filename">username</code></p></li><li><p>not repeat for at least four changes back</p><pre class="highlight nowrap listingblock"><code>$ kcadm.sh update realms/demorealm -s 'passwordPolicy="hashIterations(25000) and specialChars(2) and upperCase(2) and lowerCase(2) and digits(2) and length(9) and notUsername and passwordHistory(4)"'</code></pre></li></ul></div></li></ol></div>
<h4 id="_getting_the_current_password_policy" class="discrete">Getting the current password policy</h4>
<div class="paragraph"><p>Get the current realm configuration and filter everything but the <code class="command">passwordPolicy</code> attribute.</p></div>
<div class="paragraph"><p>Use the following example to display <code class="command">passwordPolicy</code> for <code class="filename">demorealm</code>.</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get realms/demorealm --fields passwordPolicy</code></pre>
<h4 id="_listing_authentication_flows" class="discrete">Listing authentication flows</h4>
<div class="paragraph"><p>Run the <code class="command">get</code> command on the <code class="filename">authentication/flows</code> endpoint.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get authentication/flows -r demorealm</code></pre>
<h4 id="_getting_a_specific_authentication_flow" class="discrete">Getting a specific authentication flow</h4>
<div class="paragraph"><p>Run the <code class="command">get</code> command on the <code class="filename">authentication/flows/FLOW_ID</code> endpoint.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get authentication/flows/febfd772-e1a1-42fb-b8ae-00c0566fafb8 -r demorealm</code></pre>
<h4 id="_listing_executions_for_a_flow" class="discrete">Listing executions for a flow</h4>
<div class="paragraph"><p>Run the <code class="command">get</code> command on the <code class="filename">authentication/flows/FLOW_ALIAS/executions</code> endpoint.</p></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm.sh get authentication/flows/Copy%20of%20browser/executions -r demorealm</code></pre>
<h4 id="_adding_configuration_to_an_execution" class="discrete">Adding configuration to an execution</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Get execution for a flow, and take note of its ID</p></li><li><p>Run the <code class="command">create</code> command on the <code class="filename">authentication/executions/{executionId}/config</code> endpoint.</p></li></ol></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm create "authentication/executions/a3147129-c402-4760-86d9-3f2345e401c7/config" -r examplerealm -b '{"config":{"x509-cert-auth.mapping-source-selection":"Match SubjectDN using regular expression","x509-cert-auth.regular-expression":"(.*?)(?:$)","x509-cert-auth.mapper-selection":"Custom Attribute Mapper","x509-cert-auth.mapper-selection.user-attribute-name":"usercertificate","x509-cert-auth.crl-checking-enabled":"","x509-cert-auth.crldp-checking-enabled":false,"x509-cert-auth.crl-relative-path":"crl.pem","x509-cert-auth.ocsp-checking-enabled":"","x509-cert-auth.ocsp-responder-uri":"","x509-cert-auth.keyusage":"","x509-cert-auth.extendedkeyusage":"","x509-cert-auth.confirmation-page-disallowed":""},"alias":"my_otp_config"}'</code></pre>
<h4 id="_getting_configuration_for_an_execution" class="discrete">Getting configuration for an execution</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Get execution for a flow, and get its <code class="filename">authenticationConfig</code> attribute, containing the config ID.</p></li><li><p>Run the <code class="command">get</code> command on the <code class="filename">authentication/config/ID</code> endpoint.</p></li></ol></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm get "authentication/config/dd91611a-d25c-421a-87e2-227c18421833" -r examplerealm</code></pre>
<h4 id="_updating_configuration_for_an_execution" class="discrete">Updating configuration for an execution</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Get execution for a flow, and get its <code class="filename">authenticationConfig</code> attribute, containing the config ID.</p></li><li><p>Run the <code class="command">update</code> command on the <code class="filename">authentication/config/ID</code> endpoint.</p></li></ol></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm update "authentication/config/dd91611a-d25c-421a-87e2-227c18421833" -r examplerealm -b '{"id":"dd91611a-d25c-421a-87e2-227c18421833","alias":"my_otp_config","config":{"x509-cert-auth.extendedkeyusage":"","x509-cert-auth.mapper-selection.user-attribute-name":"usercertificate","x509-cert-auth.ocsp-responder-uri":"","x509-cert-auth.regular-expression":"(.*?)(?:$)","x509-cert-auth.crl-checking-enabled":"true","x509-cert-auth.confirmation-page-disallowed":"","x509-cert-auth.keyusage":"","x509-cert-auth.mapper-selection":"Custom Attribute Mapper","x509-cert-auth.crl-relative-path":"crl.pem","x509-cert-auth.crldp-checking-enabled":"false","x509-cert-auth.mapping-source-selection":"Match SubjectDN using regular expression","x509-cert-auth.ocsp-checking-enabled":""}}'</code></pre>
<h4 id="_deleting_configuration_for_an_execution" class="discrete">Deleting configuration for an execution</h4>
<div class="olist arabic"><ol class="arabic"><li><p>Get execution for a flow, and get its <code class="filename">authenticationConfig</code> attribute, containing the config ID.</p></li><li><p>Run the <code class="command">delete</code> command on the <code class="filename">authentication/config/ID</code> endpoint.</p></li></ol></div>
<div class="paragraph"><p>For example:</p></div>
<pre class="highlight nowrap listingblock"><code>$ kcadm delete "authentication/config/dd91611a-d25c-421a-87e2-227c18421833" -r examplerealm</code></pre></section></section></div></div><script src="node_modules/reveal.js/lib/js/head.min.js"></script><script src="node_modules/reveal.js/js/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
})

// See https://github.com/hakimel/reveal.js#configuration for a full list of configuration options
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Push each slide change to the browser history
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: 960,
  height: 700,

  // Factor of the display size that should remain empty around the content
  margin: 0.1,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 1.5,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'node_modules/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
      
      { src: 'node_modules/reveal.js/plugin/zoom-js/zoom.js', async: true },
      { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true },
      
      
      
      
  ],

  

});</script></body></html>